/* Generated by wayland-scanner 1.23.1 */

#ifndef WAYLAND_CLIENT_PROTOCOL_H
#define WAYLAND_CLIENT_PROTOCOL_H

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_wayland The wayland protocol
 * @section page_ifaces_wayland Interfaces
 * - @subpage page_iface_wl_display - core global object
 * - @subpage page_iface_wl_registry - global registry object
 * - @subpage page_iface_wl_callback - callback object
 * - @subpage page_iface_wl_compositor - the compositor singleton
 * - @subpage page_iface_wl_shm_pool - a shared memory pool
 * - @subpage page_iface_wl_shm - shared memory support
 * - @subpage page_iface_wl_buffer - content for a wl_surface
 * - @subpage page_iface_wl_data_offer - offer to transfer data
 * - @subpage page_iface_wl_data_source - offer to transfer data
 * - @subpage page_iface_wl_data_device - data transfer device
 * - @subpage page_iface_wl_data_device_manager - data transfer interface
 * - @subpage page_iface_wl_shell - create desktop-style surfaces
 * - @subpage page_iface_wl_shell_surface - desktop-style metadata interface
 * - @subpage page_iface_wl_surface - an onscreen surface
 * - @subpage page_iface_wl_seat - group of input devices
 * - @subpage page_iface_wl_pointer - pointer input device
 * - @subpage page_iface_wl_keyboard - keyboard input device
 * - @subpage page_iface_wl_touch - touchscreen input device
 * - @subpage page_iface_wl_output - compositor output region
 * - @subpage page_iface_wl_region - region interface
 * - @subpage page_iface_wl_subcompositor - sub-surface compositing
 * - @subpage page_iface_wl_subsurface - sub-surface interface to a wl_surface
 * @section page_copyright_wayland Copyright
 * <pre>
 *
 * Copyright © 2008-2011 Kristian Høgsberg
 * Copyright © 2010-2011 Intel Corporation
 * Copyright © 2012-2013 Collabora, Ltd.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * </pre>
 */
struct wl_buffer;
struct wl_callback;
struct wl_compositor;
struct wl_data_device;
struct wl_data_device_manager;
struct wl_data_offer;
struct wl_data_source;
struct wl_display;
struct wl_keyboard;
struct wl_output;
struct wl_pointer;
struct wl_region;
struct wl_registry;
struct wl_seat;
struct wl_shell;
struct wl_shell_surface;
struct wl_shm;
struct wl_shm_pool;
struct wl_subcompositor;
struct wl_subsurface;
struct wl_surface;
struct wl_touch;

#ifndef WL_DISPLAY_INTERFACE
#define WL_DISPLAY_INTERFACE
/**
 * @page page_iface_wl_display wl_display
 * @section page_iface_wl_display_desc Description
 *
 * The core global object.  This is a special singleton object.  It
 * is used for internal Wayland protocol features.
 * @section page_iface_wl_display_api API
 * See @ref iface_wl_display.
 */
/**
 * @defgroup iface_wl_display The wl_display interface
 *
 * The core global object.  This is a special singleton object.  It
 * is used for internal Wayland protocol features.
 */
extern const struct wl_interface wl_display_interface;
#endif
#ifndef WL_REGISTRY_INTERFACE
#define WL_REGISTRY_INTERFACE
/**
 * @page page_iface_wl_registry wl_registry
 * @section page_iface_wl_registry_desc Description
 *
 * The singleton global registry object.  The server has a number of
 * global objects that are available to all clients.  These objects
 * typically represent an actual object in the server (for example,
 * an input device) or they are singleton objects that provide
 * extension functionality.
 *
 * When a client creates a registry object, the registry object
 * will emit a global event for each global currently in the
 * registry.  Globals come and go as a result of device or
 * monitor hotplugs, reconfiguration or other events, and the
 * registry will send out global and global_remove events to
 * keep the client up to date with the changes.  To mark the end
 * of the initial burst of events, the client can use the
 * wl_display.sync request immediately after calling
 * wl_display.get_registry.
 *
 * A client can bind to a global object by using the bind
 * request.  This creates a client-side handle that lets the object
 * emit events to the client and lets the client invoke requests on
 * the object.
 * @section page_iface_wl_registry_api API
 * See @ref iface_wl_registry.
 */
/**
 * @defgroup iface_wl_registry The wl_registry interface
 *
 * The singleton global registry object.  The server has a number of
 * global objects that are available to all clients.  These objects
 * typically represent an actual object in the server (for example,
 * an input device) or they are singleton objects that provide
 * extension functionality.
 *
 * When a client creates a registry object, the registry object
 * will emit a global event for each global currently in the
 * registry.  Globals come and go as a result of device or
 * monitor hotplugs, reconfiguration or other events, and the
 * registry will send out global and global_remove events to
 * keep the client up to date with the changes.  To mark the end
 * of the initial burst of events, the client can use the
 * wl_display.sync request immediately after calling
 * wl_display.get_registry.
 *
 * A client can bind to a global object by using the bind
 * request.  This creates a client-side handle that lets the object
 * emit events to the client and lets the client invoke requests on
 * the object.
 */
extern const struct wl_interface wl_registry_interface;
#endif
#ifndef WL_CALLBACK_INTERFACE
#define WL_CALLBACK_INTERFACE
/**
 * @page page_iface_wl_callback wl_callback
 * @section page_iface_wl_callback_desc Description
 *
 * Clients can handle the 'done' event to get notified when
 * the related request is done.
 *
 * Note, because wl_callback objects are created from multiple independent
 * factory interfaces, the wl_callback interface is frozen at version 1.
 * @section page_iface_wl_callback_api API
 * See @ref iface_wl_callback.
 */
/**
 * @defgroup iface_wl_callback The wl_callback interface
 *
 * Clients can handle the 'done' event to get notified when
 * the related request is done.
 *
 * Note, because wl_callback objects are created from multiple independent
 * factory interfaces, the wl_callback interface is frozen at version 1.
 */
extern const struct wl_interface wl_callback_interface;
#endif
#ifndef WL_COMPOSITOR_INTERFACE
#define WL_COMPOSITOR_INTERFACE
/**
 * @page page_iface_wl_compositor wl_compositor
 * @section page_iface_wl_compositor_desc Description
 *
 * A compositor.  This object is a singleton global.  The
 * compositor is in charge of combining the contents of multiple
 * surfaces into one displayable output.
 * @section page_iface_wl_compositor_api API
 * See @ref iface_wl_compositor.
 */
/**
 * @defgroup iface_wl_compositor The wl_compositor interface
 *
 * A compositor.  This object is a singleton global.  The
 * compositor is in charge of combining the contents of multiple
 * surfaces into one displayable output.
 */
extern const struct wl_interface wl_compositor_interface;
#endif
#ifndef WL_SHM_POOL_INTERFACE
#define WL_SHM_POOL_INTERFACE
/**
 * @page page_iface_wl_shm_pool wl_shm_pool
 * @section page_iface_wl_shm_pool_desc Description
 *
 * The wl_shm_pool object encapsulates a piece of memory shared
 * between the compositor and client.  Through the wl_shm_pool
 * object, the client can allocate shared memory wl_buffer objects.
 * All objects created through the same pool share the same
 * underlying mapped memory. Reusing the mapped memory avoids the
 * setup/teardown overhead and is useful when interactively resizing
 * a surface or for many small buffers.
 * @section page_iface_wl_shm_pool_api API
 * See @ref iface_wl_shm_pool.
 */
/**
 * @defgroup iface_wl_shm_pool The wl_shm_pool interface
 *
 * The wl_shm_pool object encapsulates a piece of memory shared
 * between the compositor and client.  Through the wl_shm_pool
 * object, the client can allocate shared memory wl_buffer objects.
 * All objects created through the same pool share the same
 * underlying mapped memory. Reusing the mapped memory avoids the
 * setup/teardown overhead and is useful when interactively resizing
 * a surface or for many small buffers.
 */
extern const struct wl_interface wl_shm_pool_interface;
#endif
#ifndef WL_SHM_INTERFACE
#define WL_SHM_INTERFACE
/**
 * @page page_iface_wl_shm wl_shm
 * @section page_iface_wl_shm_desc Description
 *
 * A singleton global object that provides support for shared
 * memory.
 *
 * Clients can create wl_shm_pool objects using the create_pool
 * request.
 *
 * On binding the wl_shm object one or more format events
 * are emitted to inform clients about the valid pixel formats
 * that can be used for buffers.
 * @section page_iface_wl_shm_api API
 * See @ref iface_wl_shm.
 */
/**
 * @defgroup iface_wl_shm The wl_shm interface
 *
 * A singleton global object that provides support for shared
 * memory.
 *
 * Clients can create wl_shm_pool objects using the create_pool
 * request.
 *
 * On binding the wl_shm object one or more format events
 * are emitted to inform clients about the valid pixel formats
 * that can be used for buffers.
 */
extern const struct wl_interface wl_shm_interface;
#endif
#ifndef WL_BUFFER_INTERFACE
#define WL_BUFFER_INTERFACE
/**
 * @page page_iface_wl_buffer wl_buffer
 * @section page_iface_wl_buffer_desc Description
 *
 * A buffer provides the content for a wl_surface. Buffers are
 * created through factory interfaces such as wl_shm, wp_linux_buffer_params
 * (from the linux-dmabuf protocol extension) or similar. It has a width and
 * a height and can be attached to a wl_surface, but the mechanism by which a
 * client provides and updates the contents is defined by the buffer factory
 * interface.
 *
 * Color channels are assumed to be electrical rather than optical (in other
 * words, encoded with a transfer function) unless otherwise specified. If
 * the buffer uses a format that has an alpha channel, the alpha channel is
 * assumed to be premultiplied into the electrical color channel values
 * (after transfer function encoding) unless otherwise specified.
 *
 * Note, because wl_buffer objects are created from multiple independent
 * factory interfaces, the wl_buffer interface is frozen at version 1.
 * @section page_iface_wl_buffer_api API
 * See @ref iface_wl_buffer.
 */
/**
 * @defgroup iface_wl_buffer The wl_buffer interface
 *
 * A buffer provides the content for a wl_surface. Buffers are
 * created through factory interfaces such as wl_shm, wp_linux_buffer_params
 * (from the linux-dmabuf protocol extension) or similar. It has a width and
 * a height and can be attached to a wl_surface, but the mechanism by which a
 * client provides and updates the contents is defined by the buffer factory
 * interface.
 *
 * Color channels are assumed to be electrical rather than optical (in other
 * words, encoded with a transfer function) unless otherwise specified. If
 * the buffer uses a format that has an alpha channel, the alpha channel is
 * assumed to be premultiplied into the electrical color channel values
 * (after transfer function encoding) unless otherwise specified.
 *
 * Note, because wl_buffer objects are created from multiple independent
 * factory interfaces, the wl_buffer interface is frozen at version 1.
 */
extern const struct wl_interface wl_buffer_interface;
#endif
#ifndef WL_DATA_OFFER_INTERFACE
#define WL_DATA_OFFER_INTERFACE
/**
 * @page page_iface_wl_data_offer wl_data_offer
 * @section page_iface_wl_data_offer_desc Description
 *
 * A wl_data_offer represents a piece of data offered for transfer
 * by another client (the source client).  It is used by the
 * copy-and-paste and drag-and-drop mechanisms.  The offer
 * describes the different mime types that the data can be
 * converted to and provides the mechanism for transferring the
 * data directly from the source client.
 * @section page_iface_wl_data_offer_api API
 * See @ref iface_wl_data_offer.
 */
/**
 * @defgroup iface_wl_data_offer The wl_data_offer interface
 *
 * A wl_data_offer represents a piece of data offered for transfer
 * by another client (the source client).  It is used by the
 * copy-and-paste and drag-and-drop mechanisms.  The offer
 * describes the different mime types that the data can be
 * converted to and provides the mechanism for transferring the
 * data directly from the source client.
 */
extern const struct wl_interface wl_data_offer_interface;
#endif
#ifndef WL_DATA_SOURCE_INTERFACE
#define WL_DATA_SOURCE_INTERFACE
/**
 * @page page_iface_wl_data_source wl_data_source
 * @section page_iface_wl_data_source_desc Description
 *
 * The wl_data_source object is the source side of a wl_data_offer.
 * It is created by the source client in a data transfer and
 * provides a way to describe the offered data and a way to respond
 * to requests to transfer the data.
 * @section page_iface_wl_data_source_api API
 * See @ref iface_wl_data_source.
 */
/**
 * @defgroup iface_wl_data_source The wl_data_source interface
 *
 * The wl_data_source object is the source side of a wl_data_offer.
 * It is created by the source client in a data transfer and
 * provides a way to describe the offered data and a way to respond
 * to requests to transfer the data.
 */
extern const struct wl_interface wl_data_source_interface;
#endif
#ifndef WL_DATA_DEVICE_INTERFACE
#define WL_DATA_DEVICE_INTERFACE
/**
 * @page page_iface_wl_data_device wl_data_device
 * @section page_iface_wl_data_device_desc Description
 *
 * There is one wl_data_device per seat which can be obtained
 * from the global wl_data_device_manager singleton.
 *
 * A wl_data_device provides access to inter-client data transfer
 * mechanisms such as copy-and-paste and drag-and-drop.
 * @section page_iface_wl_data_device_api API
 * See @ref iface_wl_data_device.
 */
/**
 * @defgroup iface_wl_data_device The wl_data_device interface
 *
 * There is one wl_data_device per seat which can be obtained
 * from the global wl_data_device_manager singleton.
 *
 * A wl_data_device provides access to inter-client data transfer
 * mechanisms such as copy-and-paste and drag-and-drop.
 */
extern const struct wl_interface wl_data_device_interface;
#endif
#ifndef WL_DATA_DEVICE_MANAGER_INTERFACE
#define WL_DATA_DEVICE_MANAGER_INTERFACE
/**
 * @page page_iface_wl_data_device_manager wl_data_device_manager
 * @section page_iface_wl_data_device_manager_desc Description
 *
 * The wl_data_device_manager is a singleton global object that
 * provides access to inter-client data transfer mechanisms such as
 * copy-and-paste and drag-and-drop.  These mechanisms are tied to
 * a wl_seat and this interface lets a client get a wl_data_device
 * corresponding to a wl_seat.
 *
 * Depending on the version bound, the objects created from the bound
 * wl_data_device_manager object will have different requirements for
 * functioning properly. See wl_data_source.set_actions,
 * wl_data_offer.accept and wl_data_offer.finish for details.
 * @section page_iface_wl_data_device_manager_api API
 * See @ref iface_wl_data_device_manager.
 */
/**
 * @defgroup iface_wl_data_device_manager The wl_data_device_manager interface
 *
 * The wl_data_device_manager is a singleton global object that
 * provides access to inter-client data transfer mechanisms such as
 * copy-and-paste and drag-and-drop.  These mechanisms are tied to
 * a wl_seat and this interface lets a client get a wl_data_device
 * corresponding to a wl_seat.
 *
 * Depending on the version bound, the objects created from the bound
 * wl_data_device_manager object will have different requirements for
 * functioning properly. See wl_data_source.set_actions,
 * wl_data_offer.accept and wl_data_offer.finish for details.
 */
extern const struct wl_interface wl_data_device_manager_interface;
#endif
#ifndef WL_SHELL_INTERFACE
#define WL_SHELL_INTERFACE
/**
 * @page page_iface_wl_shell wl_shell
 * @section page_iface_wl_shell_desc Description
 *
 * This interface is implemented by servers that provide
 * desktop-style user interfaces.
 *
 * It allows clients to associate a wl_shell_surface with
 * a basic surface.
 *
 * Note! This protocol is deprecated and not intended for production use.
 * For desktop-style user interfaces, use xdg_shell. Compositors and clients
 * should not implement this interface.
 * @section page_iface_wl_shell_api API
 * See @ref iface_wl_shell.
 */
/**
 * @defgroup iface_wl_shell The wl_shell interface
 *
 * This interface is implemented by servers that provide
 * desktop-style user interfaces.
 *
 * It allows clients to associate a wl_shell_surface with
 * a basic surface.
 *
 * Note! This protocol is deprecated and not intended for production use.
 * For desktop-style user interfaces, use xdg_shell. Compositors and clients
 * should not implement this interface.
 */
extern const struct wl_interface wl_shell_interface;
#endif
#ifndef WL_SHELL_SURFACE_INTERFACE
#define WL_SHELL_SURFACE_INTERFACE
/**
 * @page page_iface_wl_shell_surface wl_shell_surface
 * @section page_iface_wl_shell_surface_desc Description
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides requests to treat surfaces like toplevel, fullscreen
 * or popup windows, move, resize or maximize them, associate
 * metadata like title and class, etc.
 *
 * On the server side the object is automatically destroyed when
 * the related wl_surface is destroyed. On the client side,
 * wl_shell_surface_destroy() must be called before destroying
 * the wl_surface object.
 * @section page_iface_wl_shell_surface_api API
 * See @ref iface_wl_shell_surface.
 */
/**
 * @defgroup iface_wl_shell_surface The wl_shell_surface interface
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides requests to treat surfaces like toplevel, fullscreen
 * or popup windows, move, resize or maximize them, associate
 * metadata like title and class, etc.
 *
 * On the server side the object is automatically destroyed when
 * the related wl_surface is destroyed. On the client side,
 * wl_shell_surface_destroy() must be called before destroying
 * the wl_surface object.
 */
extern const struct wl_interface wl_shell_surface_interface;
#endif
#ifndef WL_SURFACE_INTERFACE
#define WL_SURFACE_INTERFACE
/**
 * @page page_iface_wl_surface wl_surface
 * @section page_iface_wl_surface_desc Description
 *
 * A surface is a rectangular area that may be displayed on zero
 * or more outputs, and shown any number of times at the compositor's
 * discretion. They can present wl_buffers, receive user input, and
 * define a local coordinate system.
 *
 * The size of a surface (and relative positions on it) is described
 * in surface-local coordinates, which may differ from the buffer
 * coordinates of the pixel content, in case a buffer_transform
 * or a buffer_scale is used.
 *
 * A surface without a "role" is fairly useless: a compositor does
 * not know where, when or how to present it. The role is the
 * purpose of a wl_surface. Examples of roles are a cursor for a
 * pointer (as set by wl_pointer.set_cursor), a drag icon
 * (wl_data_device.start_drag), a sub-surface
 * (wl_subcompositor.get_subsurface), and a window as defined by a
 * shell protocol (e.g. wl_shell.get_shell_surface).
 *
 * A surface can have only one role at a time. Initially a
 * wl_surface does not have a role. Once a wl_surface is given a
 * role, it is set permanently for the whole lifetime of the
 * wl_surface object. Giving the current role again is allowed,
 * unless explicitly forbidden by the relevant interface
 * specification.
 *
 * Surface roles are given by requests in other interfaces such as
 * wl_pointer.set_cursor. The request should explicitly mention
 * that this request gives a role to a wl_surface. Often, this
 * request also creates a new protocol object that represents the
 * role and adds additional functionality to wl_surface. When a
 * client wants to destroy a wl_surface, they must destroy this role
 * object before the wl_surface, otherwise a defunct_role_object error is
 * sent.
 *
 * Destroying the role object does not remove the role from the
 * wl_surface, but it may stop the wl_surface from "playing the role".
 * For instance, if a wl_subsurface object is destroyed, the wl_surface
 * it was created for will be unmapped and forget its position and
 * z-order. It is allowed to create a wl_subsurface for the same
 * wl_surface again, but it is not allowed to use the wl_surface as
 * a cursor (cursor is a different role than sub-surface, and role
 * switching is not allowed).
 * @section page_iface_wl_surface_api API
 * See @ref iface_wl_surface.
 */
/**
 * @defgroup iface_wl_surface The wl_surface interface
 *
 * A surface is a rectangular area that may be displayed on zero
 * or more outputs, and shown any number of times at the compositor's
 * discretion. They can present wl_buffers, receive user input, and
 * define a local coordinate system.
 *
 * The size of a surface (and relative positions on it) is described
 * in surface-local coordinates, which may differ from the buffer
 * coordinates of the pixel content, in case a buffer_transform
 * or a buffer_scale is used.
 *
 * A surface without a "role" is fairly useless: a compositor does
 * not know where, when or how to present it. The role is the
 * purpose of a wl_surface. Examples of roles are a cursor for a
 * pointer (as set by wl_pointer.set_cursor), a drag icon
 * (wl_data_device.start_drag), a sub-surface
 * (wl_subcompositor.get_subsurface), and a window as defined by a
 * shell protocol (e.g. wl_shell.get_shell_surface).
 *
 * A surface can have only one role at a time. Initially a
 * wl_surface does not have a role. Once a wl_surface is given a
 * role, it is set permanently for the whole lifetime of the
 * wl_surface object. Giving the current role again is allowed,
 * unless explicitly forbidden by the relevant interface
 * specification.
 *
 * Surface roles are given by requests in other interfaces such as
 * wl_pointer.set_cursor. The request should explicitly mention
 * that this request gives a role to a wl_surface. Often, this
 * request also creates a new protocol object that represents the
 * role and adds additional functionality to wl_surface. When a
 * client wants to destroy a wl_surface, they must destroy this role
 * object before the wl_surface, otherwise a defunct_role_object error is
 * sent.
 *
 * Destroying the role object does not remove the role from the
 * wl_surface, but it may stop the wl_surface from "playing the role".
 * For instance, if a wl_subsurface object is destroyed, the wl_surface
 * it was created for will be unmapped and forget its position and
 * z-order. It is allowed to create a wl_subsurface for the same
 * wl_surface again, but it is not allowed to use the wl_surface as
 * a cursor (cursor is a different role than sub-surface, and role
 * switching is not allowed).
 */
extern const struct wl_interface wl_surface_interface;
#endif
#ifndef WL_SEAT_INTERFACE
#define WL_SEAT_INTERFACE
/**
 * @page page_iface_wl_seat wl_seat
 * @section page_iface_wl_seat_desc Description
 *
 * A seat is a group of keyboards, pointer and touch devices. This
 * object is published as a global during start up, or when such a
 * device is hot plugged.  A seat typically has a pointer and
 * maintains a keyboard focus and a pointer focus.
 * @section page_iface_wl_seat_api API
 * See @ref iface_wl_seat.
 */
/**
 * @defgroup iface_wl_seat The wl_seat interface
 *
 * A seat is a group of keyboards, pointer and touch devices. This
 * object is published as a global during start up, or when such a
 * device is hot plugged.  A seat typically has a pointer and
 * maintains a keyboard focus and a pointer focus.
 */
extern const struct wl_interface wl_seat_interface;
#endif
#ifndef WL_POINTER_INTERFACE
#define WL_POINTER_INTERFACE
/**
 * @page page_iface_wl_pointer wl_pointer
 * @section page_iface_wl_pointer_desc Description
 *
 * The wl_pointer interface represents one or more input devices,
 * such as mice, which control the pointer location and pointer_focus
 * of a seat.
 *
 * The wl_pointer interface generates motion, enter and leave
 * events for the surfaces that the pointer is located over,
 * and button and axis events for button presses, button releases
 * and scrolling.
 * @section page_iface_wl_pointer_api API
 * See @ref iface_wl_pointer.
 */
/**
 * @defgroup iface_wl_pointer The wl_pointer interface
 *
 * The wl_pointer interface represents one or more input devices,
 * such as mice, which control the pointer location and pointer_focus
 * of a seat.
 *
 * The wl_pointer interface generates motion, enter and leave
 * events for the surfaces that the pointer is located over,
 * and button and axis events for button presses, button releases
 * and scrolling.
 */
extern const struct wl_interface wl_pointer_interface;
#endif
#ifndef WL_KEYBOARD_INTERFACE
#define WL_KEYBOARD_INTERFACE
/**
 * @page page_iface_wl_keyboard wl_keyboard
 * @section page_iface_wl_keyboard_desc Description
 *
 * The wl_keyboard interface represents one or more keyboards
 * associated with a seat.
 *
 * Each wl_keyboard has the following logical state:
 *
 * - an active surface (possibly null),
 * - the keys currently logically down,
 * - the active modifiers,
 * - the active group.
 *
 * By default, the active surface is null, the keys currently logically down
 * are empty, the active modifiers and the active group are 0.
 * @section page_iface_wl_keyboard_api API
 * See @ref iface_wl_keyboard.
 */
/**
 * @defgroup iface_wl_keyboard The wl_keyboard interface
 *
 * The wl_keyboard interface represents one or more keyboards
 * associated with a seat.
 *
 * Each wl_keyboard has the following logical state:
 *
 * - an active surface (possibly null),
 * - the keys currently logically down,
 * - the active modifiers,
 * - the active group.
 *
 * By default, the active surface is null, the keys currently logically down
 * are empty, the active modifiers and the active group are 0.
 */
extern const struct wl_interface wl_keyboard_interface;
#endif
#ifndef WL_TOUCH_INTERFACE
#define WL_TOUCH_INTERFACE
/**
 * @page page_iface_wl_touch wl_touch
 * @section page_iface_wl_touch_desc Description
 *
 * The wl_touch interface represents a touchscreen
 * associated with a seat.
 *
 * Touch interactions can consist of one or more contacts.
 * For each contact, a series of events is generated, starting
 * with a down event, followed by zero or more motion events,
 * and ending with an up event. Events relating to the same
 * contact point can be identified by the ID of the sequence.
 * @section page_iface_wl_touch_api API
 * See @ref iface_wl_touch.
 */
/**
 * @defgroup iface_wl_touch The wl_touch interface
 *
 * The wl_touch interface represents a touchscreen
 * associated with a seat.
 *
 * Touch interactions can consist of one or more contacts.
 * For each contact, a series of events is generated, starting
 * with a down event, followed by zero or more motion events,
 * and ending with an up event. Events relating to the same
 * contact point can be identified by the ID of the sequence.
 */
extern const struct wl_interface wl_touch_interface;
#endif
#ifndef WL_OUTPUT_INTERFACE
#define WL_OUTPUT_INTERFACE
/**
 * @page page_iface_wl_output wl_output
 * @section page_iface_wl_output_desc Description
 *
 * An output describes part of the compositor geometry.  The
 * compositor works in the 'compositor coordinate system' and an
 * output corresponds to a rectangular area in that space that is
 * actually visible.  This typically corresponds to a monitor that
 * displays part of the compositor space.  This object is published
 * as global during start up, or when a monitor is hotplugged.
 * @section page_iface_wl_output_api API
 * See @ref iface_wl_output.
 */
/**
 * @defgroup iface_wl_output The wl_output interface
 *
 * An output describes part of the compositor geometry.  The
 * compositor works in the 'compositor coordinate system' and an
 * output corresponds to a rectangular area in that space that is
 * actually visible.  This typically corresponds to a monitor that
 * displays part of the compositor space.  This object is published
 * as global during start up, or when a monitor is hotplugged.
 */
extern const struct wl_interface wl_output_interface;
#endif
#ifndef WL_REGION_INTERFACE
#define WL_REGION_INTERFACE
/**
 * @page page_iface_wl_region wl_region
 * @section page_iface_wl_region_desc Description
 *
 * A region object describes an area.
 *
 * Region objects are used to describe the opaque and input
 * regions of a surface.
 * @section page_iface_wl_region_api API
 * See @ref iface_wl_region.
 */
/**
 * @defgroup iface_wl_region The wl_region interface
 *
 * A region object describes an area.
 *
 * Region objects are used to describe the opaque and input
 * regions of a surface.
 */
extern const struct wl_interface wl_region_interface;
#endif
#ifndef WL_SUBCOMPOSITOR_INTERFACE
#define WL_SUBCOMPOSITOR_INTERFACE
/**
 * @page page_iface_wl_subcompositor wl_subcompositor
 * @section page_iface_wl_subcompositor_desc Description
 *
 * The global interface exposing sub-surface compositing capabilities.
 * A wl_surface, that has sub-surfaces associated, is called the
 * parent surface. Sub-surfaces can be arbitrarily nested and create
 * a tree of sub-surfaces.
 *
 * The root surface in a tree of sub-surfaces is the main
 * surface. The main surface cannot be a sub-surface, because
 * sub-surfaces must always have a parent.
 *
 * A main surface with its sub-surfaces forms a (compound) window.
 * For window management purposes, this set of wl_surface objects is
 * to be considered as a single window, and it should also behave as
 * such.
 *
 * The aim of sub-surfaces is to offload some of the compositing work
 * within a window from clients to the compositor. A prime example is
 * a video player with decorations and video in separate wl_surface
 * objects. This should allow the compositor to pass YUV video buffer
 * processing to dedicated overlay hardware when possible.
 * @section page_iface_wl_subcompositor_api API
 * See @ref iface_wl_subcompositor.
 */
/**
 * @defgroup iface_wl_subcompositor The wl_subcompositor interface
 *
 * The global interface exposing sub-surface compositing capabilities.
 * A wl_surface, that has sub-surfaces associated, is called the
 * parent surface. Sub-surfaces can be arbitrarily nested and create
 * a tree of sub-surfaces.
 *
 * The root surface in a tree of sub-surfaces is the main
 * surface. The main surface cannot be a sub-surface, because
 * sub-surfaces must always have a parent.
 *
 * A main surface with its sub-surfaces forms a (compound) window.
 * For window management purposes, this set of wl_surface objects is
 * to be considered as a single window, and it should also behave as
 * such.
 *
 * The aim of sub-surfaces is to offload some of the compositing work
 * within a window from clients to the compositor. A prime example is
 * a video player with decorations and video in separate wl_surface
 * objects. This should allow the compositor to pass YUV video buffer
 * processing to dedicated overlay hardware when possible.
 */
extern const struct wl_interface wl_subcompositor_interface;
#endif
#ifndef WL_SUBSURFACE_INTERFACE
#define WL_SUBSURFACE_INTERFACE
/**
 * @page page_iface_wl_subsurface wl_subsurface
 * @section page_iface_wl_subsurface_desc Description
 *
 * An additional interface to a wl_surface object, which has been
 * made a sub-surface. A sub-surface has one parent surface. A
 * sub-surface's size and position are not limited to that of the parent.
 * Particularly, a sub-surface is not automatically clipped to its
 * parent's area.
 *
 * A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
 * and the parent surface is mapped. The order of which one happens
 * first is irrelevant. A sub-surface is hidden if the parent becomes
 * hidden, or if a NULL wl_buffer is applied. These rules apply
 * recursively through the tree of surfaces.
 *
 * The behaviour of a wl_surface.commit request on a sub-surface
 * depends on the sub-surface's mode. The possible modes are
 * synchronized and desynchronized, see methods
 * wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
 * mode caches the wl_surface state to be applied when the parent's
 * state gets applied, and desynchronized mode applies the pending
 * wl_surface state directly. A sub-surface is initially in the
 * synchronized mode.
 *
 * Sub-surfaces also have another kind of state, which is managed by
 * wl_subsurface requests, as opposed to wl_surface requests. This
 * state includes the sub-surface position relative to the parent
 * surface (wl_subsurface.set_position), and the stacking order of
 * the parent and its sub-surfaces (wl_subsurface.place_above and
 * .place_below). This state is applied when the parent surface's
 * wl_surface state is applied, regardless of the sub-surface's mode.
 * As the exception, set_sync and set_desync are effective immediately.
 *
 * The main surface can be thought to be always in desynchronized mode,
 * since it does not have a parent in the sub-surfaces sense.
 *
 * Even if a sub-surface is in desynchronized mode, it will behave as
 * in synchronized mode, if its parent surface behaves as in
 * synchronized mode. This rule is applied recursively throughout the
 * tree of surfaces. This means, that one can set a sub-surface into
 * synchronized mode, and then assume that all its child and grand-child
 * sub-surfaces are synchronized, too, without explicitly setting them.
 *
 * Destroying a sub-surface takes effect immediately. If you need to
 * synchronize the removal of a sub-surface to the parent surface update,
 * unmap the sub-surface first by attaching a NULL wl_buffer, update parent,
 * and then destroy the sub-surface.
 *
 * If the parent wl_surface object is destroyed, the sub-surface is
 * unmapped.
 *
 * A sub-surface never has the keyboard focus of any seat.
 *
 * The wl_surface.offset request is ignored: clients must use set_position
 * instead to move the sub-surface.
 * @section page_iface_wl_subsurface_api API
 * See @ref iface_wl_subsurface.
 */
/**
 * @defgroup iface_wl_subsurface The wl_subsurface interface
 *
 * An additional interface to a wl_surface object, which has been
 * made a sub-surface. A sub-surface has one parent surface. A
 * sub-surface's size and position are not limited to that of the parent.
 * Particularly, a sub-surface is not automatically clipped to its
 * parent's area.
 *
 * A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
 * and the parent surface is mapped. The order of which one happens
 * first is irrelevant. A sub-surface is hidden if the parent becomes
 * hidden, or if a NULL wl_buffer is applied. These rules apply
 * recursively through the tree of surfaces.
 *
 * The behaviour of a wl_surface.commit request on a sub-surface
 * depends on the sub-surface's mode. The possible modes are
 * synchronized and desynchronized, see methods
 * wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
 * mode caches the wl_surface state to be applied when the parent's
 * state gets applied, and desynchronized mode applies the pending
 * wl_surface state directly. A sub-surface is initially in the
 * synchronized mode.
 *
 * Sub-surfaces also have another kind of state, which is managed by
 * wl_subsurface requests, as opposed to wl_surface requests. This
 * state includes the sub-surface position relative to the parent
 * surface (wl_subsurface.set_position), and the stacking order of
 * the parent and its sub-surfaces (wl_subsurface.place_above and
 * .place_below). This state is applied when the parent surface's
 * wl_surface state is applied, regardless of the sub-surface's mode.
 * As the exception, set_sync and set_desync are effective immediately.
 *
 * The main surface can be thought to be always in desynchronized mode,
 * since it does not have a parent in the sub-surfaces sense.
 *
 * Even if a sub-surface is in desynchronized mode, it will behave as
 * in synchronized mode, if its parent surface behaves as in
 * synchronized mode. This rule is applied recursively throughout the
 * tree of surfaces. This means, that one can set a sub-surface into
 * synchronized mode, and then assume that all its child and grand-child
 * sub-surfaces are synchronized, too, without explicitly setting them.
 *
 * Destroying a sub-surface takes effect immediately. If you need to
 * synchronize the removal of a sub-surface to the parent surface update,
 * unmap the sub-surface first by attaching a NULL wl_buffer, update parent,
 * and then destroy the sub-surface.
 *
 * If the parent wl_surface object is destroyed, the sub-surface is
 * unmapped.
 *
 * A sub-surface never has the keyboard focus of any seat.
 *
 * The wl_surface.offset request is ignored: clients must use set_position
 * instead to move the sub-surface.
 */
extern const struct wl_interface wl_subsurface_interface;
#endif

#ifndef WL_DISPLAY_ERROR_ENUM
#define WL_DISPLAY_ERROR_ENUM
/**
 * @ingroup iface_wl_display
 * global error values
 *
 * These errors are global and can be emitted in response to any
 * server request.
 */
enum wl_display_error {
	/**
	 * server couldn't find object
	 */
	WL_DISPLAY_ERROR_INVALID_OBJECT = 0,
	/**
	 * method doesn't exist on the specified interface or malformed request
	 */
	WL_DISPLAY_ERROR_INVALID_METHOD = 1,
	/**
	 * server is out of memory
	 */
	WL_DISPLAY_ERROR_NO_MEMORY = 2,
	/**
	 * implementation error in compositor
	 */
	WL_DISPLAY_ERROR_IMPLEMENTATION = 3,
};
#endif /* WL_DISPLAY_ERROR_ENUM */

/**
 * @ingroup iface_wl_display
 * @struct wl_display_listener
 */
struct wl_display_listener {
	/**
	 * fatal error event
	 *
	 * The error event is sent out when a fatal (non-recoverable)
	 * error has occurred. The object_id argument is the object where
	 * the error occurred, most often in response to a request to that
	 * object. The code identifies the error and is defined by the
	 * object interface. As such, each interface defines its own set of
	 * error codes. The message is a brief description of the error,
	 * for (debugging) convenience.
	 * @param object_id object where the error occurred
	 * @param code error code
	 * @param message error description
	 */
	void (*error)(void *data,
		      struct wl_display *wl_display,
		      void *object_id,
		      uint32_t code,
		      const char *message);
	/**
	 * acknowledge object ID deletion
	 *
	 * This event is used internally by the object ID management
	 * logic. When a client deletes an object that it had created, the
	 * server will send this event to acknowledge that it has seen the
	 * delete request. When the client receives this event, it will
	 * know that it can safely reuse the object ID.
	 * @param id deleted object ID
	 */
	void (*delete_id)(void *data,
			  struct wl_display *wl_display,
			  uint32_t id);
};

/**
 * @ingroup iface_wl_display
 */
static inline int
wl_display_add_listener(struct wl_display *wl_display,
			const struct wl_display_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_display,
				     (void (**)(void)) listener, data);
}

#define WL_DISPLAY_SYNC 0
#define WL_DISPLAY_GET_REGISTRY 1

/**
 * @ingroup iface_wl_display
 */
#define WL_DISPLAY_ERROR_SINCE_VERSION 1
/**
 * @ingroup iface_wl_display
 */
#define WL_DISPLAY_DELETE_ID_SINCE_VERSION 1

/**
 * @ingroup iface_wl_display
 */
#define WL_DISPLAY_SYNC_SINCE_VERSION 1
/**
 * @ingroup iface_wl_display
 */
#define WL_DISPLAY_GET_REGISTRY_SINCE_VERSION 1

/** @ingroup iface_wl_display */
static inline void
wl_display_set_user_data(struct wl_display *wl_display, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_display, user_data);
}

/** @ingroup iface_wl_display */
static inline void *
wl_display_get_user_data(struct wl_display *wl_display)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_display);
}

static inline uint32_t
wl_display_get_version(struct wl_display *wl_display)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_display);
}

/**
 * @ingroup iface_wl_display
 *
 * The sync request asks the server to emit the 'done' event
 * on the returned wl_callback object.  Since requests are
 * handled in-order and events are delivered in-order, this can
 * be used as a barrier to ensure all previous requests and the
 * resulting events have been handled.
 *
 * The object returned by this request will be destroyed by the
 * compositor after the callback is fired and as such the client must not
 * attempt to use it after that point.
 *
 * The callback_data passed in the callback is undefined and should be ignored.
 */
static inline struct wl_callback *
wl_display_sync(struct wl_display *wl_display)
{
	struct wl_proxy *callback;

	callback = wl_proxy_marshal_flags((struct wl_proxy *) wl_display,
			 WL_DISPLAY_SYNC, &wl_callback_interface, wl_proxy_get_version((struct wl_proxy *) wl_display), 0, NULL);

	return (struct wl_callback *) callback;
}

/**
 * @ingroup iface_wl_display
 *
 * This request creates a registry object that allows the client
 * to list and bind the global objects available from the
 * compositor.
 *
 * It should be noted that the server side resources consumed in
 * response to a get_registry request can only be released when the
 * client disconnects, not when the client side proxy is destroyed.
 * Therefore, clients should invoke get_registry as infrequently as
 * possible to avoid wasting memory.
 */
static inline struct wl_registry *
wl_display_get_registry(struct wl_display *wl_display)
{
	struct wl_proxy *registry;

	registry = wl_proxy_marshal_flags((struct wl_proxy *) wl_display,
			 WL_DISPLAY_GET_REGISTRY, &wl_registry_interface, wl_proxy_get_version((struct wl_proxy *) wl_display), 0, NULL);

	return (struct wl_registry *) registry;
}

/**
 * @ingroup iface_wl_registry
 * @struct wl_registry_listener
 */
struct wl_registry_listener {
	/**
	 * announce global object
	 *
	 * Notify the client of global objects.
	 *
	 * The event notifies the client that a global object with the
	 * given name is now available, and it implements the given version
	 * of the given interface.
	 * @param name numeric name of the global object
	 * @param interface interface implemented by the object
	 * @param version interface version
	 */
	void (*global)(void *data,
		       struct wl_registry *wl_registry,
		       uint32_t name,
		       const char *interface,
		       uint32_t version);
	/**
	 * announce removal of global object
	 *
	 * Notify the client of removed global objects.
	 *
	 * This event notifies the client that the global identified by
	 * name is no longer available. If the client bound to the global
	 * using the bind request, the client should now destroy that
	 * object.
	 *
	 * The object remains valid and requests to the object will be
	 * ignored until the client destroys it, to avoid races between the
	 * global going away and a client sending a request to it.
	 * @param name numeric name of the global object
	 */
	void (*global_remove)(void *data,
			      struct wl_registry *wl_registry,
			      uint32_t name);
};

/**
 * @ingroup iface_wl_registry
 */
static inline int
wl_registry_add_listener(struct wl_registry *wl_registry,
			 const struct wl_registry_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_registry,
				     (void (**)(void)) listener, data);
}

#define WL_REGISTRY_BIND 0

/**
 * @ingroup iface_wl_registry
 */
#define WL_REGISTRY_GLOBAL_SINCE_VERSION 1
/**
 * @ingroup iface_wl_registry
 */
#define WL_REGISTRY_GLOBAL_REMOVE_SINCE_VERSION 1

/**
 * @ingroup iface_wl_registry
 */
#define WL_REGISTRY_BIND_SINCE_VERSION 1

/** @ingroup iface_wl_registry */
static inline void
wl_registry_set_user_data(struct wl_registry *wl_registry, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_registry, user_data);
}

/** @ingroup iface_wl_registry */
static inline void *
wl_registry_get_user_data(struct wl_registry *wl_registry)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_registry);
}

static inline uint32_t
wl_registry_get_version(struct wl_registry *wl_registry)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_registry);
}

/** @ingroup iface_wl_registry */
static inline void
wl_registry_destroy(struct wl_registry *wl_registry)
{
	wl_proxy_destroy((struct wl_proxy *) wl_registry);
}

/**
 * @ingroup iface_wl_registry
 *
 * Binds a new, client-created object to the server using the
 * specified name as the identifier.
 */
static inline void *
wl_registry_bind(struct wl_registry *wl_registry, uint32_t name, const struct wl_interface *interface, uint32_t version)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) wl_registry,
			 WL_REGISTRY_BIND, interface, version, 0, name, interface->name, version, NULL);

	return (void *) id;
}

/**
 * @ingroup iface_wl_callback
 * @struct wl_callback_listener
 */
struct wl_callback_listener {
	/**
	 * done event
	 *
	 * Notify the client when the related request is done.
	 * @param callback_data request-specific data for the callback
	 */
	void (*done)(void *data,
		     struct wl_callback *wl_callback,
		     uint32_t callback_data);
};

/**
 * @ingroup iface_wl_callback
 */
static inline int
wl_callback_add_listener(struct wl_callback *wl_callback,
			 const struct wl_callback_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_callback,
				     (void (**)(void)) listener, data);
}

/**
 * @ingroup iface_wl_callback
 */
#define WL_CALLBACK_DONE_SINCE_VERSION 1


/** @ingroup iface_wl_callback */
static inline void
wl_callback_set_user_data(struct wl_callback *wl_callback, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_callback, user_data);
}

/** @ingroup iface_wl_callback */
static inline void *
wl_callback_get_user_data(struct wl_callback *wl_callback)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_callback);
}

static inline uint32_t
wl_callback_get_version(struct wl_callback *wl_callback)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_callback);
}

/** @ingroup iface_wl_callback */
static inline void
wl_callback_destroy(struct wl_callback *wl_callback)
{
	wl_proxy_destroy((struct wl_proxy *) wl_callback);
}

#define WL_COMPOSITOR_CREATE_SURFACE 0
#define WL_COMPOSITOR_CREATE_REGION 1


/**
 * @ingroup iface_wl_compositor
 */
#define WL_COMPOSITOR_CREATE_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_wl_compositor
 */
#define WL_COMPOSITOR_CREATE_REGION_SINCE_VERSION 1

/** @ingroup iface_wl_compositor */
static inline void
wl_compositor_set_user_data(struct wl_compositor *wl_compositor, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_compositor, user_data);
}

/** @ingroup iface_wl_compositor */
static inline void *
wl_compositor_get_user_data(struct wl_compositor *wl_compositor)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_compositor);
}

static inline uint32_t
wl_compositor_get_version(struct wl_compositor *wl_compositor)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_compositor);
}

/** @ingroup iface_wl_compositor */
static inline void
wl_compositor_destroy(struct wl_compositor *wl_compositor)
{
	wl_proxy_destroy((struct wl_proxy *) wl_compositor);
}

/**
 * @ingroup iface_wl_compositor
 *
 * Ask the compositor to create a new surface.
 */
static inline struct wl_surface *
wl_compositor_create_surface(struct wl_compositor *wl_compositor)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) wl_compositor,
			 WL_COMPOSITOR_CREATE_SURFACE, &wl_surface_interface, wl_proxy_get_version((struct wl_proxy *) wl_compositor), 0, NULL);

	return (struct wl_surface *) id;
}

/**
 * @ingroup iface_wl_compositor
 *
 * Ask the compositor to create a new region.
 */
static inline struct wl_region *
wl_compositor_create_region(struct wl_compositor *wl_compositor)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) wl_compositor,
			 WL_COMPOSITOR_CREATE_REGION, &wl_region_interface, wl_proxy_get_version((struct wl_proxy *) wl_compositor), 0, NULL);

	return (struct wl_region *) id;
}

#define WL_SHM_POOL_CREATE_BUFFER 0
#define WL_SHM_POOL_DESTROY 1
#define WL_SHM_POOL_RESIZE 2


/**
 * @ingroup iface_wl_shm_pool
 */
#define WL_SHM_POOL_CREATE_BUFFER_SINCE_VERSION 1
/**
 * @ingroup iface_wl_shm_pool
 */
#define WL_SHM_POOL_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_wl_shm_pool
 */
#define WL_SHM_POOL_RESIZE_SINCE_VERSION 1

/** @ingroup iface_wl_shm_pool */
static inline void
wl_shm_pool_set_user_data(struct wl_shm_pool *wl_shm_pool, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_shm_pool, user_data);
}

/** @ingroup iface_wl_shm_pool */
static inline void *
wl_shm_pool_get_user_data(struct wl_shm_pool *wl_shm_pool)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_shm_pool);
}

static inline uint32_t
wl_shm_pool_get_version(struct wl_shm_pool *wl_shm_pool)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_shm_pool);
}

/**
 * @ingroup iface_wl_shm_pool
 *
 * Create a wl_buffer object from the pool.
 *
 * The buffer is created offset bytes into the pool and has
 * width and height as specified.  The stride argument specifies
 * the number of bytes from the beginning of one row to the beginning
 * of the next.  The format is the pixel format of the buffer and
 * must be one of those advertised through the wl_shm.format event.
 *
 * A buffer will keep a reference to the pool it was created from
 * so it is valid to destroy the pool immediately after creating
 * a buffer from it.
 */
static inline struct wl_buffer *
wl_shm_pool_create_buffer(struct wl_shm_pool *wl_shm_pool, int32_t offset, int32_t width, int32_t height, int32_t stride, uint32_t format)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) wl_shm_pool,
			 WL_SHM_POOL_CREATE_BUFFER, &wl_buffer_interface, wl_proxy_get_version((struct wl_proxy *) wl_shm_pool), 0, NULL, offset, width, height, stride, format);

	return (struct wl_buffer *) id;
}

/**
 * @ingroup iface_wl_shm_pool
 *
 * Destroy the shared memory pool.
 *
 * The mmapped memory will be released when all
 * buffers that have been created from this pool
 * are gone.
 */
static inline void
wl_shm_pool_destroy(struct wl_shm_pool *wl_shm_pool)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_shm_pool,
			 WL_SHM_POOL_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) wl_shm_pool), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_wl_shm_pool
 *
 * This request will cause the server to remap the backing memory
 * for the pool from the file descriptor passed when the pool was
 * created, but using the new size.  This request can only be
 * used to make the pool bigger.
 *
 * This request only changes the amount of bytes that are mmapped
 * by the server and does not touch the file corresponding to the
 * file descriptor passed at creation time. It is the client's
 * responsibility to ensure that the file is at least as big as
 * the new pool size.
 */
static inline void
wl_shm_pool_resize(struct wl_shm_pool *wl_shm_pool, int32_t size)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_shm_pool,
			 WL_SHM_POOL_RESIZE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_shm_pool), 0, size);
}

#ifndef WL_SHM_ERROR_ENUM
#define WL_SHM_ERROR_ENUM
/**
 * @ingroup iface_wl_shm
 * wl_shm error values
 *
 * These errors can be emitted in response to wl_shm requests.
 */
enum wl_shm_error {
	/**
	 * buffer format is not known
	 */
	WL_SHM_ERROR_INVALID_FORMAT = 0,
	/**
	 * invalid size or stride during pool or buffer creation
	 */
	WL_SHM_ERROR_INVALID_STRIDE = 1,
	/**
	 * mmapping the file descriptor failed
	 */
	WL_SHM_ERROR_INVALID_FD = 2,
};
#endif /* WL_SHM_ERROR_ENUM */

#ifndef WL_SHM_FORMAT_ENUM
#define WL_SHM_FORMAT_ENUM
/**
 * @ingroup iface_wl_shm
 * pixel formats
 *
 * This describes the memory layout of an individual pixel.
 *
 * All renderers should support argb8888 and xrgb8888 but any other
 * formats are optional and may not be supported by the particular
 * renderer in use.
 *
 * The drm format codes match the macros defined in drm_fourcc.h, except
 * argb8888 and xrgb8888. The formats actually supported by the compositor
 * will be reported by the format event.
 *
 * For all wl_shm formats and unless specified in another protocol
 * extension, pre-multiplied alpha is used for pixel values.
 */
enum wl_shm_format {
	/**
	 * 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_ARGB8888 = 0,
	/**
	 * 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_XRGB8888 = 1,
	/**
	 * 8-bit color index format, [7:0] C
	 */
	WL_SHM_FORMAT_C8 = 0x20203843,
	/**
	 * 8-bit RGB format, [7:0] R:G:B 3:3:2
	 */
	WL_SHM_FORMAT_RGB332 = 0x38424752,
	/**
	 * 8-bit BGR format, [7:0] B:G:R 2:3:3
	 */
	WL_SHM_FORMAT_BGR233 = 0x38524742,
	/**
	 * 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
	 */
	WL_SHM_FORMAT_XRGB4444 = 0x32315258,
	/**
	 * 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
	 */
	WL_SHM_FORMAT_XBGR4444 = 0x32314258,
	/**
	 * 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
	 */
	WL_SHM_FORMAT_RGBX4444 = 0x32315852,
	/**
	 * 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
	 */
	WL_SHM_FORMAT_BGRX4444 = 0x32315842,
	/**
	 * 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
	 */
	WL_SHM_FORMAT_ARGB4444 = 0x32315241,
	/**
	 * 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
	 */
	WL_SHM_FORMAT_ABGR4444 = 0x32314241,
	/**
	 * 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
	 */
	WL_SHM_FORMAT_RGBA4444 = 0x32314152,
	/**
	 * 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
	 */
	WL_SHM_FORMAT_BGRA4444 = 0x32314142,
	/**
	 * 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
	 */
	WL_SHM_FORMAT_XRGB1555 = 0x35315258,
	/**
	 * 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
	 */
	WL_SHM_FORMAT_XBGR1555 = 0x35314258,
	/**
	 * 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
	 */
	WL_SHM_FORMAT_RGBX5551 = 0x35315852,
	/**
	 * 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
	 */
	WL_SHM_FORMAT_BGRX5551 = 0x35315842,
	/**
	 * 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
	 */
	WL_SHM_FORMAT_ARGB1555 = 0x35315241,
	/**
	 * 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
	 */
	WL_SHM_FORMAT_ABGR1555 = 0x35314241,
	/**
	 * 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
	 */
	WL_SHM_FORMAT_RGBA5551 = 0x35314152,
	/**
	 * 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
	 */
	WL_SHM_FORMAT_BGRA5551 = 0x35314142,
	/**
	 * 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
	 */
	WL_SHM_FORMAT_RGB565 = 0x36314752,
	/**
	 * 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
	 */
	WL_SHM_FORMAT_BGR565 = 0x36314742,
	/**
	 * 24-bit RGB format, [23:0] R:G:B little endian
	 */
	WL_SHM_FORMAT_RGB888 = 0x34324752,
	/**
	 * 24-bit BGR format, [23:0] B:G:R little endian
	 */
	WL_SHM_FORMAT_BGR888 = 0x34324742,
	/**
	 * 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_XBGR8888 = 0x34324258,
	/**
	 * 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_RGBX8888 = 0x34325852,
	/**
	 * 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_BGRX8888 = 0x34325842,
	/**
	 * 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_ABGR8888 = 0x34324241,
	/**
	 * 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_RGBA8888 = 0x34324152,
	/**
	 * 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_BGRA8888 = 0x34324142,
	/**
	 * 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
	 */
	WL_SHM_FORMAT_XRGB2101010 = 0x30335258,
	/**
	 * 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
	 */
	WL_SHM_FORMAT_XBGR2101010 = 0x30334258,
	/**
	 * 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
	 */
	WL_SHM_FORMAT_RGBX1010102 = 0x30335852,
	/**
	 * 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
	 */
	WL_SHM_FORMAT_BGRX1010102 = 0x30335842,
	/**
	 * 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
	 */
	WL_SHM_FORMAT_ARGB2101010 = 0x30335241,
	/**
	 * 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
	 */
	WL_SHM_FORMAT_ABGR2101010 = 0x30334241,
	/**
	 * 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
	 */
	WL_SHM_FORMAT_RGBA1010102 = 0x30334152,
	/**
	 * 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
	 */
	WL_SHM_FORMAT_BGRA1010102 = 0x30334142,
	/**
	 * packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_YUYV = 0x56595559,
	/**
	 * packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_YVYU = 0x55595659,
	/**
	 * packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_UYVY = 0x59565955,
	/**
	 * packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_VYUY = 0x59555956,
	/**
	 * packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_AYUV = 0x56555941,
	/**
	 * 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
	 */
	WL_SHM_FORMAT_NV12 = 0x3231564e,
	/**
	 * 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
	 */
	WL_SHM_FORMAT_NV21 = 0x3132564e,
	/**
	 * 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
	 */
	WL_SHM_FORMAT_NV16 = 0x3631564e,
	/**
	 * 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
	 */
	WL_SHM_FORMAT_NV61 = 0x3136564e,
	/**
	 * 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
	 */
	WL_SHM_FORMAT_YUV410 = 0x39565559,
	/**
	 * 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
	 */
	WL_SHM_FORMAT_YVU410 = 0x39555659,
	/**
	 * 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
	 */
	WL_SHM_FORMAT_YUV411 = 0x31315559,
	/**
	 * 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
	 */
	WL_SHM_FORMAT_YVU411 = 0x31315659,
	/**
	 * 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
	 */
	WL_SHM_FORMAT_YUV420 = 0x32315559,
	/**
	 * 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
	 */
	WL_SHM_FORMAT_YVU420 = 0x32315659,
	/**
	 * 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
	 */
	WL_SHM_FORMAT_YUV422 = 0x36315559,
	/**
	 * 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
	 */
	WL_SHM_FORMAT_YVU422 = 0x36315659,
	/**
	 * 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
	 */
	WL_SHM_FORMAT_YUV444 = 0x34325559,
	/**
	 * 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
	 */
	WL_SHM_FORMAT_YVU444 = 0x34325659,
	/**
	 * [7:0] R
	 */
	WL_SHM_FORMAT_R8 = 0x20203852,
	/**
	 * [15:0] R little endian
	 */
	WL_SHM_FORMAT_R16 = 0x20363152,
	/**
	 * [15:0] R:G 8:8 little endian
	 */
	WL_SHM_FORMAT_RG88 = 0x38384752,
	/**
	 * [15:0] G:R 8:8 little endian
	 */
	WL_SHM_FORMAT_GR88 = 0x38385247,
	/**
	 * [31:0] R:G 16:16 little endian
	 */
	WL_SHM_FORMAT_RG1616 = 0x32334752,
	/**
	 * [31:0] G:R 16:16 little endian
	 */
	WL_SHM_FORMAT_GR1616 = 0x32335247,
	/**
	 * [63:0] x:R:G:B 16:16:16:16 little endian
	 */
	WL_SHM_FORMAT_XRGB16161616F = 0x48345258,
	/**
	 * [63:0] x:B:G:R 16:16:16:16 little endian
	 */
	WL_SHM_FORMAT_XBGR16161616F = 0x48344258,
	/**
	 * [63:0] A:R:G:B 16:16:16:16 little endian
	 */
	WL_SHM_FORMAT_ARGB16161616F = 0x48345241,
	/**
	 * [63:0] A:B:G:R 16:16:16:16 little endian
	 */
	WL_SHM_FORMAT_ABGR16161616F = 0x48344241,
	/**
	 * [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_XYUV8888 = 0x56555958,
	/**
	 * [23:0] Cr:Cb:Y 8:8:8 little endian
	 */
	WL_SHM_FORMAT_VUY888 = 0x34325556,
	/**
	 * Y followed by U then V, 10:10:10. Non-linear modifier only
	 */
	WL_SHM_FORMAT_VUY101010 = 0x30335556,
	/**
	 * [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
	 */
	WL_SHM_FORMAT_Y210 = 0x30313259,
	/**
	 * [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
	 */
	WL_SHM_FORMAT_Y212 = 0x32313259,
	/**
	 * [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
	 */
	WL_SHM_FORMAT_Y216 = 0x36313259,
	/**
	 * [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
	 */
	WL_SHM_FORMAT_Y410 = 0x30313459,
	/**
	 * [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
	 */
	WL_SHM_FORMAT_Y412 = 0x32313459,
	/**
	 * [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
	 */
	WL_SHM_FORMAT_Y416 = 0x36313459,
	/**
	 * [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
	 */
	WL_SHM_FORMAT_XVYU2101010 = 0x30335658,
	/**
	 * [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
	 */
	WL_SHM_FORMAT_XVYU12_16161616 = 0x36335658,
	/**
	 * [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
	 */
	WL_SHM_FORMAT_XVYU16161616 = 0x38345658,
	/**
	 * [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
	 */
	WL_SHM_FORMAT_Y0L0 = 0x304c3059,
	/**
	 * [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
	 */
	WL_SHM_FORMAT_X0L0 = 0x304c3058,
	/**
	 * [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
	 */
	WL_SHM_FORMAT_Y0L2 = 0x324c3059,
	/**
	 * [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
	 */
	WL_SHM_FORMAT_X0L2 = 0x324c3058,
	WL_SHM_FORMAT_YUV420_8BIT = 0x38305559,
	WL_SHM_FORMAT_YUV420_10BIT = 0x30315559,
	WL_SHM_FORMAT_XRGB8888_A8 = 0x38415258,
	WL_SHM_FORMAT_XBGR8888_A8 = 0x38414258,
	WL_SHM_FORMAT_RGBX8888_A8 = 0x38415852,
	WL_SHM_FORMAT_BGRX8888_A8 = 0x38415842,
	WL_SHM_FORMAT_RGB888_A8 = 0x38413852,
	WL_SHM_FORMAT_BGR888_A8 = 0x38413842,
	WL_SHM_FORMAT_RGB565_A8 = 0x38413552,
	WL_SHM_FORMAT_BGR565_A8 = 0x38413542,
	/**
	 * non-subsampled Cr:Cb plane
	 */
	WL_SHM_FORMAT_NV24 = 0x3432564e,
	/**
	 * non-subsampled Cb:Cr plane
	 */
	WL_SHM_FORMAT_NV42 = 0x3234564e,
	/**
	 * 2x1 subsampled Cr:Cb plane, 10 bit per channel
	 */
	WL_SHM_FORMAT_P210 = 0x30313250,
	/**
	 * 2x2 subsampled Cr:Cb plane 10 bits per channel
	 */
	WL_SHM_FORMAT_P010 = 0x30313050,
	/**
	 * 2x2 subsampled Cr:Cb plane 12 bits per channel
	 */
	WL_SHM_FORMAT_P012 = 0x32313050,
	/**
	 * 2x2 subsampled Cr:Cb plane 16 bits per channel
	 */
	WL_SHM_FORMAT_P016 = 0x36313050,
	/**
	 * [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
	 */
	WL_SHM_FORMAT_AXBXGXRX106106106106 = 0x30314241,
	/**
	 * 2x2 subsampled Cr:Cb plane
	 */
	WL_SHM_FORMAT_NV15 = 0x3531564e,
	WL_SHM_FORMAT_Q410 = 0x30313451,
	WL_SHM_FORMAT_Q401 = 0x31303451,
	/**
	 * [63:0] x:R:G:B 16:16:16:16 little endian
	 */
	WL_SHM_FORMAT_XRGB16161616 = 0x38345258,
	/**
	 * [63:0] x:B:G:R 16:16:16:16 little endian
	 */
	WL_SHM_FORMAT_XBGR16161616 = 0x38344258,
	/**
	 * [63:0] A:R:G:B 16:16:16:16 little endian
	 */
	WL_SHM_FORMAT_ARGB16161616 = 0x38345241,
	/**
	 * [63:0] A:B:G:R 16:16:16:16 little endian
	 */
	WL_SHM_FORMAT_ABGR16161616 = 0x38344241,
	/**
	 * [7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte
	 */
	WL_SHM_FORMAT_C1 = 0x20203143,
	/**
	 * [7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte
	 */
	WL_SHM_FORMAT_C2 = 0x20203243,
	/**
	 * [7:0] C0:C1 4:4 two pixels/byte
	 */
	WL_SHM_FORMAT_C4 = 0x20203443,
	/**
	 * [7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte
	 */
	WL_SHM_FORMAT_D1 = 0x20203144,
	/**
	 * [7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte
	 */
	WL_SHM_FORMAT_D2 = 0x20203244,
	/**
	 * [7:0] D0:D1 4:4 two pixels/byte
	 */
	WL_SHM_FORMAT_D4 = 0x20203444,
	/**
	 * [7:0] D
	 */
	WL_SHM_FORMAT_D8 = 0x20203844,
	/**
	 * [7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte
	 */
	WL_SHM_FORMAT_R1 = 0x20203152,
	/**
	 * [7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte
	 */
	WL_SHM_FORMAT_R2 = 0x20203252,
	/**
	 * [7:0] R0:R1 4:4 two pixels/byte
	 */
	WL_SHM_FORMAT_R4 = 0x20203452,
	/**
	 * [15:0] x:R 6:10 little endian
	 */
	WL_SHM_FORMAT_R10 = 0x20303152,
	/**
	 * [15:0] x:R 4:12 little endian
	 */
	WL_SHM_FORMAT_R12 = 0x20323152,
	/**
	 * [31:0] A:Cr:Cb:Y 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_AVUY8888 = 0x59555641,
	/**
	 * [31:0] X:Cr:Cb:Y 8:8:8:8 little endian
	 */
	WL_SHM_FORMAT_XVUY8888 = 0x59555658,
	/**
	 * 2x2 subsampled Cr:Cb plane 10 bits per channel packed
	 */
	WL_SHM_FORMAT_P030 = 0x30333050,
};
#endif /* WL_SHM_FORMAT_ENUM */

/**
 * @ingroup iface_wl_shm
 * @struct wl_shm_listener
 */
struct wl_shm_listener {
	/**
	 * pixel format description
	 *
	 * Informs the client about a valid pixel format that can be used
	 * for buffers. Known formats include argb8888 and xrgb8888.
	 * @param format buffer pixel format
	 */
	void (*format)(void *data,
		       struct wl_shm *wl_shm,
		       uint32_t format);
};

/**
 * @ingroup iface_wl_shm
 */
static inline int
wl_shm_add_listener(struct wl_shm *wl_shm,
		    const struct wl_shm_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_shm,
				     (void (**)(void)) listener, data);
}

#define WL_SHM_CREATE_POOL 0
#define WL_SHM_RELEASE 1

/**
 * @ingroup iface_wl_shm
 */
#define WL_SHM_FORMAT_SINCE_VERSION 1

/**
 * @ingroup iface_wl_shm
 */
#define WL_SHM_CREATE_POOL_SINCE_VERSION 1
/**
 * @ingroup iface_wl_shm
 */
#define WL_SHM_RELEASE_SINCE_VERSION 2

/** @ingroup iface_wl_shm */
static inline void
wl_shm_set_user_data(struct wl_shm *wl_shm, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_shm, user_data);
}

/** @ingroup iface_wl_shm */
static inline void *
wl_shm_get_user_data(struct wl_shm *wl_shm)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_shm);
}

static inline uint32_t
wl_shm_get_version(struct wl_shm *wl_shm)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_shm);
}

/** @ingroup iface_wl_shm */
static inline void
wl_shm_destroy(struct wl_shm *wl_shm)
{
	wl_proxy_destroy((struct wl_proxy *) wl_shm);
}

/**
 * @ingroup iface_wl_shm
 *
 * Create a new wl_shm_pool object.
 *
 * The pool can be used to create shared memory based buffer
 * objects.  The server will mmap size bytes of the passed file
 * descriptor, to use as backing memory for the pool.
 */
static inline struct wl_shm_pool *
wl_shm_create_pool(struct wl_shm *wl_shm, int32_t fd, int32_t size)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) wl_shm,
			 WL_SHM_CREATE_POOL, &wl_shm_pool_interface, wl_proxy_get_version((struct wl_proxy *) wl_shm), 0, NULL, fd, size);

	return (struct wl_shm_pool *) id;
}

/**
 * @ingroup iface_wl_shm
 *
 * Using this request a client can tell the server that it is not going to
 * use the shm object anymore.
 *
 * Objects created via this interface remain unaffected.
 */
static inline void
wl_shm_release(struct wl_shm *wl_shm)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_shm,
			 WL_SHM_RELEASE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_shm), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_wl_buffer
 * @struct wl_buffer_listener
 */
struct wl_buffer_listener {
	/**
	 * compositor releases buffer
	 *
	 * Sent when this wl_buffer is no longer used by the compositor.
	 * The client is now free to reuse or destroy this buffer and its
	 * backing storage.
	 *
	 * If a client receives a release event before the frame callback
	 * requested in the same wl_surface.commit that attaches this
	 * wl_buffer to a surface, then the client is immediately free to
	 * reuse the buffer and its backing storage, and does not need a
	 * second buffer for the next surface content update. Typically
	 * this is possible, when the compositor maintains a copy of the
	 * wl_surface contents, e.g. as a GL texture. This is an important
	 * optimization for GL(ES) compositors with wl_shm clients.
	 */
	void (*release)(void *data,
			struct wl_buffer *wl_buffer);
};

/**
 * @ingroup iface_wl_buffer
 */
static inline int
wl_buffer_add_listener(struct wl_buffer *wl_buffer,
		       const struct wl_buffer_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_buffer,
				     (void (**)(void)) listener, data);
}

#define WL_BUFFER_DESTROY 0

/**
 * @ingroup iface_wl_buffer
 */
#define WL_BUFFER_RELEASE_SINCE_VERSION 1

/**
 * @ingroup iface_wl_buffer
 */
#define WL_BUFFER_DESTROY_SINCE_VERSION 1

/** @ingroup iface_wl_buffer */
static inline void
wl_buffer_set_user_data(struct wl_buffer *wl_buffer, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_buffer, user_data);
}

/** @ingroup iface_wl_buffer */
static inline void *
wl_buffer_get_user_data(struct wl_buffer *wl_buffer)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_buffer);
}

static inline uint32_t
wl_buffer_get_version(struct wl_buffer *wl_buffer)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_buffer);
}

/**
 * @ingroup iface_wl_buffer
 *
 * Destroy a buffer. If and how you need to release the backing
 * storage is defined by the buffer factory interface.
 *
 * For possible side-effects to a surface, see wl_surface.attach.
 */
static inline void
wl_buffer_destroy(struct wl_buffer *wl_buffer)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_buffer,
			 WL_BUFFER_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) wl_buffer), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef WL_DATA_OFFER_ERROR_ENUM
#define WL_DATA_OFFER_ERROR_ENUM
enum wl_data_offer_error {
	/**
	 * finish request was called untimely
	 */
	WL_DATA_OFFER_ERROR_INVALID_FINISH = 0,
	/**
	 * action mask contains invalid values
	 */
	WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK = 1,
	/**
	 * action argument has an invalid value
	 */
	WL_DATA_OFFER_ERROR_INVALID_ACTION = 2,
	/**
	 * offer doesn't accept this request
	 */
	WL_DATA_OFFER_ERROR_INVALID_OFFER = 3,
};
#endif /* WL_DATA_OFFER_ERROR_ENUM */

/**
 * @ingroup iface_wl_data_offer
 * @struct wl_data_offer_listener
 */
struct wl_data_offer_listener {
	/**
	 * advertise offered mime type
	 *
	 * Sent immediately after creating the wl_data_offer object. One
	 * event per offered mime type.
	 * @param mime_type offered mime type
	 */
	void (*offer)(void *data,
		      struct wl_data_offer *wl_data_offer,
		      const char *mime_type);
	/**
	 * notify the source-side available actions
	 *
	 * This event indicates the actions offered by the data source.
	 * It will be sent immediately after creating the wl_data_offer
	 * object, or anytime the source side changes its offered actions
	 * through wl_data_source.set_actions.
	 * @param source_actions actions offered by the data source
	 * @since 3
	 */
	void (*source_actions)(void *data,
			       struct wl_data_offer *wl_data_offer,
			       uint32_t source_actions);
	/**
	 * notify the selected action
	 *
	 * This event indicates the action selected by the compositor
	 * after matching the source/destination side actions. Only one
	 * action (or none) will be offered here.
	 *
	 * This event can be emitted multiple times during the
	 * drag-and-drop operation in response to destination side action
	 * changes through wl_data_offer.set_actions.
	 *
	 * This event will no longer be emitted after wl_data_device.drop
	 * happened on the drag-and-drop destination, the client must honor
	 * the last action received, or the last preferred one set through
	 * wl_data_offer.set_actions when handling an "ask" action.
	 *
	 * Compositors may also change the selected action on the fly,
	 * mainly in response to keyboard modifier changes during the
	 * drag-and-drop operation.
	 *
	 * The most recent action received is always the valid one. Prior
	 * to receiving wl_data_device.drop, the chosen action may change
	 * (e.g. due to keyboard modifiers being pressed). At the time of
	 * receiving wl_data_device.drop the drag-and-drop destination must
	 * honor the last action received.
	 *
	 * Action changes may still happen after wl_data_device.drop,
	 * especially on "ask" actions, where the drag-and-drop destination
	 * may choose another action afterwards. Action changes happening
	 * at this stage are always the result of inter-client negotiation,
	 * the compositor shall no longer be able to induce a different
	 * action.
	 *
	 * Upon "ask" actions, it is expected that the drag-and-drop
	 * destination may potentially choose a different action and/or
	 * mime type, based on wl_data_offer.source_actions and finally
	 * chosen by the user (e.g. popping up a menu with the available
	 * options). The final wl_data_offer.set_actions and
	 * wl_data_offer.accept requests must happen before the call to
	 * wl_data_offer.finish.
	 * @param dnd_action action selected by the compositor
	 * @since 3
	 */
	void (*action)(void *data,
		       struct wl_data_offer *wl_data_offer,
		       uint32_t dnd_action);
};

/**
 * @ingroup iface_wl_data_offer
 */
static inline int
wl_data_offer_add_listener(struct wl_data_offer *wl_data_offer,
			   const struct wl_data_offer_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_data_offer,
				     (void (**)(void)) listener, data);
}

#define WL_DATA_OFFER_ACCEPT 0
#define WL_DATA_OFFER_RECEIVE 1
#define WL_DATA_OFFER_DESTROY 2
#define WL_DATA_OFFER_FINISH 3
#define WL_DATA_OFFER_SET_ACTIONS 4

/**
 * @ingroup iface_wl_data_offer
 */
#define WL_DATA_OFFER_OFFER_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_offer
 */
#define WL_DATA_OFFER_SOURCE_ACTIONS_SINCE_VERSION 3
/**
 * @ingroup iface_wl_data_offer
 */
#define WL_DATA_OFFER_ACTION_SINCE_VERSION 3

/**
 * @ingroup iface_wl_data_offer
 */
#define WL_DATA_OFFER_ACCEPT_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_offer
 */
#define WL_DATA_OFFER_RECEIVE_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_offer
 */
#define WL_DATA_OFFER_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_offer
 */
#define WL_DATA_OFFER_FINISH_SINCE_VERSION 3
/**
 * @ingroup iface_wl_data_offer
 */
#define WL_DATA_OFFER_SET_ACTIONS_SINCE_VERSION 3

/** @ingroup iface_wl_data_offer */
static inline void
wl_data_offer_set_user_data(struct wl_data_offer *wl_data_offer, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_data_offer, user_data);
}

/** @ingroup iface_wl_data_offer */
static inline void *
wl_data_offer_get_user_data(struct wl_data_offer *wl_data_offer)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_data_offer);
}

static inline uint32_t
wl_data_offer_get_version(struct wl_data_offer *wl_data_offer)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_data_offer);
}

/**
 * @ingroup iface_wl_data_offer
 *
 * Indicate that the client can accept the given mime type, or
 * NULL for not accepted.
 *
 * For objects of version 2 or older, this request is used by the
 * client to give feedback whether the client can receive the given
 * mime type, or NULL if none is accepted; the feedback does not
 * determine whether the drag-and-drop operation succeeds or not.
 *
 * For objects of version 3 or newer, this request determines the
 * final result of the drag-and-drop operation. If the end result
 * is that no mime types were accepted, the drag-and-drop operation
 * will be cancelled and the corresponding drag source will receive
 * wl_data_source.cancelled. Clients may still use this event in
 * conjunction with wl_data_source.action for feedback.
 */
static inline void
wl_data_offer_accept(struct wl_data_offer *wl_data_offer, uint32_t serial, const char *mime_type)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_data_offer,
			 WL_DATA_OFFER_ACCEPT, NULL, wl_proxy_get_version((struct wl_proxy *) wl_data_offer), 0, serial, mime_type);
}

/**
 * @ingroup iface_wl_data_offer
 *
 * To transfer the offered data, the client issues this request
 * and indicates the mime type it wants to receive.  The transfer
 * happens through the passed file descriptor (typically created
 * with the pipe system call).  The source client writes the data
 * in the mime type representation requested and then closes the
 * file descriptor.
 *
 * The receiving client reads from the read end of the pipe until
 * EOF and then closes its end, at which point the transfer is
 * complete.
 *
 * This request may happen multiple times for different mime types,
 * both before and after wl_data_device.drop. Drag-and-drop destination
 * clients may preemptively fetch data or examine it more closely to
 * determine acceptance.
 */
static inline void
wl_data_offer_receive(struct wl_data_offer *wl_data_offer, const char *mime_type, int32_t fd)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_data_offer,
			 WL_DATA_OFFER_RECEIVE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_data_offer), 0, mime_type, fd);
}

/**
 * @ingroup iface_wl_data_offer
 *
 * Destroy the data offer.
 */
static inline void
wl_data_offer_destroy(struct wl_data_offer *wl_data_offer)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_data_offer,
			 WL_DATA_OFFER_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) wl_data_offer), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_wl_data_offer
 *
 * Notifies the compositor that the drag destination successfully
 * finished the drag-and-drop operation.
 *
 * Upon receiving this request, the compositor will emit
 * wl_data_source.dnd_finished on the drag source client.
 *
 * It is a client error to perform other requests than
 * wl_data_offer.destroy after this one. It is also an error to perform
 * this request after a NULL mime type has been set in
 * wl_data_offer.accept or no action was received through
 * wl_data_offer.action.
 *
 * If wl_data_offer.finish request is received for a non drag and drop
 * operation, the invalid_finish protocol error is raised.
 */
static inline void
wl_data_offer_finish(struct wl_data_offer *wl_data_offer)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_data_offer,
			 WL_DATA_OFFER_FINISH, NULL, wl_proxy_get_version((struct wl_proxy *) wl_data_offer), 0);
}

/**
 * @ingroup iface_wl_data_offer
 *
 * Sets the actions that the destination side client supports for
 * this operation. This request may trigger the emission of
 * wl_data_source.action and wl_data_offer.action events if the compositor
 * needs to change the selected action.
 *
 * This request can be called multiple times throughout the
 * drag-and-drop operation, typically in response to wl_data_device.enter
 * or wl_data_device.motion events.
 *
 * This request determines the final result of the drag-and-drop
 * operation. If the end result is that no action is accepted,
 * the drag source will receive wl_data_source.cancelled.
 *
 * The dnd_actions argument must contain only values expressed in the
 * wl_data_device_manager.dnd_actions enum, and the preferred_action
 * argument must only contain one of those values set, otherwise it
 * will result in a protocol error.
 *
 * While managing an "ask" action, the destination drag-and-drop client
 * may perform further wl_data_offer.receive requests, and is expected
 * to perform one last wl_data_offer.set_actions request with a preferred
 * action other than "ask" (and optionally wl_data_offer.accept) before
 * requesting wl_data_offer.finish, in order to convey the action selected
 * by the user. If the preferred action is not in the
 * wl_data_offer.source_actions mask, an error will be raised.
 *
 * If the "ask" action is dismissed (e.g. user cancellation), the client
 * is expected to perform wl_data_offer.destroy right away.
 *
 * This request can only be made on drag-and-drop offers, a protocol error
 * will be raised otherwise.
 */
static inline void
wl_data_offer_set_actions(struct wl_data_offer *wl_data_offer, uint32_t dnd_actions, uint32_t preferred_action)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_data_offer,
			 WL_DATA_OFFER_SET_ACTIONS, NULL, wl_proxy_get_version((struct wl_proxy *) wl_data_offer), 0, dnd_actions, preferred_action);
}

#ifndef WL_DATA_SOURCE_ERROR_ENUM
#define WL_DATA_SOURCE_ERROR_ENUM
enum wl_data_source_error {
	/**
	 * action mask contains invalid values
	 */
	WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK = 0,
	/**
	 * source doesn't accept this request
	 */
	WL_DATA_SOURCE_ERROR_INVALID_SOURCE = 1,
};
#endif /* WL_DATA_SOURCE_ERROR_ENUM */

/**
 * @ingroup iface_wl_data_source
 * @struct wl_data_source_listener
 */
struct wl_data_source_listener {
	/**
	 * a target accepts an offered mime type
	 *
	 * Sent when a target accepts pointer_focus or motion events. If
	 * a target does not accept any of the offered types, type is NULL.
	 *
	 * Used for feedback during drag-and-drop.
	 * @param mime_type mime type accepted by the target
	 */
	void (*target)(void *data,
		       struct wl_data_source *wl_data_source,
		       const char *mime_type);
	/**
	 * send the data
	 *
	 * Request for data from the client. Send the data as the
	 * specified mime type over the passed file descriptor, then close
	 * it.
	 * @param mime_type mime type for the data
	 * @param fd file descriptor for the data
	 */
	void (*send)(void *data,
		     struct wl_data_source *wl_data_source,
		     const char *mime_type,
		     int32_t fd);
	/**
	 * selection was cancelled
	 *
	 * This data source is no longer valid. There are several reasons
	 * why this could happen:
	 *
	 * - The data source has been replaced by another data source. -
	 * The drag-and-drop operation was performed, but the drop
	 * destination did not accept any of the mime types offered through
	 * wl_data_source.target. - The drag-and-drop operation was
	 * performed, but the drop destination did not select any of the
	 * actions present in the mask offered through
	 * wl_data_source.action. - The drag-and-drop operation was
	 * performed but didn't happen over a surface. - The compositor
	 * cancelled the drag-and-drop operation (e.g. compositor dependent
	 * timeouts to avoid stale drag-and-drop transfers).
	 *
	 * The client should clean up and destroy this data source.
	 *
	 * For objects of version 2 or older, wl_data_source.cancelled will
	 * only be emitted if the data source was replaced by another data
	 * source.
	 */
	void (*cancelled)(void *data,
			  struct wl_data_source *wl_data_source);
	/**
	 * the drag-and-drop operation physically finished
	 *
	 * The user performed the drop action. This event does not
	 * indicate acceptance, wl_data_source.cancelled may still be
	 * emitted afterwards if the drop destination does not accept any
	 * mime type.
	 *
	 * However, this event might however not be received if the
	 * compositor cancelled the drag-and-drop operation before this
	 * event could happen.
	 *
	 * Note that the data_source may still be used in the future and
	 * should not be destroyed here.
	 * @since 3
	 */
	void (*dnd_drop_performed)(void *data,
				   struct wl_data_source *wl_data_source);
	/**
	 * the drag-and-drop operation concluded
	 *
	 * The drop destination finished interoperating with this data
	 * source, so the client is now free to destroy this data source
	 * and free all associated data.
	 *
	 * If the action used to perform the operation was "move", the
	 * source can now delete the transferred data.
	 * @since 3
	 */
	void (*dnd_finished)(void *data,
			     struct wl_data_source *wl_data_source);
	/**
	 * notify the selected action
	 *
	 * This event indicates the action selected by the compositor
	 * after matching the source/destination side actions. Only one
	 * action (or none) will be offered here.
	 *
	 * This event can be emitted multiple times during the
	 * drag-and-drop operation, mainly in response to destination side
	 * changes through wl_data_offer.set_actions, and as the data
	 * device enters/leaves surfaces.
	 *
	 * It is only possible to receive this event after
	 * wl_data_source.dnd_drop_performed if the drag-and-drop operation
	 * ended in an "ask" action, in which case the final
	 * wl_data_source.action event will happen immediately before
	 * wl_data_source.dnd_finished.
	 *
	 * Compositors may also change the selected action on the fly,
	 * mainly in response to keyboard modifier changes during the
	 * drag-and-drop operation.
	 *
	 * The most recent action received is always the valid one. The
	 * chosen action may change alongside negotiation (e.g. an "ask"
	 * action can turn into a "move" operation), so the effects of the
	 * final action must always be applied in
	 * wl_data_offer.dnd_finished.
	 *
	 * Clients can trigger cursor surface changes from this point, so
	 * they reflect the current action.
	 * @param dnd_action action selected by the compositor
	 * @since 3
	 */
	void (*action)(void *data,
		       struct wl_data_source *wl_data_source,
		       uint32_t dnd_action);
};

/**
 * @ingroup iface_wl_data_source
 */
static inline int
wl_data_source_add_listener(struct wl_data_source *wl_data_source,
			    const struct wl_data_source_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_data_source,
				     (void (**)(void)) listener, data);
}

#define WL_DATA_SOURCE_OFFER 0
#define WL_DATA_SOURCE_DESTROY 1
#define WL_DATA_SOURCE_SET_ACTIONS 2

/**
 * @ingroup iface_wl_data_source
 */
#define WL_DATA_SOURCE_TARGET_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_source
 */
#define WL_DATA_SOURCE_SEND_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_source
 */
#define WL_DATA_SOURCE_CANCELLED_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_source
 */
#define WL_DATA_SOURCE_DND_DROP_PERFORMED_SINCE_VERSION 3
/**
 * @ingroup iface_wl_data_source
 */
#define WL_DATA_SOURCE_DND_FINISHED_SINCE_VERSION 3
/**
 * @ingroup iface_wl_data_source
 */
#define WL_DATA_SOURCE_ACTION_SINCE_VERSION 3

/**
 * @ingroup iface_wl_data_source
 */
#define WL_DATA_SOURCE_OFFER_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_source
 */
#define WL_DATA_SOURCE_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_source
 */
#define WL_DATA_SOURCE_SET_ACTIONS_SINCE_VERSION 3

/** @ingroup iface_wl_data_source */
static inline void
wl_data_source_set_user_data(struct wl_data_source *wl_data_source, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_data_source, user_data);
}

/** @ingroup iface_wl_data_source */
static inline void *
wl_data_source_get_user_data(struct wl_data_source *wl_data_source)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_data_source);
}

static inline uint32_t
wl_data_source_get_version(struct wl_data_source *wl_data_source)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_data_source);
}

/**
 * @ingroup iface_wl_data_source
 *
 * This request adds a mime type to the set of mime types
 * advertised to targets.  Can be called several times to offer
 * multiple types.
 */
static inline void
wl_data_source_offer(struct wl_data_source *wl_data_source, const char *mime_type)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_data_source,
			 WL_DATA_SOURCE_OFFER, NULL, wl_proxy_get_version((struct wl_proxy *) wl_data_source), 0, mime_type);
}

/**
 * @ingroup iface_wl_data_source
 *
 * Destroy the data source.
 */
static inline void
wl_data_source_destroy(struct wl_data_source *wl_data_source)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_data_source,
			 WL_DATA_SOURCE_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) wl_data_source), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_wl_data_source
 *
 * Sets the actions that the source side client supports for this
 * operation. This request may trigger wl_data_source.action and
 * wl_data_offer.action events if the compositor needs to change the
 * selected action.
 *
 * The dnd_actions argument must contain only values expressed in the
 * wl_data_device_manager.dnd_actions enum, otherwise it will result
 * in a protocol error.
 *
 * This request must be made once only, and can only be made on sources
 * used in drag-and-drop, so it must be performed before
 * wl_data_device.start_drag. Attempting to use the source other than
 * for drag-and-drop will raise a protocol error.
 */
static inline void
wl_data_source_set_actions(struct wl_data_source *wl_data_source, uint32_t dnd_actions)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_data_source,
			 WL_DATA_SOURCE_SET_ACTIONS, NULL, wl_proxy_get_version((struct wl_proxy *) wl_data_source), 0, dnd_actions);
}

#ifndef WL_DATA_DEVICE_ERROR_ENUM
#define WL_DATA_DEVICE_ERROR_ENUM
enum wl_data_device_error {
	/**
	 * given wl_surface has another role
	 */
	WL_DATA_DEVICE_ERROR_ROLE = 0,
	/**
	 * source has already been used
	 */
	WL_DATA_DEVICE_ERROR_USED_SOURCE = 1,
};
#endif /* WL_DATA_DEVICE_ERROR_ENUM */

/**
 * @ingroup iface_wl_data_device
 * @struct wl_data_device_listener
 */
struct wl_data_device_listener {
	/**
	 * introduce a new wl_data_offer
	 *
	 * The data_offer event introduces a new wl_data_offer object,
	 * which will subsequently be used in either the data_device.enter
	 * event (for drag-and-drop) or the data_device.selection event
	 * (for selections). Immediately following the
	 * data_device.data_offer event, the new data_offer object will
	 * send out data_offer.offer events to describe the mime types it
	 * offers.
	 * @param id the new data_offer object
	 */
	void (*data_offer)(void *data,
			   struct wl_data_device *wl_data_device,
			   struct wl_data_offer *id);
	/**
	 * initiate drag-and-drop session
	 *
	 * This event is sent when an active drag-and-drop pointer enters
	 * a surface owned by the client. The position of the pointer at
	 * enter time is provided by the x and y arguments, in
	 * surface-local coordinates.
	 * @param serial serial number of the enter event
	 * @param surface client surface entered
	 * @param x surface-local x coordinate
	 * @param y surface-local y coordinate
	 * @param id source data_offer object
	 */
	void (*enter)(void *data,
		      struct wl_data_device *wl_data_device,
		      uint32_t serial,
		      struct wl_surface *surface,
		      wl_fixed_t x,
		      wl_fixed_t y,
		      struct wl_data_offer *id);
	/**
	 * end drag-and-drop session
	 *
	 * This event is sent when the drag-and-drop pointer leaves the
	 * surface and the session ends. The client must destroy the
	 * wl_data_offer introduced at enter time at this point.
	 */
	void (*leave)(void *data,
		      struct wl_data_device *wl_data_device);
	/**
	 * drag-and-drop session motion
	 *
	 * This event is sent when the drag-and-drop pointer moves within
	 * the currently focused surface. The new position of the pointer
	 * is provided by the x and y arguments, in surface-local
	 * coordinates.
	 * @param time timestamp with millisecond granularity
	 * @param x surface-local x coordinate
	 * @param y surface-local y coordinate
	 */
	void (*motion)(void *data,
		       struct wl_data_device *wl_data_device,
		       uint32_t time,
		       wl_fixed_t x,
		       wl_fixed_t y);
	/**
	 * end drag-and-drop session successfully
	 *
	 * The event is sent when a drag-and-drop operation is ended
	 * because the implicit grab is removed.
	 *
	 * The drag-and-drop destination is expected to honor the last
	 * action received through wl_data_offer.action, if the resulting
	 * action is "copy" or "move", the destination can still perform
	 * wl_data_offer.receive requests, and is expected to end all
	 * transfers with a wl_data_offer.finish request.
	 *
	 * If the resulting action is "ask", the action will not be
	 * considered final. The drag-and-drop destination is expected to
	 * perform one last wl_data_offer.set_actions request, or
	 * wl_data_offer.destroy in order to cancel the operation.
	 */
	void (*drop)(void *data,
		     struct wl_data_device *wl_data_device);
	/**
	 * advertise new selection
	 *
	 * The selection event is sent out to notify the client of a new
	 * wl_data_offer for the selection for this device. The
	 * data_device.data_offer and the data_offer.offer events are sent
	 * out immediately before this event to introduce the data offer
	 * object. The selection event is sent to a client immediately
	 * before receiving keyboard focus and when a new selection is set
	 * while the client has keyboard focus. The data_offer is valid
	 * until a new data_offer or NULL is received or until the client
	 * loses keyboard focus. Switching surface with keyboard focus
	 * within the same client doesn't mean a new selection will be
	 * sent. The client must destroy the previous selection data_offer,
	 * if any, upon receiving this event.
	 * @param id selection data_offer object
	 */
	void (*selection)(void *data,
			  struct wl_data_device *wl_data_device,
			  struct wl_data_offer *id);
};

/**
 * @ingroup iface_wl_data_device
 */
static inline int
wl_data_device_add_listener(struct wl_data_device *wl_data_device,
			    const struct wl_data_device_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_data_device,
				     (void (**)(void)) listener, data);
}

#define WL_DATA_DEVICE_START_DRAG 0
#define WL_DATA_DEVICE_SET_SELECTION 1
#define WL_DATA_DEVICE_RELEASE 2

/**
 * @ingroup iface_wl_data_device
 */
#define WL_DATA_DEVICE_DATA_OFFER_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_device
 */
#define WL_DATA_DEVICE_ENTER_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_device
 */
#define WL_DATA_DEVICE_LEAVE_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_device
 */
#define WL_DATA_DEVICE_MOTION_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_device
 */
#define WL_DATA_DEVICE_DROP_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_device
 */
#define WL_DATA_DEVICE_SELECTION_SINCE_VERSION 1

/**
 * @ingroup iface_wl_data_device
 */
#define WL_DATA_DEVICE_START_DRAG_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_device
 */
#define WL_DATA_DEVICE_SET_SELECTION_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_device
 */
#define WL_DATA_DEVICE_RELEASE_SINCE_VERSION 2

/** @ingroup iface_wl_data_device */
static inline void
wl_data_device_set_user_data(struct wl_data_device *wl_data_device, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_data_device, user_data);
}

/** @ingroup iface_wl_data_device */
static inline void *
wl_data_device_get_user_data(struct wl_data_device *wl_data_device)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_data_device);
}

static inline uint32_t
wl_data_device_get_version(struct wl_data_device *wl_data_device)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_data_device);
}

/** @ingroup iface_wl_data_device */
static inline void
wl_data_device_destroy(struct wl_data_device *wl_data_device)
{
	wl_proxy_destroy((struct wl_proxy *) wl_data_device);
}

/**
 * @ingroup iface_wl_data_device
 *
 * This request asks the compositor to start a drag-and-drop
 * operation on behalf of the client.
 *
 * The source argument is the data source that provides the data
 * for the eventual data transfer. If source is NULL, enter, leave
 * and motion events are sent only to the client that initiated the
 * drag and the client is expected to handle the data passing
 * internally. If source is destroyed, the drag-and-drop session will be
 * cancelled.
 *
 * The origin surface is the surface where the drag originates and
 * the client must have an active implicit grab that matches the
 * serial.
 *
 * The icon surface is an optional (can be NULL) surface that
 * provides an icon to be moved around with the cursor.  Initially,
 * the top-left corner of the icon surface is placed at the cursor
 * hotspot, but subsequent wl_surface.offset requests can move the
 * relative position. Attach requests must be confirmed with
 * wl_surface.commit as usual. The icon surface is given the role of
 * a drag-and-drop icon. If the icon surface already has another role,
 * it raises a protocol error.
 *
 * The input region is ignored for wl_surfaces with the role of a
 * drag-and-drop icon.
 *
 * The given source may not be used in any further set_selection or
 * start_drag requests. Attempting to reuse a previously-used source
 * may send a used_source error.
 */
static inline void
wl_data_device_start_drag(struct wl_data_device *wl_data_device, struct wl_data_source *source, struct wl_surface *origin, struct wl_surface *icon, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_data_device,
			 WL_DATA_DEVICE_START_DRAG, NULL, wl_proxy_get_version((struct wl_proxy *) wl_data_device), 0, source, origin, icon, serial);
}

/**
 * @ingroup iface_wl_data_device
 *
 * This request asks the compositor to set the selection
 * to the data from the source on behalf of the client.
 *
 * To unset the selection, set the source to NULL.
 *
 * The given source may not be used in any further set_selection or
 * start_drag requests. Attempting to reuse a previously-used source
 * may send a used_source error.
 */
static inline void
wl_data_device_set_selection(struct wl_data_device *wl_data_device, struct wl_data_source *source, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_data_device,
			 WL_DATA_DEVICE_SET_SELECTION, NULL, wl_proxy_get_version((struct wl_proxy *) wl_data_device), 0, source, serial);
}

/**
 * @ingroup iface_wl_data_device
 *
 * This request destroys the data device.
 */
static inline void
wl_data_device_release(struct wl_data_device *wl_data_device)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_data_device,
			 WL_DATA_DEVICE_RELEASE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_data_device), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef WL_DATA_DEVICE_MANAGER_DND_ACTION_ENUM
#define WL_DATA_DEVICE_MANAGER_DND_ACTION_ENUM
/**
 * @ingroup iface_wl_data_device_manager
 * drag and drop actions
 *
 * This is a bitmask of the available/preferred actions in a
 * drag-and-drop operation.
 *
 * In the compositor, the selected action is a result of matching the
 * actions offered by the source and destination sides.  "action" events
 * with a "none" action will be sent to both source and destination if
 * there is no match. All further checks will effectively happen on
 * (source actions ∩ destination actions).
 *
 * In addition, compositors may also pick different actions in
 * reaction to key modifiers being pressed. One common design that
 * is used in major toolkits (and the behavior recommended for
 * compositors) is:
 *
 * - If no modifiers are pressed, the first match (in bit order)
 * will be used.
 * - Pressing Shift selects "move", if enabled in the mask.
 * - Pressing Control selects "copy", if enabled in the mask.
 *
 * Behavior beyond that is considered implementation-dependent.
 * Compositors may for example bind other modifiers (like Alt/Meta)
 * or drags initiated with other buttons than BTN_LEFT to specific
 * actions (e.g. "ask").
 */
enum wl_data_device_manager_dnd_action {
	/**
	 * no action
	 */
	WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE = 0,
	/**
	 * copy action
	 */
	WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY = 1,
	/**
	 * move action
	 */
	WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE = 2,
	/**
	 * ask action
	 */
	WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK = 4,
};
#endif /* WL_DATA_DEVICE_MANAGER_DND_ACTION_ENUM */

#define WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE 0
#define WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE 1


/**
 * @ingroup iface_wl_data_device_manager
 */
#define WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE_SINCE_VERSION 1
/**
 * @ingroup iface_wl_data_device_manager
 */
#define WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE_SINCE_VERSION 1

/** @ingroup iface_wl_data_device_manager */
static inline void
wl_data_device_manager_set_user_data(struct wl_data_device_manager *wl_data_device_manager, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_data_device_manager, user_data);
}

/** @ingroup iface_wl_data_device_manager */
static inline void *
wl_data_device_manager_get_user_data(struct wl_data_device_manager *wl_data_device_manager)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_data_device_manager);
}

static inline uint32_t
wl_data_device_manager_get_version(struct wl_data_device_manager *wl_data_device_manager)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_data_device_manager);
}

/** @ingroup iface_wl_data_device_manager */
static inline void
wl_data_device_manager_destroy(struct wl_data_device_manager *wl_data_device_manager)
{
	wl_proxy_destroy((struct wl_proxy *) wl_data_device_manager);
}

/**
 * @ingroup iface_wl_data_device_manager
 *
 * Create a new data source.
 */
static inline struct wl_data_source *
wl_data_device_manager_create_data_source(struct wl_data_device_manager *wl_data_device_manager)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) wl_data_device_manager,
			 WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE, &wl_data_source_interface, wl_proxy_get_version((struct wl_proxy *) wl_data_device_manager), 0, NULL);

	return (struct wl_data_source *) id;
}

/**
 * @ingroup iface_wl_data_device_manager
 *
 * Create a new data device for a given seat.
 */
static inline struct wl_data_device *
wl_data_device_manager_get_data_device(struct wl_data_device_manager *wl_data_device_manager, struct wl_seat *seat)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) wl_data_device_manager,
			 WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE, &wl_data_device_interface, wl_proxy_get_version((struct wl_proxy *) wl_data_device_manager), 0, NULL, seat);

	return (struct wl_data_device *) id;
}

#ifndef WL_SHELL_ERROR_ENUM
#define WL_SHELL_ERROR_ENUM
enum wl_shell_error {
	/**
	 * given wl_surface has another role
	 */
	WL_SHELL_ERROR_ROLE = 0,
};
#endif /* WL_SHELL_ERROR_ENUM */

#define WL_SHELL_GET_SHELL_SURFACE 0


/**
 * @ingroup iface_wl_shell
 */
#define WL_SHELL_GET_SHELL_SURFACE_SINCE_VERSION 1

/** @ingroup iface_wl_shell */
static inline void
wl_shell_set_user_data(struct wl_shell *wl_shell, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_shell, user_data);
}

/** @ingroup iface_wl_shell */
static inline void *
wl_shell_get_user_data(struct wl_shell *wl_shell)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_shell);
}

static inline uint32_t
wl_shell_get_version(struct wl_shell *wl_shell)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_shell);
}

/** @ingroup iface_wl_shell */
static inline void
wl_shell_destroy(struct wl_shell *wl_shell)
{
	wl_proxy_destroy((struct wl_proxy *) wl_shell);
}

/**
 * @ingroup iface_wl_shell
 *
 * Create a shell surface for an existing surface. This gives
 * the wl_surface the role of a shell surface. If the wl_surface
 * already has another role, it raises a protocol error.
 *
 * Only one shell surface can be associated with a given surface.
 */
static inline struct wl_shell_surface *
wl_shell_get_shell_surface(struct wl_shell *wl_shell, struct wl_surface *surface)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) wl_shell,
			 WL_SHELL_GET_SHELL_SURFACE, &wl_shell_surface_interface, wl_proxy_get_version((struct wl_proxy *) wl_shell), 0, NULL, surface);

	return (struct wl_shell_surface *) id;
}

#ifndef WL_SHELL_SURFACE_RESIZE_ENUM
#define WL_SHELL_SURFACE_RESIZE_ENUM
/**
 * @ingroup iface_wl_shell_surface
 * edge values for resizing
 *
 * These values are used to indicate which edge of a surface
 * is being dragged in a resize operation. The server may
 * use this information to adapt its behavior, e.g. choose
 * an appropriate cursor image.
 */
enum wl_shell_surface_resize {
	/**
	 * no edge
	 */
	WL_SHELL_SURFACE_RESIZE_NONE = 0,
	/**
	 * top edge
	 */
	WL_SHELL_SURFACE_RESIZE_TOP = 1,
	/**
	 * bottom edge
	 */
	WL_SHELL_SURFACE_RESIZE_BOTTOM = 2,
	/**
	 * left edge
	 */
	WL_SHELL_SURFACE_RESIZE_LEFT = 4,
	/**
	 * top and left edges
	 */
	WL_SHELL_SURFACE_RESIZE_TOP_LEFT = 5,
	/**
	 * bottom and left edges
	 */
	WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT = 6,
	/**
	 * right edge
	 */
	WL_SHELL_SURFACE_RESIZE_RIGHT = 8,
	/**
	 * top and right edges
	 */
	WL_SHELL_SURFACE_RESIZE_TOP_RIGHT = 9,
	/**
	 * bottom and right edges
	 */
	WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT = 10,
};
#endif /* WL_SHELL_SURFACE_RESIZE_ENUM */

#ifndef WL_SHELL_SURFACE_TRANSIENT_ENUM
#define WL_SHELL_SURFACE_TRANSIENT_ENUM
/**
 * @ingroup iface_wl_shell_surface
 * details of transient behaviour
 *
 * These flags specify details of the expected behaviour
 * of transient surfaces. Used in the set_transient request.
 */
enum wl_shell_surface_transient {
	/**
	 * do not set keyboard focus
	 */
	WL_SHELL_SURFACE_TRANSIENT_INACTIVE = 0x1,
};
#endif /* WL_SHELL_SURFACE_TRANSIENT_ENUM */

#ifndef WL_SHELL_SURFACE_FULLSCREEN_METHOD_ENUM
#define WL_SHELL_SURFACE_FULLSCREEN_METHOD_ENUM
/**
 * @ingroup iface_wl_shell_surface
 * different method to set the surface fullscreen
 *
 * Hints to indicate to the compositor how to deal with a conflict
 * between the dimensions of the surface and the dimensions of the
 * output. The compositor is free to ignore this parameter.
 */
enum wl_shell_surface_fullscreen_method {
	/**
	 * no preference, apply default policy
	 */
	WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT = 0,
	/**
	 * scale, preserve the surface's aspect ratio and center on output
	 */
	WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE = 1,
	/**
	 * switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
	 */
	WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER = 2,
	/**
	 * no upscaling, center on output and add black borders to compensate size mismatch
	 */
	WL_SHELL_SURFACE_FULLSCREEN_METHOD_FILL = 3,
};
#endif /* WL_SHELL_SURFACE_FULLSCREEN_METHOD_ENUM */

/**
 * @ingroup iface_wl_shell_surface
 * @struct wl_shell_surface_listener
 */
struct wl_shell_surface_listener {
	/**
	 * ping client
	 *
	 * Ping a client to check if it is receiving events and sending
	 * requests. A client is expected to reply with a pong request.
	 * @param serial serial number of the ping
	 */
	void (*ping)(void *data,
		     struct wl_shell_surface *wl_shell_surface,
		     uint32_t serial);
	/**
	 * suggest resize
	 *
	 * The configure event asks the client to resize its surface.
	 *
	 * The size is a hint, in the sense that the client is free to
	 * ignore it if it doesn't resize, pick a smaller size (to satisfy
	 * aspect ratio or resize in steps of NxM pixels).
	 *
	 * The edges parameter provides a hint about how the surface was
	 * resized. The client may use this information to decide how to
	 * adjust its content to the new size (e.g. a scrolling area might
	 * adjust its content position to leave the viewable content
	 * unmoved).
	 *
	 * The client is free to dismiss all but the last configure event
	 * it received.
	 *
	 * The width and height arguments specify the size of the window in
	 * surface-local coordinates.
	 * @param edges how the surface was resized
	 * @param width new width of the surface
	 * @param height new height of the surface
	 */
	void (*configure)(void *data,
			  struct wl_shell_surface *wl_shell_surface,
			  uint32_t edges,
			  int32_t width,
			  int32_t height);
	/**
	 * popup interaction is done
	 *
	 * The popup_done event is sent out when a popup grab is broken,
	 * that is, when the user clicks a surface that doesn't belong to
	 * the client owning the popup surface.
	 */
	void (*popup_done)(void *data,
			   struct wl_shell_surface *wl_shell_surface);
};

/**
 * @ingroup iface_wl_shell_surface
 */
static inline int
wl_shell_surface_add_listener(struct wl_shell_surface *wl_shell_surface,
			      const struct wl_shell_surface_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_shell_surface,
				     (void (**)(void)) listener, data);
}

#define WL_SHELL_SURFACE_PONG 0
#define WL_SHELL_SURFACE_MOVE 1
#define WL_SHELL_SURFACE_RESIZE 2
#define WL_SHELL_SURFACE_SET_TOPLEVEL 3
#define WL_SHELL_SURFACE_SET_TRANSIENT 4
#define WL_SHELL_SURFACE_SET_FULLSCREEN 5
#define WL_SHELL_SURFACE_SET_POPUP 6
#define WL_SHELL_SURFACE_SET_MAXIMIZED 7
#define WL_SHELL_SURFACE_SET_TITLE 8
#define WL_SHELL_SURFACE_SET_CLASS 9

/**
 * @ingroup iface_wl_shell_surface
 */
#define WL_SHELL_SURFACE_PING_SINCE_VERSION 1
/**
 * @ingroup iface_wl_shell_surface
 */
#define WL_SHELL_SURFACE_CONFIGURE_SINCE_VERSION 1
/**
 * @ingroup iface_wl_shell_surface
 */
#define WL_SHELL_SURFACE_POPUP_DONE_SINCE_VERSION 1

/**
 * @ingroup iface_wl_shell_surface
 */
#define WL_SHELL_SURFACE_PONG_SINCE_VERSION 1
/**
 * @ingroup iface_wl_shell_surface
 */
#define WL_SHELL_SURFACE_MOVE_SINCE_VERSION 1
/**
 * @ingroup iface_wl_shell_surface
 */
#define WL_SHELL_SURFACE_RESIZE_SINCE_VERSION 1
/**
 * @ingroup iface_wl_shell_surface
 */
#define WL_SHELL_SURFACE_SET_TOPLEVEL_SINCE_VERSION 1
/**
 * @ingroup iface_wl_shell_surface
 */
#define WL_SHELL_SURFACE_SET_TRANSIENT_SINCE_VERSION 1
/**
 * @ingroup iface_wl_shell_surface
 */
#define WL_SHELL_SURFACE_SET_FULLSCREEN_SINCE_VERSION 1
/**
 * @ingroup iface_wl_shell_surface
 */
#define WL_SHELL_SURFACE_SET_POPUP_SINCE_VERSION 1
/**
 * @ingroup iface_wl_shell_surface
 */
#define WL_SHELL_SURFACE_SET_MAXIMIZED_SINCE_VERSION 1
/**
 * @ingroup iface_wl_shell_surface
 */
#define WL_SHELL_SURFACE_SET_TITLE_SINCE_VERSION 1
/**
 * @ingroup iface_wl_shell_surface
 */
#define WL_SHELL_SURFACE_SET_CLASS_SINCE_VERSION 1

/** @ingroup iface_wl_shell_surface */
static inline void
wl_shell_surface_set_user_data(struct wl_shell_surface *wl_shell_surface, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_shell_surface, user_data);
}

/** @ingroup iface_wl_shell_surface */
static inline void *
wl_shell_surface_get_user_data(struct wl_shell_surface *wl_shell_surface)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_shell_surface);
}

static inline uint32_t
wl_shell_surface_get_version(struct wl_shell_surface *wl_shell_surface)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_shell_surface);
}

/** @ingroup iface_wl_shell_surface */
static inline void
wl_shell_surface_destroy(struct wl_shell_surface *wl_shell_surface)
{
	wl_proxy_destroy((struct wl_proxy *) wl_shell_surface);
}

/**
 * @ingroup iface_wl_shell_surface
 *
 * A client must respond to a ping event with a pong request or
 * the client may be deemed unresponsive.
 */
static inline void
wl_shell_surface_pong(struct wl_shell_surface *wl_shell_surface, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_shell_surface,
			 WL_SHELL_SURFACE_PONG, NULL, wl_proxy_get_version((struct wl_proxy *) wl_shell_surface), 0, serial);
}

/**
 * @ingroup iface_wl_shell_surface
 *
 * Start a pointer-driven move of the surface.
 *
 * This request must be used in response to a button press event.
 * The server may ignore move requests depending on the state of
 * the surface (e.g. fullscreen or maximized).
 */
static inline void
wl_shell_surface_move(struct wl_shell_surface *wl_shell_surface, struct wl_seat *seat, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_shell_surface,
			 WL_SHELL_SURFACE_MOVE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_shell_surface), 0, seat, serial);
}

/**
 * @ingroup iface_wl_shell_surface
 *
 * Start a pointer-driven resizing of the surface.
 *
 * This request must be used in response to a button press event.
 * The server may ignore resize requests depending on the state of
 * the surface (e.g. fullscreen or maximized).
 */
static inline void
wl_shell_surface_resize(struct wl_shell_surface *wl_shell_surface, struct wl_seat *seat, uint32_t serial, uint32_t edges)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_shell_surface,
			 WL_SHELL_SURFACE_RESIZE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_shell_surface), 0, seat, serial, edges);
}

/**
 * @ingroup iface_wl_shell_surface
 *
 * Map the surface as a toplevel surface.
 *
 * A toplevel surface is not fullscreen, maximized or transient.
 */
static inline void
wl_shell_surface_set_toplevel(struct wl_shell_surface *wl_shell_surface)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_shell_surface,
			 WL_SHELL_SURFACE_SET_TOPLEVEL, NULL, wl_proxy_get_version((struct wl_proxy *) wl_shell_surface), 0);
}

/**
 * @ingroup iface_wl_shell_surface
 *
 * Map the surface relative to an existing surface.
 *
 * The x and y arguments specify the location of the upper left
 * corner of the surface relative to the upper left corner of the
 * parent surface, in surface-local coordinates.
 *
 * The flags argument controls details of the transient behaviour.
 */
static inline void
wl_shell_surface_set_transient(struct wl_shell_surface *wl_shell_surface, struct wl_surface *parent, int32_t x, int32_t y, uint32_t flags)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_shell_surface,
			 WL_SHELL_SURFACE_SET_TRANSIENT, NULL, wl_proxy_get_version((struct wl_proxy *) wl_shell_surface), 0, parent, x, y, flags);
}

/**
 * @ingroup iface_wl_shell_surface
 *
 * Map the surface as a fullscreen surface.
 *
 * If an output parameter is given then the surface will be made
 * fullscreen on that output. If the client does not specify the
 * output then the compositor will apply its policy - usually
 * choosing the output on which the surface has the biggest surface
 * area.
 *
 * The client may specify a method to resolve a size conflict
 * between the output size and the surface size - this is provided
 * through the method parameter.
 *
 * The framerate parameter is used only when the method is set
 * to "driver", to indicate the preferred framerate. A value of 0
 * indicates that the client does not care about framerate.  The
 * framerate is specified in mHz, that is framerate of 60000 is 60Hz.
 *
 * A method of "scale" or "driver" implies a scaling operation of
 * the surface, either via a direct scaling operation or a change of
 * the output mode. This will override any kind of output scaling, so
 * that mapping a surface with a buffer size equal to the mode can
 * fill the screen independent of buffer_scale.
 *
 * A method of "fill" means we don't scale up the buffer, however
 * any output scale is applied. This means that you may run into
 * an edge case where the application maps a buffer with the same
 * size of the output mode but buffer_scale 1 (thus making a
 * surface larger than the output). In this case it is allowed to
 * downscale the results to fit the screen.
 *
 * The compositor must reply to this request with a configure event
 * with the dimensions for the output on which the surface will
 * be made fullscreen.
 */
static inline void
wl_shell_surface_set_fullscreen(struct wl_shell_surface *wl_shell_surface, uint32_t method, uint32_t framerate, struct wl_output *output)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_shell_surface,
			 WL_SHELL_SURFACE_SET_FULLSCREEN, NULL, wl_proxy_get_version((struct wl_proxy *) wl_shell_surface), 0, method, framerate, output);
}

/**
 * @ingroup iface_wl_shell_surface
 *
 * Map the surface as a popup.
 *
 * A popup surface is a transient surface with an added pointer
 * grab.
 *
 * An existing implicit grab will be changed to owner-events mode,
 * and the popup grab will continue after the implicit grab ends
 * (i.e. releasing the mouse button does not cause the popup to
 * be unmapped).
 *
 * The popup grab continues until the window is destroyed or a
 * mouse button is pressed in any other client's window. A click
 * in any of the client's surfaces is reported as normal, however,
 * clicks in other clients' surfaces will be discarded and trigger
 * the callback.
 *
 * The x and y arguments specify the location of the upper left
 * corner of the surface relative to the upper left corner of the
 * parent surface, in surface-local coordinates.
 */
static inline void
wl_shell_surface_set_popup(struct wl_shell_surface *wl_shell_surface, struct wl_seat *seat, uint32_t serial, struct wl_surface *parent, int32_t x, int32_t y, uint32_t flags)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_shell_surface,
			 WL_SHELL_SURFACE_SET_POPUP, NULL, wl_proxy_get_version((struct wl_proxy *) wl_shell_surface), 0, seat, serial, parent, x, y, flags);
}

/**
 * @ingroup iface_wl_shell_surface
 *
 * Map the surface as a maximized surface.
 *
 * If an output parameter is given then the surface will be
 * maximized on that output. If the client does not specify the
 * output then the compositor will apply its policy - usually
 * choosing the output on which the surface has the biggest surface
 * area.
 *
 * The compositor will reply with a configure event telling
 * the expected new surface size. The operation is completed
 * on the next buffer attach to this surface.
 *
 * A maximized surface typically fills the entire output it is
 * bound to, except for desktop elements such as panels. This is
 * the main difference between a maximized shell surface and a
 * fullscreen shell surface.
 *
 * The details depend on the compositor implementation.
 */
static inline void
wl_shell_surface_set_maximized(struct wl_shell_surface *wl_shell_surface, struct wl_output *output)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_shell_surface,
			 WL_SHELL_SURFACE_SET_MAXIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) wl_shell_surface), 0, output);
}

/**
 * @ingroup iface_wl_shell_surface
 *
 * Set a short title for the surface.
 *
 * This string may be used to identify the surface in a task bar,
 * window list, or other user interface elements provided by the
 * compositor.
 *
 * The string must be encoded in UTF-8.
 */
static inline void
wl_shell_surface_set_title(struct wl_shell_surface *wl_shell_surface, const char *title)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_shell_surface,
			 WL_SHELL_SURFACE_SET_TITLE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_shell_surface), 0, title);
}

/**
 * @ingroup iface_wl_shell_surface
 *
 * Set a class for the surface.
 *
 * The surface class identifies the general class of applications
 * to which the surface belongs. A common convention is to use the
 * file name (or the full path if it is a non-standard location) of
 * the application's .desktop file as the class.
 */
static inline void
wl_shell_surface_set_class(struct wl_shell_surface *wl_shell_surface, const char *class_)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_shell_surface,
			 WL_SHELL_SURFACE_SET_CLASS, NULL, wl_proxy_get_version((struct wl_proxy *) wl_shell_surface), 0, class_);
}

#ifndef WL_SURFACE_ERROR_ENUM
#define WL_SURFACE_ERROR_ENUM
/**
 * @ingroup iface_wl_surface
 * wl_surface error values
 *
 * These errors can be emitted in response to wl_surface requests.
 */
enum wl_surface_error {
	/**
	 * buffer scale value is invalid
	 */
	WL_SURFACE_ERROR_INVALID_SCALE = 0,
	/**
	 * buffer transform value is invalid
	 */
	WL_SURFACE_ERROR_INVALID_TRANSFORM = 1,
	/**
	 * buffer size is invalid
	 */
	WL_SURFACE_ERROR_INVALID_SIZE = 2,
	/**
	 * buffer offset is invalid
	 */
	WL_SURFACE_ERROR_INVALID_OFFSET = 3,
	/**
	 * surface was destroyed before its role object
	 */
	WL_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT = 4,
};
#endif /* WL_SURFACE_ERROR_ENUM */

/**
 * @ingroup iface_wl_surface
 * @struct wl_surface_listener
 */
struct wl_surface_listener {
	/**
	 * surface enters an output
	 *
	 * This is emitted whenever a surface's creation, movement, or
	 * resizing results in some part of it being within the scanout
	 * region of an output.
	 *
	 * Note that a surface may be overlapping with zero or more
	 * outputs.
	 * @param output output entered by the surface
	 */
	void (*enter)(void *data,
		      struct wl_surface *wl_surface,
		      struct wl_output *output);
	/**
	 * surface leaves an output
	 *
	 * This is emitted whenever a surface's creation, movement, or
	 * resizing results in it no longer having any part of it within
	 * the scanout region of an output.
	 *
	 * Clients should not use the number of outputs the surface is on
	 * for frame throttling purposes. The surface might be hidden even
	 * if no leave event has been sent, and the compositor might expect
	 * new surface content updates even if no enter event has been
	 * sent. The frame event should be used instead.
	 * @param output output left by the surface
	 */
	void (*leave)(void *data,
		      struct wl_surface *wl_surface,
		      struct wl_output *output);
	/**
	 * preferred buffer scale for the surface
	 *
	 * This event indicates the preferred buffer scale for this
	 * surface. It is sent whenever the compositor's preference
	 * changes.
	 *
	 * Before receiving this event the preferred buffer scale for this
	 * surface is 1.
	 *
	 * It is intended that scaling aware clients use this event to
	 * scale their content and use wl_surface.set_buffer_scale to
	 * indicate the scale they have rendered with. This allows clients
	 * to supply a higher detail buffer.
	 *
	 * The compositor shall emit a scale value greater than 0.
	 * @param factor preferred scaling factor
	 * @since 6
	 */
	void (*preferred_buffer_scale)(void *data,
				       struct wl_surface *wl_surface,
				       int32_t factor);
	/**
	 * preferred buffer transform for the surface
	 *
	 * This event indicates the preferred buffer transform for this
	 * surface. It is sent whenever the compositor's preference
	 * changes.
	 *
	 * Before receiving this event the preferred buffer transform for
	 * this surface is normal.
	 *
	 * Applying this transformation to the surface buffer contents and
	 * using wl_surface.set_buffer_transform might allow the compositor
	 * to use the surface buffer more efficiently.
	 * @param transform preferred transform
	 * @since 6
	 */
	void (*preferred_buffer_transform)(void *data,
					   struct wl_surface *wl_surface,
					   uint32_t transform);
};

/**
 * @ingroup iface_wl_surface
 */
static inline int
wl_surface_add_listener(struct wl_surface *wl_surface,
			const struct wl_surface_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_surface,
				     (void (**)(void)) listener, data);
}

#define WL_SURFACE_DESTROY 0
#define WL_SURFACE_ATTACH 1
#define WL_SURFACE_DAMAGE 2
#define WL_SURFACE_FRAME 3
#define WL_SURFACE_SET_OPAQUE_REGION 4
#define WL_SURFACE_SET_INPUT_REGION 5
#define WL_SURFACE_COMMIT 6
#define WL_SURFACE_SET_BUFFER_TRANSFORM 7
#define WL_SURFACE_SET_BUFFER_SCALE 8
#define WL_SURFACE_DAMAGE_BUFFER 9
#define WL_SURFACE_OFFSET 10

/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_ENTER_SINCE_VERSION 1
/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_LEAVE_SINCE_VERSION 1
/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_PREFERRED_BUFFER_SCALE_SINCE_VERSION 6
/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_PREFERRED_BUFFER_TRANSFORM_SINCE_VERSION 6

/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_ATTACH_SINCE_VERSION 1
/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_DAMAGE_SINCE_VERSION 1
/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_FRAME_SINCE_VERSION 1
/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_SET_OPAQUE_REGION_SINCE_VERSION 1
/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_SET_INPUT_REGION_SINCE_VERSION 1
/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_COMMIT_SINCE_VERSION 1
/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_SET_BUFFER_TRANSFORM_SINCE_VERSION 2
/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_SET_BUFFER_SCALE_SINCE_VERSION 3
/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_DAMAGE_BUFFER_SINCE_VERSION 4
/**
 * @ingroup iface_wl_surface
 */
#define WL_SURFACE_OFFSET_SINCE_VERSION 5

/** @ingroup iface_wl_surface */
static inline void
wl_surface_set_user_data(struct wl_surface *wl_surface, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_surface, user_data);
}

/** @ingroup iface_wl_surface */
static inline void *
wl_surface_get_user_data(struct wl_surface *wl_surface)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_surface);
}

static inline uint32_t
wl_surface_get_version(struct wl_surface *wl_surface)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_surface);
}

/**
 * @ingroup iface_wl_surface
 *
 * Deletes the surface and invalidates its object ID.
 */
static inline void
wl_surface_destroy(struct wl_surface *wl_surface)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_surface,
			 WL_SURFACE_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) wl_surface), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_wl_surface
 *
 * Set a buffer as the content of this surface.
 *
 * The new size of the surface is calculated based on the buffer
 * size transformed by the inverse buffer_transform and the
 * inverse buffer_scale. This means that at commit time the supplied
 * buffer size must be an integer multiple of the buffer_scale. If
 * that's not the case, an invalid_size error is sent.
 *
 * The x and y arguments specify the location of the new pending
 * buffer's upper left corner, relative to the current buffer's upper
 * left corner, in surface-local coordinates. In other words, the
 * x and y, combined with the new surface size define in which
 * directions the surface's size changes. Setting anything other than 0
 * as x and y arguments is discouraged, and should instead be replaced
 * with using the separate wl_surface.offset request.
 *
 * When the bound wl_surface version is 5 or higher, passing any
 * non-zero x or y is a protocol violation, and will result in an
 * 'invalid_offset' error being raised. The x and y arguments are ignored
 * and do not change the pending state. To achieve equivalent semantics,
 * use wl_surface.offset.
 *
 * Surface contents are double-buffered state, see wl_surface.commit.
 *
 * The initial surface contents are void; there is no content.
 * wl_surface.attach assigns the given wl_buffer as the pending
 * wl_buffer. wl_surface.commit makes the pending wl_buffer the new
 * surface contents, and the size of the surface becomes the size
 * calculated from the wl_buffer, as described above. After commit,
 * there is no pending buffer until the next attach.
 *
 * Committing a pending wl_buffer allows the compositor to read the
 * pixels in the wl_buffer. The compositor may access the pixels at
 * any time after the wl_surface.commit request. When the compositor
 * will not access the pixels anymore, it will send the
 * wl_buffer.release event. Only after receiving wl_buffer.release,
 * the client may reuse the wl_buffer. A wl_buffer that has been
 * attached and then replaced by another attach instead of committed
 * will not receive a release event, and is not used by the
 * compositor.
 *
 * If a pending wl_buffer has been committed to more than one wl_surface,
 * the delivery of wl_buffer.release events becomes undefined. A well
 * behaved client should not rely on wl_buffer.release events in this
 * case. Alternatively, a client could create multiple wl_buffer objects
 * from the same backing storage or use wp_linux_buffer_release.
 *
 * Destroying the wl_buffer after wl_buffer.release does not change
 * the surface contents. Destroying the wl_buffer before wl_buffer.release
 * is allowed as long as the underlying buffer storage isn't re-used (this
 * can happen e.g. on client process termination). However, if the client
 * destroys the wl_buffer before receiving the wl_buffer.release event and
 * mutates the underlying buffer storage, the surface contents become
 * undefined immediately.
 *
 * If wl_surface.attach is sent with a NULL wl_buffer, the
 * following wl_surface.commit will remove the surface content.
 *
 * If a pending wl_buffer has been destroyed, the result is not specified.
 * Many compositors are known to remove the surface content on the following
 * wl_surface.commit, but this behaviour is not universal. Clients seeking to
 * maximise compatibility should not destroy pending buffers and should
 * ensure that they explicitly remove content from surfaces, even after
 * destroying buffers.
 */
static inline void
wl_surface_attach(struct wl_surface *wl_surface, struct wl_buffer *buffer, int32_t x, int32_t y)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_surface,
			 WL_SURFACE_ATTACH, NULL, wl_proxy_get_version((struct wl_proxy *) wl_surface), 0, buffer, x, y);
}

/**
 * @ingroup iface_wl_surface
 *
 * This request is used to describe the regions where the pending
 * buffer is different from the current surface contents, and where
 * the surface therefore needs to be repainted. The compositor
 * ignores the parts of the damage that fall outside of the surface.
 *
 * Damage is double-buffered state, see wl_surface.commit.
 *
 * The damage rectangle is specified in surface-local coordinates,
 * where x and y specify the upper left corner of the damage rectangle.
 *
 * The initial value for pending damage is empty: no damage.
 * wl_surface.damage adds pending damage: the new pending damage
 * is the union of old pending damage and the given rectangle.
 *
 * wl_surface.commit assigns pending damage as the current damage,
 * and clears pending damage. The server will clear the current
 * damage as it repaints the surface.
 *
 * Note! New clients should not use this request. Instead damage can be
 * posted with wl_surface.damage_buffer which uses buffer coordinates
 * instead of surface coordinates.
 */
static inline void
wl_surface_damage(struct wl_surface *wl_surface, int32_t x, int32_t y, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_surface,
			 WL_SURFACE_DAMAGE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_surface), 0, x, y, width, height);
}

/**
 * @ingroup iface_wl_surface
 *
 * Request a notification when it is a good time to start drawing a new
 * frame, by creating a frame callback. This is useful for throttling
 * redrawing operations, and driving animations.
 *
 * When a client is animating on a wl_surface, it can use the 'frame'
 * request to get notified when it is a good time to draw and commit the
 * next frame of animation. If the client commits an update earlier than
 * that, it is likely that some updates will not make it to the display,
 * and the client is wasting resources by drawing too often.
 *
 * The frame request will take effect on the next wl_surface.commit.
 * The notification will only be posted for one frame unless
 * requested again. For a wl_surface, the notifications are posted in
 * the order the frame requests were committed.
 *
 * The server must send the notifications so that a client
 * will not send excessive updates, while still allowing
 * the highest possible update rate for clients that wait for the reply
 * before drawing again. The server should give some time for the client
 * to draw and commit after sending the frame callback events to let it
 * hit the next output refresh.
 *
 * A server should avoid signaling the frame callbacks if the
 * surface is not visible in any way, e.g. the surface is off-screen,
 * or completely obscured by other opaque surfaces.
 *
 * The object returned by this request will be destroyed by the
 * compositor after the callback is fired and as such the client must not
 * attempt to use it after that point.
 *
 * The callback_data passed in the callback is the current time, in
 * milliseconds, with an undefined base.
 */
static inline struct wl_callback *
wl_surface_frame(struct wl_surface *wl_surface)
{
	struct wl_proxy *callback;

	callback = wl_proxy_marshal_flags((struct wl_proxy *) wl_surface,
			 WL_SURFACE_FRAME, &wl_callback_interface, wl_proxy_get_version((struct wl_proxy *) wl_surface), 0, NULL);

	return (struct wl_callback *) callback;
}

/**
 * @ingroup iface_wl_surface
 *
 * This request sets the region of the surface that contains
 * opaque content.
 *
 * The opaque region is an optimization hint for the compositor
 * that lets it optimize the redrawing of content behind opaque
 * regions.  Setting an opaque region is not required for correct
 * behaviour, but marking transparent content as opaque will result
 * in repaint artifacts.
 *
 * The opaque region is specified in surface-local coordinates.
 *
 * The compositor ignores the parts of the opaque region that fall
 * outside of the surface.
 *
 * Opaque region is double-buffered state, see wl_surface.commit.
 *
 * wl_surface.set_opaque_region changes the pending opaque region.
 * wl_surface.commit copies the pending region to the current region.
 * Otherwise, the pending and current regions are never changed.
 *
 * The initial value for an opaque region is empty. Setting the pending
 * opaque region has copy semantics, and the wl_region object can be
 * destroyed immediately. A NULL wl_region causes the pending opaque
 * region to be set to empty.
 */
static inline void
wl_surface_set_opaque_region(struct wl_surface *wl_surface, struct wl_region *region)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_surface,
			 WL_SURFACE_SET_OPAQUE_REGION, NULL, wl_proxy_get_version((struct wl_proxy *) wl_surface), 0, region);
}

/**
 * @ingroup iface_wl_surface
 *
 * This request sets the region of the surface that can receive
 * pointer and touch events.
 *
 * Input events happening outside of this region will try the next
 * surface in the server surface stack. The compositor ignores the
 * parts of the input region that fall outside of the surface.
 *
 * The input region is specified in surface-local coordinates.
 *
 * Input region is double-buffered state, see wl_surface.commit.
 *
 * wl_surface.set_input_region changes the pending input region.
 * wl_surface.commit copies the pending region to the current region.
 * Otherwise the pending and current regions are never changed,
 * except cursor and icon surfaces are special cases, see
 * wl_pointer.set_cursor and wl_data_device.start_drag.
 *
 * The initial value for an input region is infinite. That means the
 * whole surface will accept input. Setting the pending input region
 * has copy semantics, and the wl_region object can be destroyed
 * immediately. A NULL wl_region causes the input region to be set
 * to infinite.
 */
static inline void
wl_surface_set_input_region(struct wl_surface *wl_surface, struct wl_region *region)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_surface,
			 WL_SURFACE_SET_INPUT_REGION, NULL, wl_proxy_get_version((struct wl_proxy *) wl_surface), 0, region);
}

/**
 * @ingroup iface_wl_surface
 *
 * Surface state (input, opaque, and damage regions, attached buffers,
 * etc.) is double-buffered. Protocol requests modify the pending state,
 * as opposed to the active state in use by the compositor.
 *
 * A commit request atomically creates a content update from the pending
 * state, even if the pending state has not been touched. The content
 * update is placed in a queue until it becomes active. After commit, the
 * new pending state is as documented for each related request.
 *
 * When the content update is applied, the wl_buffer is applied before all
 * other state. This means that all coordinates in double-buffered state
 * are relative to the newly attached wl_buffers, except for
 * wl_surface.attach itself. If there is no newly attached wl_buffer, the
 * coordinates are relative to the previous content update.
 *
 * All requests that need a commit to become effective are documented
 * to affect double-buffered state.
 *
 * Other interfaces may add further double-buffered surface state.
 */
static inline void
wl_surface_commit(struct wl_surface *wl_surface)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_surface,
			 WL_SURFACE_COMMIT, NULL, wl_proxy_get_version((struct wl_proxy *) wl_surface), 0);
}

/**
 * @ingroup iface_wl_surface
 *
 * This request sets the transformation that the client has already applied
 * to the content of the buffer. The accepted values for the transform
 * parameter are the values for wl_output.transform.
 *
 * The compositor applies the inverse of this transformation whenever it
 * uses the buffer contents.
 *
 * Buffer transform is double-buffered state, see wl_surface.commit.
 *
 * A newly created surface has its buffer transformation set to normal.
 *
 * wl_surface.set_buffer_transform changes the pending buffer
 * transformation. wl_surface.commit copies the pending buffer
 * transformation to the current one. Otherwise, the pending and current
 * values are never changed.
 *
 * The purpose of this request is to allow clients to render content
 * according to the output transform, thus permitting the compositor to
 * use certain optimizations even if the display is rotated. Using
 * hardware overlays and scanning out a client buffer for fullscreen
 * surfaces are examples of such optimizations. Those optimizations are
 * highly dependent on the compositor implementation, so the use of this
 * request should be considered on a case-by-case basis.
 *
 * Note that if the transform value includes 90 or 270 degree rotation,
 * the width of the buffer will become the surface height and the height
 * of the buffer will become the surface width.
 *
 * If transform is not one of the values from the
 * wl_output.transform enum the invalid_transform protocol error
 * is raised.
 */
static inline void
wl_surface_set_buffer_transform(struct wl_surface *wl_surface, int32_t transform)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_surface,
			 WL_SURFACE_SET_BUFFER_TRANSFORM, NULL, wl_proxy_get_version((struct wl_proxy *) wl_surface), 0, transform);
}

/**
 * @ingroup iface_wl_surface
 *
 * This request sets an optional scaling factor on how the compositor
 * interprets the contents of the buffer attached to the window.
 *
 * Buffer scale is double-buffered state, see wl_surface.commit.
 *
 * A newly created surface has its buffer scale set to 1.
 *
 * wl_surface.set_buffer_scale changes the pending buffer scale.
 * wl_surface.commit copies the pending buffer scale to the current one.
 * Otherwise, the pending and current values are never changed.
 *
 * The purpose of this request is to allow clients to supply higher
 * resolution buffer data for use on high resolution outputs. It is
 * intended that you pick the same buffer scale as the scale of the
 * output that the surface is displayed on. This means the compositor
 * can avoid scaling when rendering the surface on that output.
 *
 * Note that if the scale is larger than 1, then you have to attach
 * a buffer that is larger (by a factor of scale in each dimension)
 * than the desired surface size.
 *
 * If scale is not greater than 0 the invalid_scale protocol error is
 * raised.
 */
static inline void
wl_surface_set_buffer_scale(struct wl_surface *wl_surface, int32_t scale)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_surface,
			 WL_SURFACE_SET_BUFFER_SCALE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_surface), 0, scale);
}

/**
 * @ingroup iface_wl_surface
 *
 * This request is used to describe the regions where the pending
 * buffer is different from the current surface contents, and where
 * the surface therefore needs to be repainted. The compositor
 * ignores the parts of the damage that fall outside of the surface.
 *
 * Damage is double-buffered state, see wl_surface.commit.
 *
 * The damage rectangle is specified in buffer coordinates,
 * where x and y specify the upper left corner of the damage rectangle.
 *
 * The initial value for pending damage is empty: no damage.
 * wl_surface.damage_buffer adds pending damage: the new pending
 * damage is the union of old pending damage and the given rectangle.
 *
 * wl_surface.commit assigns pending damage as the current damage,
 * and clears pending damage. The server will clear the current
 * damage as it repaints the surface.
 *
 * This request differs from wl_surface.damage in only one way - it
 * takes damage in buffer coordinates instead of surface-local
 * coordinates. While this generally is more intuitive than surface
 * coordinates, it is especially desirable when using wp_viewport
 * or when a drawing library (like EGL) is unaware of buffer scale
 * and buffer transform.
 *
 * Note: Because buffer transformation changes and damage requests may
 * be interleaved in the protocol stream, it is impossible to determine
 * the actual mapping between surface and buffer damage until
 * wl_surface.commit time. Therefore, compositors wishing to take both
 * kinds of damage into account will have to accumulate damage from the
 * two requests separately and only transform from one to the other
 * after receiving the wl_surface.commit.
 */
static inline void
wl_surface_damage_buffer(struct wl_surface *wl_surface, int32_t x, int32_t y, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_surface,
			 WL_SURFACE_DAMAGE_BUFFER, NULL, wl_proxy_get_version((struct wl_proxy *) wl_surface), 0, x, y, width, height);
}

/**
 * @ingroup iface_wl_surface
 *
 * The x and y arguments specify the location of the new pending
 * buffer's upper left corner, relative to the current buffer's upper
 * left corner, in surface-local coordinates. In other words, the
 * x and y, combined with the new surface size define in which
 * directions the surface's size changes.
 *
 * Surface location offset is double-buffered state, see
 * wl_surface.commit.
 *
 * This request is semantically equivalent to and the replaces the x and y
 * arguments in the wl_surface.attach request in wl_surface versions prior
 * to 5. See wl_surface.attach for details.
 */
static inline void
wl_surface_offset(struct wl_surface *wl_surface, int32_t x, int32_t y)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_surface,
			 WL_SURFACE_OFFSET, NULL, wl_proxy_get_version((struct wl_proxy *) wl_surface), 0, x, y);
}

#ifndef WL_SEAT_CAPABILITY_ENUM
#define WL_SEAT_CAPABILITY_ENUM
/**
 * @ingroup iface_wl_seat
 * seat capability bitmask
 *
 * This is a bitmask of capabilities this seat has; if a member is
 * set, then it is present on the seat.
 */
enum wl_seat_capability {
	/**
	 * the seat has pointer devices
	 */
	WL_SEAT_CAPABILITY_POINTER = 1,
	/**
	 * the seat has one or more keyboards
	 */
	WL_SEAT_CAPABILITY_KEYBOARD = 2,
	/**
	 * the seat has touch devices
	 */
	WL_SEAT_CAPABILITY_TOUCH = 4,
};
#endif /* WL_SEAT_CAPABILITY_ENUM */

#ifndef WL_SEAT_ERROR_ENUM
#define WL_SEAT_ERROR_ENUM
/**
 * @ingroup iface_wl_seat
 * wl_seat error values
 *
 * These errors can be emitted in response to wl_seat requests.
 */
enum wl_seat_error {
	/**
	 * get_pointer, get_keyboard or get_touch called on seat without the matching capability
	 */
	WL_SEAT_ERROR_MISSING_CAPABILITY = 0,
};
#endif /* WL_SEAT_ERROR_ENUM */

/**
 * @ingroup iface_wl_seat
 * @struct wl_seat_listener
 */
struct wl_seat_listener {
	/**
	 * seat capabilities changed
	 *
	 * This is emitted whenever a seat gains or loses the pointer,
	 * keyboard or touch capabilities. The argument is a capability
	 * enum containing the complete set of capabilities this seat has.
	 *
	 * When the pointer capability is added, a client may create a
	 * wl_pointer object using the wl_seat.get_pointer request. This
	 * object will receive pointer events until the capability is
	 * removed in the future.
	 *
	 * When the pointer capability is removed, a client should destroy
	 * the wl_pointer objects associated with the seat where the
	 * capability was removed, using the wl_pointer.release request. No
	 * further pointer events will be received on these objects.
	 *
	 * In some compositors, if a seat regains the pointer capability
	 * and a client has a previously obtained wl_pointer object of
	 * version 4 or less, that object may start sending pointer events
	 * again. This behavior is considered a misinterpretation of the
	 * intended behavior and must not be relied upon by the client.
	 * wl_pointer objects of version 5 or later must not send events if
	 * created before the most recent event notifying the client of an
	 * added pointer capability.
	 *
	 * The above behavior also applies to wl_keyboard and wl_touch with
	 * the keyboard and touch capabilities, respectively.
	 * @param capabilities capabilities of the seat
	 */
	void (*capabilities)(void *data,
			     struct wl_seat *wl_seat,
			     uint32_t capabilities);
	/**
	 * unique identifier for this seat
	 *
	 * In a multi-seat configuration the seat name can be used by
	 * clients to help identify which physical devices the seat
	 * represents.
	 *
	 * The seat name is a UTF-8 string with no convention defined for
	 * its contents. Each name is unique among all wl_seat globals. The
	 * name is only guaranteed to be unique for the current compositor
	 * instance.
	 *
	 * The same seat names are used for all clients. Thus, the name can
	 * be shared across processes to refer to a specific wl_seat
	 * global.
	 *
	 * The name event is sent after binding to the seat global. This
	 * event is only sent once per seat object, and the name does not
	 * change over the lifetime of the wl_seat global.
	 *
	 * Compositors may re-use the same seat name if the wl_seat global
	 * is destroyed and re-created later.
	 * @param name seat identifier
	 * @since 2
	 */
	void (*name)(void *data,
		     struct wl_seat *wl_seat,
		     const char *name);
};

/**
 * @ingroup iface_wl_seat
 */
static inline int
wl_seat_add_listener(struct wl_seat *wl_seat,
		     const struct wl_seat_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_seat,
				     (void (**)(void)) listener, data);
}

#define WL_SEAT_GET_POINTER 0
#define WL_SEAT_GET_KEYBOARD 1
#define WL_SEAT_GET_TOUCH 2
#define WL_SEAT_RELEASE 3

/**
 * @ingroup iface_wl_seat
 */
#define WL_SEAT_CAPABILITIES_SINCE_VERSION 1
/**
 * @ingroup iface_wl_seat
 */
#define WL_SEAT_NAME_SINCE_VERSION 2

/**
 * @ingroup iface_wl_seat
 */
#define WL_SEAT_GET_POINTER_SINCE_VERSION 1
/**
 * @ingroup iface_wl_seat
 */
#define WL_SEAT_GET_KEYBOARD_SINCE_VERSION 1
/**
 * @ingroup iface_wl_seat
 */
#define WL_SEAT_GET_TOUCH_SINCE_VERSION 1
/**
 * @ingroup iface_wl_seat
 */
#define WL_SEAT_RELEASE_SINCE_VERSION 5

/** @ingroup iface_wl_seat */
static inline void
wl_seat_set_user_data(struct wl_seat *wl_seat, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_seat, user_data);
}

/** @ingroup iface_wl_seat */
static inline void *
wl_seat_get_user_data(struct wl_seat *wl_seat)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_seat);
}

static inline uint32_t
wl_seat_get_version(struct wl_seat *wl_seat)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_seat);
}

/** @ingroup iface_wl_seat */
static inline void
wl_seat_destroy(struct wl_seat *wl_seat)
{
	wl_proxy_destroy((struct wl_proxy *) wl_seat);
}

/**
 * @ingroup iface_wl_seat
 *
 * The ID provided will be initialized to the wl_pointer interface
 * for this seat.
 *
 * This request only takes effect if the seat has the pointer
 * capability, or has had the pointer capability in the past.
 * It is a protocol violation to issue this request on a seat that has
 * never had the pointer capability. The missing_capability error will
 * be sent in this case.
 */
static inline struct wl_pointer *
wl_seat_get_pointer(struct wl_seat *wl_seat)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) wl_seat,
			 WL_SEAT_GET_POINTER, &wl_pointer_interface, wl_proxy_get_version((struct wl_proxy *) wl_seat), 0, NULL);

	return (struct wl_pointer *) id;
}

/**
 * @ingroup iface_wl_seat
 *
 * The ID provided will be initialized to the wl_keyboard interface
 * for this seat.
 *
 * This request only takes effect if the seat has the keyboard
 * capability, or has had the keyboard capability in the past.
 * It is a protocol violation to issue this request on a seat that has
 * never had the keyboard capability. The missing_capability error will
 * be sent in this case.
 */
static inline struct wl_keyboard *
wl_seat_get_keyboard(struct wl_seat *wl_seat)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) wl_seat,
			 WL_SEAT_GET_KEYBOARD, &wl_keyboard_interface, wl_proxy_get_version((struct wl_proxy *) wl_seat), 0, NULL);

	return (struct wl_keyboard *) id;
}

/**
 * @ingroup iface_wl_seat
 *
 * The ID provided will be initialized to the wl_touch interface
 * for this seat.
 *
 * This request only takes effect if the seat has the touch
 * capability, or has had the touch capability in the past.
 * It is a protocol violation to issue this request on a seat that has
 * never had the touch capability. The missing_capability error will
 * be sent in this case.
 */
static inline struct wl_touch *
wl_seat_get_touch(struct wl_seat *wl_seat)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) wl_seat,
			 WL_SEAT_GET_TOUCH, &wl_touch_interface, wl_proxy_get_version((struct wl_proxy *) wl_seat), 0, NULL);

	return (struct wl_touch *) id;
}

/**
 * @ingroup iface_wl_seat
 *
 * Using this request a client can tell the server that it is not going to
 * use the seat object anymore.
 */
static inline void
wl_seat_release(struct wl_seat *wl_seat)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_seat,
			 WL_SEAT_RELEASE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_seat), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef WL_POINTER_ERROR_ENUM
#define WL_POINTER_ERROR_ENUM
enum wl_pointer_error {
	/**
	 * given wl_surface has another role
	 */
	WL_POINTER_ERROR_ROLE = 0,
};
#endif /* WL_POINTER_ERROR_ENUM */

#ifndef WL_POINTER_BUTTON_STATE_ENUM
#define WL_POINTER_BUTTON_STATE_ENUM
/**
 * @ingroup iface_wl_pointer
 * physical button state
 *
 * Describes the physical state of a button that produced the button
 * event.
 */
enum wl_pointer_button_state {
	/**
	 * the button is not pressed
	 */
	WL_POINTER_BUTTON_STATE_RELEASED = 0,
	/**
	 * the button is pressed
	 */
	WL_POINTER_BUTTON_STATE_PRESSED = 1,
};
#endif /* WL_POINTER_BUTTON_STATE_ENUM */

#ifndef WL_POINTER_AXIS_ENUM
#define WL_POINTER_AXIS_ENUM
/**
 * @ingroup iface_wl_pointer
 * axis types
 *
 * Describes the axis types of scroll events.
 */
enum wl_pointer_axis {
	/**
	 * vertical axis
	 */
	WL_POINTER_AXIS_VERTICAL_SCROLL = 0,
	/**
	 * horizontal axis
	 */
	WL_POINTER_AXIS_HORIZONTAL_SCROLL = 1,
};
#endif /* WL_POINTER_AXIS_ENUM */

#ifndef WL_POINTER_AXIS_SOURCE_ENUM
#define WL_POINTER_AXIS_SOURCE_ENUM
/**
 * @ingroup iface_wl_pointer
 * axis source types
 *
 * Describes the source types for axis events. This indicates to the
 * client how an axis event was physically generated; a client may
 * adjust the user interface accordingly. For example, scroll events
 * from a "finger" source may be in a smooth coordinate space with
 * kinetic scrolling whereas a "wheel" source may be in discrete steps
 * of a number of lines.
 *
 * The "continuous" axis source is a device generating events in a
 * continuous coordinate space, but using something other than a
 * finger. One example for this source is button-based scrolling where
 * the vertical motion of a device is converted to scroll events while
 * a button is held down.
 *
 * The "wheel tilt" axis source indicates that the actual device is a
 * wheel but the scroll event is not caused by a rotation but a
 * (usually sideways) tilt of the wheel.
 */
enum wl_pointer_axis_source {
	/**
	 * a physical wheel rotation
	 */
	WL_POINTER_AXIS_SOURCE_WHEEL = 0,
	/**
	 * finger on a touch surface
	 */
	WL_POINTER_AXIS_SOURCE_FINGER = 1,
	/**
	 * continuous coordinate space
	 */
	WL_POINTER_AXIS_SOURCE_CONTINUOUS = 2,
	/**
	 * a physical wheel tilt
	 * @since 6
	 */
	WL_POINTER_AXIS_SOURCE_WHEEL_TILT = 3,
};
/**
 * @ingroup iface_wl_pointer
 */
#define WL_POINTER_AXIS_SOURCE_WHEEL_TILT_SINCE_VERSION 6
#endif /* WL_POINTER_AXIS_SOURCE_ENUM */

#ifndef WL_POINTER_AXIS_RELATIVE_DIRECTION_ENUM
#define WL_POINTER_AXIS_RELATIVE_DIRECTION_ENUM
/**
 * @ingroup iface_wl_pointer
 * axis relative direction
 *
 * This specifies the direction of the physical motion that caused a
 * wl_pointer.axis event, relative to the wl_pointer.axis direction.
 */
enum wl_pointer_axis_relative_direction {
	/**
	 * physical motion matches axis direction
	 */
	WL_POINTER_AXIS_RELATIVE_DIRECTION_IDENTICAL = 0,
	/**
	 * physical motion is the inverse of the axis direction
	 */
	WL_POINTER_AXIS_RELATIVE_DIRECTION_INVERTED = 1,
};
#endif /* WL_POINTER_AXIS_RELATIVE_DIRECTION_ENUM */

/**
 * @ingroup iface_wl_pointer
 * @struct wl_pointer_listener
 */
struct wl_pointer_listener {
	/**
	 * enter event
	 *
	 * Notification that this seat's pointer is focused on a certain
	 * surface.
	 *
	 * When a seat's focus enters a surface, the pointer image is
	 * undefined and a client should respond to this event by setting
	 * an appropriate pointer image with the set_cursor request.
	 * @param serial serial number of the enter event
	 * @param surface surface entered by the pointer
	 * @param surface_x surface-local x coordinate
	 * @param surface_y surface-local y coordinate
	 */
	void (*enter)(void *data,
		      struct wl_pointer *wl_pointer,
		      uint32_t serial,
		      struct wl_surface *surface,
		      wl_fixed_t surface_x,
		      wl_fixed_t surface_y);
	/**
	 * leave event
	 *
	 * Notification that this seat's pointer is no longer focused on
	 * a certain surface.
	 *
	 * The leave notification is sent before the enter notification for
	 * the new focus.
	 * @param serial serial number of the leave event
	 * @param surface surface left by the pointer
	 */
	void (*leave)(void *data,
		      struct wl_pointer *wl_pointer,
		      uint32_t serial,
		      struct wl_surface *surface);
	/**
	 * pointer motion event
	 *
	 * Notification of pointer location change. The arguments
	 * surface_x and surface_y are the location relative to the focused
	 * surface.
	 * @param time timestamp with millisecond granularity
	 * @param surface_x surface-local x coordinate
	 * @param surface_y surface-local y coordinate
	 */
	void (*motion)(void *data,
		       struct wl_pointer *wl_pointer,
		       uint32_t time,
		       wl_fixed_t surface_x,
		       wl_fixed_t surface_y);
	/**
	 * pointer button event
	 *
	 * Mouse button click and release notifications.
	 *
	 * The location of the click is given by the last motion or enter
	 * event. The time argument is a timestamp with millisecond
	 * granularity, with an undefined base.
	 *
	 * The button is a button code as defined in the Linux kernel's
	 * linux/input-event-codes.h header file, e.g. BTN_LEFT.
	 *
	 * Any 16-bit button code value is reserved for future additions to
	 * the kernel's event code list. All other button codes above
	 * 0xFFFF are currently undefined but may be used in future
	 * versions of this protocol.
	 * @param serial serial number of the button event
	 * @param time timestamp with millisecond granularity
	 * @param button button that produced the event
	 * @param state physical state of the button
	 */
	void (*button)(void *data,
		       struct wl_pointer *wl_pointer,
		       uint32_t serial,
		       uint32_t time,
		       uint32_t button,
		       uint32_t state);
	/**
	 * axis event
	 *
	 * Scroll and other axis notifications.
	 *
	 * For scroll events (vertical and horizontal scroll axes), the
	 * value parameter is the length of a vector along the specified
	 * axis in a coordinate space identical to those of motion events,
	 * representing a relative movement along the specified axis.
	 *
	 * For devices that support movements non-parallel to axes multiple
	 * axis events will be emitted.
	 *
	 * When applicable, for example for touch pads, the server can
	 * choose to emit scroll events where the motion vector is
	 * equivalent to a motion event vector.
	 *
	 * When applicable, a client can transform its content relative to
	 * the scroll distance.
	 * @param time timestamp with millisecond granularity
	 * @param axis axis type
	 * @param value length of vector in surface-local coordinate space
	 */
	void (*axis)(void *data,
		     struct wl_pointer *wl_pointer,
		     uint32_t time,
		     uint32_t axis,
		     wl_fixed_t value);
	/**
	 * end of a pointer event sequence
	 *
	 * Indicates the end of a set of events that logically belong
	 * together. A client is expected to accumulate the data in all
	 * events within the frame before proceeding.
	 *
	 * All wl_pointer events before a wl_pointer.frame event belong
	 * logically together. For example, in a diagonal scroll motion the
	 * compositor will send an optional wl_pointer.axis_source event,
	 * two wl_pointer.axis events (horizontal and vertical) and finally
	 * a wl_pointer.frame event. The client may use this information to
	 * calculate a diagonal vector for scrolling.
	 *
	 * When multiple wl_pointer.axis events occur within the same
	 * frame, the motion vector is the combined motion of all events.
	 * When a wl_pointer.axis and a wl_pointer.axis_stop event occur
	 * within the same frame, this indicates that axis movement in one
	 * axis has stopped but continues in the other axis. When multiple
	 * wl_pointer.axis_stop events occur within the same frame, this
	 * indicates that these axes stopped in the same instance.
	 *
	 * A wl_pointer.frame event is sent for every logical event group,
	 * even if the group only contains a single wl_pointer event.
	 * Specifically, a client may get a sequence: motion, frame,
	 * button, frame, axis, frame, axis_stop, frame.
	 *
	 * The wl_pointer.enter and wl_pointer.leave events are logical
	 * events generated by the compositor and not the hardware. These
	 * events are also grouped by a wl_pointer.frame. When a pointer
	 * moves from one surface to another, a compositor should group the
	 * wl_pointer.leave event within the same wl_pointer.frame.
	 * However, a client must not rely on wl_pointer.leave and
	 * wl_pointer.enter being in the same wl_pointer.frame.
	 * Compositor-specific policies may require the wl_pointer.leave
	 * and wl_pointer.enter event being split across multiple
	 * wl_pointer.frame groups.
	 * @since 5
	 */
	void (*frame)(void *data,
		      struct wl_pointer *wl_pointer);
	/**
	 * axis source event
	 *
	 * Source information for scroll and other axes.
	 *
	 * This event does not occur on its own. It is sent before a
	 * wl_pointer.frame event and carries the source information for
	 * all events within that frame.
	 *
	 * The source specifies how this event was generated. If the source
	 * is wl_pointer.axis_source.finger, a wl_pointer.axis_stop event
	 * will be sent when the user lifts the finger off the device.
	 *
	 * If the source is wl_pointer.axis_source.wheel,
	 * wl_pointer.axis_source.wheel_tilt or
	 * wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event
	 * may or may not be sent. Whether a compositor sends an axis_stop
	 * event for these sources is hardware-specific and
	 * implementation-dependent; clients must not rely on receiving an
	 * axis_stop event for these scroll sources and should treat scroll
	 * sequences from these scroll sources as unterminated by default.
	 *
	 * This event is optional. If the source is unknown for a
	 * particular axis event sequence, no event is sent. Only one
	 * wl_pointer.axis_source event is permitted per frame.
	 *
	 * The order of wl_pointer.axis_discrete and wl_pointer.axis_source
	 * is not guaranteed.
	 * @param axis_source source of the axis event
	 * @since 5
	 */
	void (*axis_source)(void *data,
			    struct wl_pointer *wl_pointer,
			    uint32_t axis_source);
	/**
	 * axis stop event
	 *
	 * Stop notification for scroll and other axes.
	 *
	 * For some wl_pointer.axis_source types, a wl_pointer.axis_stop
	 * event is sent to notify a client that the axis sequence has
	 * terminated. This enables the client to implement kinetic
	 * scrolling. See the wl_pointer.axis_source documentation for
	 * information on when this event may be generated.
	 *
	 * Any wl_pointer.axis events with the same axis_source after this
	 * event should be considered as the start of a new axis motion.
	 *
	 * The timestamp is to be interpreted identical to the timestamp in
	 * the wl_pointer.axis event. The timestamp value may be the same
	 * as a preceding wl_pointer.axis event.
	 * @param time timestamp with millisecond granularity
	 * @param axis the axis stopped with this event
	 * @since 5
	 */
	void (*axis_stop)(void *data,
			  struct wl_pointer *wl_pointer,
			  uint32_t time,
			  uint32_t axis);
	/**
	 * axis click event
	 *
	 * Discrete step information for scroll and other axes.
	 *
	 * This event carries the axis value of the wl_pointer.axis event
	 * in discrete steps (e.g. mouse wheel clicks).
	 *
	 * This event is deprecated with wl_pointer version 8 - this event
	 * is not sent to clients supporting version 8 or later.
	 *
	 * This event does not occur on its own, it is coupled with a
	 * wl_pointer.axis event that represents this axis value on a
	 * continuous scale. The protocol guarantees that each
	 * axis_discrete event is always followed by exactly one axis event
	 * with the same axis number within the same wl_pointer.frame. Note
	 * that the protocol allows for other events to occur between the
	 * axis_discrete and its coupled axis event, including other
	 * axis_discrete or axis events. A wl_pointer.frame must not
	 * contain more than one axis_discrete event per axis type.
	 *
	 * This event is optional; continuous scrolling devices like
	 * two-finger scrolling on touchpads do not have discrete steps and
	 * do not generate this event.
	 *
	 * The discrete value carries the directional information. e.g. a
	 * value of -2 is two steps towards the negative direction of this
	 * axis.
	 *
	 * The axis number is identical to the axis number in the
	 * associated axis event.
	 *
	 * The order of wl_pointer.axis_discrete and wl_pointer.axis_source
	 * is not guaranteed.
	 * @param axis axis type
	 * @param discrete number of steps
	 * @since 5
	 * @deprecated Deprecated since version 8
	 */
	void (*axis_discrete)(void *data,
			      struct wl_pointer *wl_pointer,
			      uint32_t axis,
			      int32_t discrete);
	/**
	 * axis high-resolution scroll event
	 *
	 * Discrete high-resolution scroll information.
	 *
	 * This event carries high-resolution wheel scroll information,
	 * with each multiple of 120 representing one logical scroll step
	 * (a wheel detent). For example, an axis_value120 of 30 is one
	 * quarter of a logical scroll step in the positive direction, a
	 * value120 of -240 are two logical scroll steps in the negative
	 * direction within the same hardware event. Clients that rely on
	 * discrete scrolling should accumulate the value120 to multiples
	 * of 120 before processing the event.
	 *
	 * The value120 must not be zero.
	 *
	 * This event replaces the wl_pointer.axis_discrete event in
	 * clients supporting wl_pointer version 8 or later.
	 *
	 * Where a wl_pointer.axis_source event occurs in the same
	 * wl_pointer.frame, the axis source applies to this event.
	 *
	 * The order of wl_pointer.axis_value120 and wl_pointer.axis_source
	 * is not guaranteed.
	 * @param axis axis type
	 * @param value120 scroll distance as fraction of 120
	 * @since 8
	 */
	void (*axis_value120)(void *data,
			      struct wl_pointer *wl_pointer,
			      uint32_t axis,
			      int32_t value120);
	/**
	 * axis relative physical direction event
	 *
	 * Relative directional information of the entity causing the
	 * axis motion.
	 *
	 * For a wl_pointer.axis event, the
	 * wl_pointer.axis_relative_direction event specifies the movement
	 * direction of the entity causing the wl_pointer.axis event. For
	 * example: - if a user's fingers on a touchpad move down and this
	 * causes a wl_pointer.axis vertical_scroll down event, the
	 * physical direction is 'identical' - if a user's fingers on a
	 * touchpad move down and this causes a wl_pointer.axis
	 * vertical_scroll up scroll up event ('natural scrolling'), the
	 * physical direction is 'inverted'.
	 *
	 * A client may use this information to adjust scroll motion of
	 * components. Specifically, enabling natural scrolling causes the
	 * content to change direction compared to traditional scrolling.
	 * Some widgets like volume control sliders should usually match
	 * the physical direction regardless of whether natural scrolling
	 * is active. This event enables clients to match the scroll
	 * direction of a widget to the physical direction.
	 *
	 * This event does not occur on its own, it is coupled with a
	 * wl_pointer.axis event that represents this axis value. The
	 * protocol guarantees that each axis_relative_direction event is
	 * always followed by exactly one axis event with the same axis
	 * number within the same wl_pointer.frame. Note that the protocol
	 * allows for other events to occur between the
	 * axis_relative_direction and its coupled axis event.
	 *
	 * The axis number is identical to the axis number in the
	 * associated axis event.
	 *
	 * The order of wl_pointer.axis_relative_direction,
	 * wl_pointer.axis_discrete and wl_pointer.axis_source is not
	 * guaranteed.
	 * @param axis axis type
	 * @param direction physical direction relative to axis motion
	 * @since 9
	 */
	void (*axis_relative_direction)(void *data,
					struct wl_pointer *wl_pointer,
					uint32_t axis,
					uint32_t direction);
};

/**
 * @ingroup iface_wl_pointer
 */
static inline int
wl_pointer_add_listener(struct wl_pointer *wl_pointer,
			const struct wl_pointer_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_pointer,
				     (void (**)(void)) listener, data);
}

#define WL_POINTER_SET_CURSOR 0
#define WL_POINTER_RELEASE 1

/**
 * @ingroup iface_wl_pointer
 */
#define WL_POINTER_ENTER_SINCE_VERSION 1
/**
 * @ingroup iface_wl_pointer
 */
#define WL_POINTER_LEAVE_SINCE_VERSION 1
/**
 * @ingroup iface_wl_pointer
 */
#define WL_POINTER_MOTION_SINCE_VERSION 1
/**
 * @ingroup iface_wl_pointer
 */
#define WL_POINTER_BUTTON_SINCE_VERSION 1
/**
 * @ingroup iface_wl_pointer
 */
#define WL_POINTER_AXIS_SINCE_VERSION 1
/**
 * @ingroup iface_wl_pointer
 */
#define WL_POINTER_FRAME_SINCE_VERSION 5
/**
 * @ingroup iface_wl_pointer
 */
#define WL_POINTER_AXIS_SOURCE_SINCE_VERSION 5
/**
 * @ingroup iface_wl_pointer
 */
#define WL_POINTER_AXIS_STOP_SINCE_VERSION 5
/**
 * @ingroup iface_wl_pointer
 */
#define WL_POINTER_AXIS_DISCRETE_SINCE_VERSION 5
/**
 * @ingroup iface_wl_pointer
 */
#define WL_POINTER_AXIS_VALUE120_SINCE_VERSION 8
/**
 * @ingroup iface_wl_pointer
 */
#define WL_POINTER_AXIS_RELATIVE_DIRECTION_SINCE_VERSION 9

/**
 * @ingroup iface_wl_pointer
 */
#define WL_POINTER_SET_CURSOR_SINCE_VERSION 1
/**
 * @ingroup iface_wl_pointer
 */
#define WL_POINTER_RELEASE_SINCE_VERSION 3

/** @ingroup iface_wl_pointer */
static inline void
wl_pointer_set_user_data(struct wl_pointer *wl_pointer, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_pointer, user_data);
}

/** @ingroup iface_wl_pointer */
static inline void *
wl_pointer_get_user_data(struct wl_pointer *wl_pointer)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_pointer);
}

static inline uint32_t
wl_pointer_get_version(struct wl_pointer *wl_pointer)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_pointer);
}

/** @ingroup iface_wl_pointer */
static inline void
wl_pointer_destroy(struct wl_pointer *wl_pointer)
{
	wl_proxy_destroy((struct wl_proxy *) wl_pointer);
}

/**
 * @ingroup iface_wl_pointer
 *
 * Set the pointer surface, i.e., the surface that contains the
 * pointer image (cursor). This request gives the surface the role
 * of a cursor. If the surface already has another role, it raises
 * a protocol error.
 *
 * The cursor actually changes only if the pointer
 * focus for this device is one of the requesting client's surfaces
 * or the surface parameter is the current pointer surface. If
 * there was a previous surface set with this request it is
 * replaced. If surface is NULL, the pointer image is hidden.
 *
 * The parameters hotspot_x and hotspot_y define the position of
 * the pointer surface relative to the pointer location. Its
 * top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
 * where (x, y) are the coordinates of the pointer location, in
 * surface-local coordinates.
 *
 * On wl_surface.offset requests to the pointer surface, hotspot_x
 * and hotspot_y are decremented by the x and y parameters
 * passed to the request. The offset must be applied by
 * wl_surface.commit as usual.
 *
 * The hotspot can also be updated by passing the currently set
 * pointer surface to this request with new values for hotspot_x
 * and hotspot_y.
 *
 * The input region is ignored for wl_surfaces with the role of
 * a cursor. When the use as a cursor ends, the wl_surface is
 * unmapped.
 *
 * The serial parameter must match the latest wl_pointer.enter
 * serial number sent to the client. Otherwise the request will be
 * ignored.
 */
static inline void
wl_pointer_set_cursor(struct wl_pointer *wl_pointer, uint32_t serial, struct wl_surface *surface, int32_t hotspot_x, int32_t hotspot_y)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_pointer,
			 WL_POINTER_SET_CURSOR, NULL, wl_proxy_get_version((struct wl_proxy *) wl_pointer), 0, serial, surface, hotspot_x, hotspot_y);
}

/**
 * @ingroup iface_wl_pointer
 *
 * Using this request a client can tell the server that it is not going to
 * use the pointer object anymore.
 *
 * This request destroys the pointer proxy object, so clients must not call
 * wl_pointer_destroy() after using this request.
 */
static inline void
wl_pointer_release(struct wl_pointer *wl_pointer)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_pointer,
			 WL_POINTER_RELEASE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_pointer), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef WL_KEYBOARD_KEYMAP_FORMAT_ENUM
#define WL_KEYBOARD_KEYMAP_FORMAT_ENUM
/**
 * @ingroup iface_wl_keyboard
 * keyboard mapping format
 *
 * This specifies the format of the keymap provided to the
 * client with the wl_keyboard.keymap event.
 */
enum wl_keyboard_keymap_format {
	/**
	 * no keymap; client must understand how to interpret the raw keycode
	 */
	WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP = 0,
	/**
	 * libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode
	 */
	WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1 = 1,
};
#endif /* WL_KEYBOARD_KEYMAP_FORMAT_ENUM */

#ifndef WL_KEYBOARD_KEY_STATE_ENUM
#define WL_KEYBOARD_KEY_STATE_ENUM
/**
 * @ingroup iface_wl_keyboard
 * physical key state
 *
 * Describes the physical state of a key that produced the key event.
 */
enum wl_keyboard_key_state {
	/**
	 * key is not pressed
	 */
	WL_KEYBOARD_KEY_STATE_RELEASED = 0,
	/**
	 * key is pressed
	 */
	WL_KEYBOARD_KEY_STATE_PRESSED = 1,
};
#endif /* WL_KEYBOARD_KEY_STATE_ENUM */

/**
 * @ingroup iface_wl_keyboard
 * @struct wl_keyboard_listener
 */
struct wl_keyboard_listener {
	/**
	 * keyboard mapping
	 *
	 * This event provides a file descriptor to the client which can
	 * be memory-mapped in read-only mode to provide a keyboard mapping
	 * description.
	 *
	 * From version 7 onwards, the fd must be mapped with MAP_PRIVATE
	 * by the recipient, as MAP_SHARED may fail.
	 * @param format keymap format
	 * @param fd keymap file descriptor
	 * @param size keymap size, in bytes
	 */
	void (*keymap)(void *data,
		       struct wl_keyboard *wl_keyboard,
		       uint32_t format,
		       int32_t fd,
		       uint32_t size);
	/**
	 * enter event
	 *
	 * Notification that this seat's keyboard focus is on a certain
	 * surface.
	 *
	 * The compositor must send the wl_keyboard.modifiers event after
	 * this event.
	 *
	 * In the wl_keyboard logical state, this event sets the active
	 * surface to the surface argument and the keys currently logically
	 * down to the keys in the keys argument. The compositor must not
	 * send this event if the wl_keyboard already had an active surface
	 * immediately before this event.
	 * @param serial serial number of the enter event
	 * @param surface surface gaining keyboard focus
	 * @param keys the keys currently logically down
	 */
	void (*enter)(void *data,
		      struct wl_keyboard *wl_keyboard,
		      uint32_t serial,
		      struct wl_surface *surface,
		      struct wl_array *keys);
	/**
	 * leave event
	 *
	 * Notification that this seat's keyboard focus is no longer on a
	 * certain surface.
	 *
	 * The leave notification is sent before the enter notification for
	 * the new focus.
	 *
	 * In the wl_keyboard logical state, this event resets all values
	 * to their defaults. The compositor must not send this event if
	 * the active surface of the wl_keyboard was not equal to the
	 * surface argument immediately before this event.
	 * @param serial serial number of the leave event
	 * @param surface surface that lost keyboard focus
	 */
	void (*leave)(void *data,
		      struct wl_keyboard *wl_keyboard,
		      uint32_t serial,
		      struct wl_surface *surface);
	/**
	 * key event
	 *
	 * A key was pressed or released. The time argument is a
	 * timestamp with millisecond granularity, with an undefined base.
	 *
	 * The key is a platform-specific key code that can be interpreted
	 * by feeding it to the keyboard mapping (see the keymap event).
	 *
	 * If this event produces a change in modifiers, then the resulting
	 * wl_keyboard.modifiers event must be sent after this event.
	 *
	 * In the wl_keyboard logical state, this event adds the key to the
	 * keys currently logically down (if the state argument is pressed)
	 * or removes the key from the keys currently logically down (if
	 * the state argument is released). The compositor must not send
	 * this event if the wl_keyboard did not have an active surface
	 * immediately before this event. The compositor must not send this
	 * event if state is pressed (resp. released) and the key was
	 * already logically down (resp. was not logically down)
	 * immediately before this event.
	 * @param serial serial number of the key event
	 * @param time timestamp with millisecond granularity
	 * @param key key that produced the event
	 * @param state physical state of the key
	 */
	void (*key)(void *data,
		    struct wl_keyboard *wl_keyboard,
		    uint32_t serial,
		    uint32_t time,
		    uint32_t key,
		    uint32_t state);
	/**
	 * modifier and group state
	 *
	 * Notifies clients that the modifier and/or group state has
	 * changed, and it should update its local state.
	 *
	 * The compositor may send this event without a surface of the
	 * client having keyboard focus, for example to tie modifier
	 * information to pointer focus instead. If a modifier event with
	 * pressed modifiers is sent without a prior enter event, the
	 * client can assume the modifier state is valid until it receives
	 * the next wl_keyboard.modifiers event. In order to reset the
	 * modifier state again, the compositor can send a
	 * wl_keyboard.modifiers event with no pressed modifiers.
	 *
	 * In the wl_keyboard logical state, this event updates the
	 * modifiers and group.
	 * @param serial serial number of the modifiers event
	 * @param mods_depressed depressed modifiers
	 * @param mods_latched latched modifiers
	 * @param mods_locked locked modifiers
	 * @param group keyboard layout
	 */
	void (*modifiers)(void *data,
			  struct wl_keyboard *wl_keyboard,
			  uint32_t serial,
			  uint32_t mods_depressed,
			  uint32_t mods_latched,
			  uint32_t mods_locked,
			  uint32_t group);
	/**
	 * repeat rate and delay
	 *
	 * Informs the client about the keyboard's repeat rate and delay.
	 *
	 * This event is sent as soon as the wl_keyboard object has been
	 * created, and is guaranteed to be received by the client before
	 * any key press event.
	 *
	 * Negative values for either rate or delay are illegal. A rate of
	 * zero will disable any repeating (regardless of the value of
	 * delay).
	 *
	 * This event can be sent later on as well with a new value if
	 * necessary, so clients should continue listening for the event
	 * past the creation of wl_keyboard.
	 * @param rate the rate of repeating keys in characters per second
	 * @param delay delay in milliseconds since key down until repeating starts
	 * @since 4
	 */
	void (*repeat_info)(void *data,
			    struct wl_keyboard *wl_keyboard,
			    int32_t rate,
			    int32_t delay);
};

/**
 * @ingroup iface_wl_keyboard
 */
static inline int
wl_keyboard_add_listener(struct wl_keyboard *wl_keyboard,
			 const struct wl_keyboard_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_keyboard,
				     (void (**)(void)) listener, data);
}

#define WL_KEYBOARD_RELEASE 0

/**
 * @ingroup iface_wl_keyboard
 */
#define WL_KEYBOARD_KEYMAP_SINCE_VERSION 1
/**
 * @ingroup iface_wl_keyboard
 */
#define WL_KEYBOARD_ENTER_SINCE_VERSION 1
/**
 * @ingroup iface_wl_keyboard
 */
#define WL_KEYBOARD_LEAVE_SINCE_VERSION 1
/**
 * @ingroup iface_wl_keyboard
 */
#define WL_KEYBOARD_KEY_SINCE_VERSION 1
/**
 * @ingroup iface_wl_keyboard
 */
#define WL_KEYBOARD_MODIFIERS_SINCE_VERSION 1
/**
 * @ingroup iface_wl_keyboard
 */
#define WL_KEYBOARD_REPEAT_INFO_SINCE_VERSION 4

/**
 * @ingroup iface_wl_keyboard
 */
#define WL_KEYBOARD_RELEASE_SINCE_VERSION 3

/** @ingroup iface_wl_keyboard */
static inline void
wl_keyboard_set_user_data(struct wl_keyboard *wl_keyboard, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_keyboard, user_data);
}

/** @ingroup iface_wl_keyboard */
static inline void *
wl_keyboard_get_user_data(struct wl_keyboard *wl_keyboard)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_keyboard);
}

static inline uint32_t
wl_keyboard_get_version(struct wl_keyboard *wl_keyboard)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_keyboard);
}

/** @ingroup iface_wl_keyboard */
static inline void
wl_keyboard_destroy(struct wl_keyboard *wl_keyboard)
{
	wl_proxy_destroy((struct wl_proxy *) wl_keyboard);
}

/**
 * @ingroup iface_wl_keyboard
 */
static inline void
wl_keyboard_release(struct wl_keyboard *wl_keyboard)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_keyboard,
			 WL_KEYBOARD_RELEASE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_keyboard), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_wl_touch
 * @struct wl_touch_listener
 */
struct wl_touch_listener {
	/**
	 * touch down event and beginning of a touch sequence
	 *
	 * A new touch point has appeared on the surface. This touch
	 * point is assigned a unique ID. Future events from this touch
	 * point reference this ID. The ID ceases to be valid after a touch
	 * up event and may be reused in the future.
	 * @param serial serial number of the touch down event
	 * @param time timestamp with millisecond granularity
	 * @param surface surface touched
	 * @param id the unique ID of this touch point
	 * @param x surface-local x coordinate
	 * @param y surface-local y coordinate
	 */
	void (*down)(void *data,
		     struct wl_touch *wl_touch,
		     uint32_t serial,
		     uint32_t time,
		     struct wl_surface *surface,
		     int32_t id,
		     wl_fixed_t x,
		     wl_fixed_t y);
	/**
	 * end of a touch event sequence
	 *
	 * The touch point has disappeared. No further events will be
	 * sent for this touch point and the touch point's ID is released
	 * and may be reused in a future touch down event.
	 * @param serial serial number of the touch up event
	 * @param time timestamp with millisecond granularity
	 * @param id the unique ID of this touch point
	 */
	void (*up)(void *data,
		   struct wl_touch *wl_touch,
		   uint32_t serial,
		   uint32_t time,
		   int32_t id);
	/**
	 * update of touch point coordinates
	 *
	 * A touch point has changed coordinates.
	 * @param time timestamp with millisecond granularity
	 * @param id the unique ID of this touch point
	 * @param x surface-local x coordinate
	 * @param y surface-local y coordinate
	 */
	void (*motion)(void *data,
		       struct wl_touch *wl_touch,
		       uint32_t time,
		       int32_t id,
		       wl_fixed_t x,
		       wl_fixed_t y);
	/**
	 * end of touch frame event
	 *
	 * Indicates the end of a set of events that logically belong
	 * together. A client is expected to accumulate the data in all
	 * events within the frame before proceeding.
	 *
	 * A wl_touch.frame terminates at least one event but otherwise no
	 * guarantee is provided about the set of events within a frame. A
	 * client must assume that any state not updated in a frame is
	 * unchanged from the previously known state.
	 */
	void (*frame)(void *data,
		      struct wl_touch *wl_touch);
	/**
	 * touch session cancelled
	 *
	 * Sent if the compositor decides the touch stream is a global
	 * gesture. No further events are sent to the clients from that
	 * particular gesture. Touch cancellation applies to all touch
	 * points currently active on this client's surface. The client is
	 * responsible for finalizing the touch points, future touch points
	 * on this surface may reuse the touch point ID.
	 *
	 * No frame event is required after the cancel event.
	 */
	void (*cancel)(void *data,
		       struct wl_touch *wl_touch);
	/**
	 * update shape of touch point
	 *
	 * Sent when a touchpoint has changed its shape.
	 *
	 * This event does not occur on its own. It is sent before a
	 * wl_touch.frame event and carries the new shape information for
	 * any previously reported, or new touch points of that frame.
	 *
	 * Other events describing the touch point such as wl_touch.down,
	 * wl_touch.motion or wl_touch.orientation may be sent within the
	 * same wl_touch.frame. A client should treat these events as a
	 * single logical touch point update. The order of wl_touch.shape,
	 * wl_touch.orientation and wl_touch.motion is not guaranteed. A
	 * wl_touch.down event is guaranteed to occur before the first
	 * wl_touch.shape event for this touch ID but both events may occur
	 * within the same wl_touch.frame.
	 *
	 * A touchpoint shape is approximated by an ellipse through the
	 * major and minor axis length. The major axis length describes the
	 * longer diameter of the ellipse, while the minor axis length
	 * describes the shorter diameter. Major and minor are orthogonal
	 * and both are specified in surface-local coordinates. The center
	 * of the ellipse is always at the touchpoint location as reported
	 * by wl_touch.down or wl_touch.move.
	 *
	 * This event is only sent by the compositor if the touch device
	 * supports shape reports. The client has to make reasonable
	 * assumptions about the shape if it did not receive this event.
	 * @param id the unique ID of this touch point
	 * @param major length of the major axis in surface-local coordinates
	 * @param minor length of the minor axis in surface-local coordinates
	 * @since 6
	 */
	void (*shape)(void *data,
		      struct wl_touch *wl_touch,
		      int32_t id,
		      wl_fixed_t major,
		      wl_fixed_t minor);
	/**
	 * update orientation of touch point
	 *
	 * Sent when a touchpoint has changed its orientation.
	 *
	 * This event does not occur on its own. It is sent before a
	 * wl_touch.frame event and carries the new shape information for
	 * any previously reported, or new touch points of that frame.
	 *
	 * Other events describing the touch point such as wl_touch.down,
	 * wl_touch.motion or wl_touch.shape may be sent within the same
	 * wl_touch.frame. A client should treat these events as a single
	 * logical touch point update. The order of wl_touch.shape,
	 * wl_touch.orientation and wl_touch.motion is not guaranteed. A
	 * wl_touch.down event is guaranteed to occur before the first
	 * wl_touch.orientation event for this touch ID but both events may
	 * occur within the same wl_touch.frame.
	 *
	 * The orientation describes the clockwise angle of a touchpoint's
	 * major axis to the positive surface y-axis and is normalized to
	 * the -180 to +180 degree range. The granularity of orientation
	 * depends on the touch device, some devices only support binary
	 * rotation values between 0 and 90 degrees.
	 *
	 * This event is only sent by the compositor if the touch device
	 * supports orientation reports.
	 * @param id the unique ID of this touch point
	 * @param orientation angle between major axis and positive surface y-axis in degrees
	 * @since 6
	 */
	void (*orientation)(void *data,
			    struct wl_touch *wl_touch,
			    int32_t id,
			    wl_fixed_t orientation);
};

/**
 * @ingroup iface_wl_touch
 */
static inline int
wl_touch_add_listener(struct wl_touch *wl_touch,
		      const struct wl_touch_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_touch,
				     (void (**)(void)) listener, data);
}

#define WL_TOUCH_RELEASE 0

/**
 * @ingroup iface_wl_touch
 */
#define WL_TOUCH_DOWN_SINCE_VERSION 1
/**
 * @ingroup iface_wl_touch
 */
#define WL_TOUCH_UP_SINCE_VERSION 1
/**
 * @ingroup iface_wl_touch
 */
#define WL_TOUCH_MOTION_SINCE_VERSION 1
/**
 * @ingroup iface_wl_touch
 */
#define WL_TOUCH_FRAME_SINCE_VERSION 1
/**
 * @ingroup iface_wl_touch
 */
#define WL_TOUCH_CANCEL_SINCE_VERSION 1
/**
 * @ingroup iface_wl_touch
 */
#define WL_TOUCH_SHAPE_SINCE_VERSION 6
/**
 * @ingroup iface_wl_touch
 */
#define WL_TOUCH_ORIENTATION_SINCE_VERSION 6

/**
 * @ingroup iface_wl_touch
 */
#define WL_TOUCH_RELEASE_SINCE_VERSION 3

/** @ingroup iface_wl_touch */
static inline void
wl_touch_set_user_data(struct wl_touch *wl_touch, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_touch, user_data);
}

/** @ingroup iface_wl_touch */
static inline void *
wl_touch_get_user_data(struct wl_touch *wl_touch)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_touch);
}

static inline uint32_t
wl_touch_get_version(struct wl_touch *wl_touch)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_touch);
}

/** @ingroup iface_wl_touch */
static inline void
wl_touch_destroy(struct wl_touch *wl_touch)
{
	wl_proxy_destroy((struct wl_proxy *) wl_touch);
}

/**
 * @ingroup iface_wl_touch
 */
static inline void
wl_touch_release(struct wl_touch *wl_touch)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_touch,
			 WL_TOUCH_RELEASE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_touch), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef WL_OUTPUT_SUBPIXEL_ENUM
#define WL_OUTPUT_SUBPIXEL_ENUM
/**
 * @ingroup iface_wl_output
 * subpixel geometry information
 *
 * This enumeration describes how the physical
 * pixels on an output are laid out.
 */
enum wl_output_subpixel {
	/**
	 * unknown geometry
	 */
	WL_OUTPUT_SUBPIXEL_UNKNOWN = 0,
	/**
	 * no geometry
	 */
	WL_OUTPUT_SUBPIXEL_NONE = 1,
	/**
	 * horizontal RGB
	 */
	WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB = 2,
	/**
	 * horizontal BGR
	 */
	WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR = 3,
	/**
	 * vertical RGB
	 */
	WL_OUTPUT_SUBPIXEL_VERTICAL_RGB = 4,
	/**
	 * vertical BGR
	 */
	WL_OUTPUT_SUBPIXEL_VERTICAL_BGR = 5,
};
#endif /* WL_OUTPUT_SUBPIXEL_ENUM */

#ifndef WL_OUTPUT_TRANSFORM_ENUM
#define WL_OUTPUT_TRANSFORM_ENUM
/**
 * @ingroup iface_wl_output
 * transformation applied to buffer contents
 *
 * This describes transformations that clients and compositors apply to
 * buffer contents.
 *
 * The flipped values correspond to an initial flip around a
 * vertical axis followed by rotation.
 *
 * The purpose is mainly to allow clients to render accordingly and
 * tell the compositor, so that for fullscreen surfaces, the
 * compositor will still be able to scan out directly from client
 * surfaces.
 */
enum wl_output_transform {
	/**
	 * no transform
	 */
	WL_OUTPUT_TRANSFORM_NORMAL = 0,
	/**
	 * 90 degrees counter-clockwise
	 */
	WL_OUTPUT_TRANSFORM_90 = 1,
	/**
	 * 180 degrees counter-clockwise
	 */
	WL_OUTPUT_TRANSFORM_180 = 2,
	/**
	 * 270 degrees counter-clockwise
	 */
	WL_OUTPUT_TRANSFORM_270 = 3,
	/**
	 * 180 degree flip around a vertical axis
	 */
	WL_OUTPUT_TRANSFORM_FLIPPED = 4,
	/**
	 * flip and rotate 90 degrees counter-clockwise
	 */
	WL_OUTPUT_TRANSFORM_FLIPPED_90 = 5,
	/**
	 * flip and rotate 180 degrees counter-clockwise
	 */
	WL_OUTPUT_TRANSFORM_FLIPPED_180 = 6,
	/**
	 * flip and rotate 270 degrees counter-clockwise
	 */
	WL_OUTPUT_TRANSFORM_FLIPPED_270 = 7,
};
#endif /* WL_OUTPUT_TRANSFORM_ENUM */

#ifndef WL_OUTPUT_MODE_ENUM
#define WL_OUTPUT_MODE_ENUM
/**
 * @ingroup iface_wl_output
 * mode information
 *
 * These flags describe properties of an output mode.
 * They are used in the flags bitfield of the mode event.
 */
enum wl_output_mode {
	/**
	 * indicates this is the current mode
	 */
	WL_OUTPUT_MODE_CURRENT = 0x1,
	/**
	 * indicates this is the preferred mode
	 */
	WL_OUTPUT_MODE_PREFERRED = 0x2,
};
#endif /* WL_OUTPUT_MODE_ENUM */

/**
 * @ingroup iface_wl_output
 * @struct wl_output_listener
 */
struct wl_output_listener {
	/**
	 * properties of the output
	 *
	 * The geometry event describes geometric properties of the
	 * output. The event is sent when binding to the output object and
	 * whenever any of the properties change.
	 *
	 * The physical size can be set to zero if it doesn't make sense
	 * for this output (e.g. for projectors or virtual outputs).
	 *
	 * The geometry event will be followed by a done event (starting
	 * from version 2).
	 *
	 * Clients should use wl_surface.preferred_buffer_transform instead
	 * of the transform advertised by this event to find the preferred
	 * buffer transform to use for a surface.
	 *
	 * Note: wl_output only advertises partial information about the
	 * output position and identification. Some compositors, for
	 * instance those not implementing a desktop-style output layout or
	 * those exposing virtual outputs, might fake this information.
	 * Instead of using x and y, clients should use
	 * xdg_output.logical_position. Instead of using make and model,
	 * clients should use name and description.
	 * @param x x position within the global compositor space
	 * @param y y position within the global compositor space
	 * @param physical_width width in millimeters of the output
	 * @param physical_height height in millimeters of the output
	 * @param subpixel subpixel orientation of the output
	 * @param make textual description of the manufacturer
	 * @param model textual description of the model
	 * @param transform additional transformation applied to buffer contents during presentation
	 */
	void (*geometry)(void *data,
			 struct wl_output *wl_output,
			 int32_t x,
			 int32_t y,
			 int32_t physical_width,
			 int32_t physical_height,
			 int32_t subpixel,
			 const char *make,
			 const char *model,
			 int32_t transform);
	/**
	 * advertise available modes for the output
	 *
	 * The mode event describes an available mode for the output.
	 *
	 * The event is sent when binding to the output object and there
	 * will always be one mode, the current mode. The event is sent
	 * again if an output changes mode, for the mode that is now
	 * current. In other words, the current mode is always the last
	 * mode that was received with the current flag set.
	 *
	 * Non-current modes are deprecated. A compositor can decide to
	 * only advertise the current mode and never send other modes.
	 * Clients should not rely on non-current modes.
	 *
	 * The size of a mode is given in physical hardware units of the
	 * output device. This is not necessarily the same as the output
	 * size in the global compositor space. For instance, the output
	 * may be scaled, as described in wl_output.scale, or transformed,
	 * as described in wl_output.transform. Clients willing to retrieve
	 * the output size in the global compositor space should use
	 * xdg_output.logical_size instead.
	 *
	 * The vertical refresh rate can be set to zero if it doesn't make
	 * sense for this output (e.g. for virtual outputs).
	 *
	 * The mode event will be followed by a done event (starting from
	 * version 2).
	 *
	 * Clients should not use the refresh rate to schedule frames.
	 * Instead, they should use the wl_surface.frame event or the
	 * presentation-time protocol.
	 *
	 * Note: this information is not always meaningful for all outputs.
	 * Some compositors, such as those exposing virtual outputs, might
	 * fake the refresh rate or the size.
	 * @param flags bitfield of mode flags
	 * @param width width of the mode in hardware units
	 * @param height height of the mode in hardware units
	 * @param refresh vertical refresh rate in mHz
	 */
	void (*mode)(void *data,
		     struct wl_output *wl_output,
		     uint32_t flags,
		     int32_t width,
		     int32_t height,
		     int32_t refresh);
	/**
	 * sent all information about output
	 *
	 * This event is sent after all other properties have been sent
	 * after binding to the output object and after any other property
	 * changes done after that. This allows changes to the output
	 * properties to be seen as atomic, even if they happen via
	 * multiple events.
	 * @since 2
	 */
	void (*done)(void *data,
		     struct wl_output *wl_output);
	/**
	 * output scaling properties
	 *
	 * This event contains scaling geometry information that is not
	 * in the geometry event. It may be sent after binding the output
	 * object or if the output scale changes later. The compositor will
	 * emit a non-zero, positive value for scale. If it is not sent,
	 * the client should assume a scale of 1.
	 *
	 * A scale larger than 1 means that the compositor will
	 * automatically scale surface buffers by this amount when
	 * rendering. This is used for very high resolution displays where
	 * applications rendering at the native resolution would be too
	 * small to be legible.
	 *
	 * Clients should use wl_surface.preferred_buffer_scale instead of
	 * this event to find the preferred buffer scale to use for a
	 * surface.
	 *
	 * The scale event will be followed by a done event.
	 * @param factor scaling factor of output
	 * @since 2
	 */
	void (*scale)(void *data,
		      struct wl_output *wl_output,
		      int32_t factor);
	/**
	 * name of this output
	 *
	 * Many compositors will assign user-friendly names to their
	 * outputs, show them to the user, allow the user to refer to an
	 * output, etc. The client may wish to know this name as well to
	 * offer the user similar behaviors.
	 *
	 * The name is a UTF-8 string with no convention defined for its
	 * contents. Each name is unique among all wl_output globals. The
	 * name is only guaranteed to be unique for the compositor
	 * instance.
	 *
	 * The same output name is used for all clients for a given
	 * wl_output global. Thus, the name can be shared across processes
	 * to refer to a specific wl_output global.
	 *
	 * The name is not guaranteed to be persistent across sessions,
	 * thus cannot be used to reliably identify an output in e.g.
	 * configuration files.
	 *
	 * Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc.
	 * However, do not assume that the name is a reflection of an
	 * underlying DRM connector, X11 connection, etc.
	 *
	 * The name event is sent after binding the output object. This
	 * event is only sent once per output object, and the name does not
	 * change over the lifetime of the wl_output global.
	 *
	 * Compositors may re-use the same output name if the wl_output
	 * global is destroyed and re-created later. Compositors should
	 * avoid re-using the same name if possible.
	 *
	 * The name event will be followed by a done event.
	 * @param name output name
	 * @since 4
	 */
	void (*name)(void *data,
		     struct wl_output *wl_output,
		     const char *name);
	/**
	 * human-readable description of this output
	 *
	 * Many compositors can produce human-readable descriptions of
	 * their outputs. The client may wish to know this description as
	 * well, e.g. for output selection purposes.
	 *
	 * The description is a UTF-8 string with no convention defined for
	 * its contents. The description is not guaranteed to be unique
	 * among all wl_output globals. Examples might include 'Foocorp 11"
	 * Display' or 'Virtual X11 output via :1'.
	 *
	 * The description event is sent after binding the output object
	 * and whenever the description changes. The description is
	 * optional, and may not be sent at all.
	 *
	 * The description event will be followed by a done event.
	 * @param description output description
	 * @since 4
	 */
	void (*description)(void *data,
			    struct wl_output *wl_output,
			    const char *description);
};

/**
 * @ingroup iface_wl_output
 */
static inline int
wl_output_add_listener(struct wl_output *wl_output,
		       const struct wl_output_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_output,
				     (void (**)(void)) listener, data);
}

#define WL_OUTPUT_RELEASE 0

/**
 * @ingroup iface_wl_output
 */
#define WL_OUTPUT_GEOMETRY_SINCE_VERSION 1
/**
 * @ingroup iface_wl_output
 */
#define WL_OUTPUT_MODE_SINCE_VERSION 1
/**
 * @ingroup iface_wl_output
 */
#define WL_OUTPUT_DONE_SINCE_VERSION 2
/**
 * @ingroup iface_wl_output
 */
#define WL_OUTPUT_SCALE_SINCE_VERSION 2
/**
 * @ingroup iface_wl_output
 */
#define WL_OUTPUT_NAME_SINCE_VERSION 4
/**
 * @ingroup iface_wl_output
 */
#define WL_OUTPUT_DESCRIPTION_SINCE_VERSION 4

/**
 * @ingroup iface_wl_output
 */
#define WL_OUTPUT_RELEASE_SINCE_VERSION 3

/** @ingroup iface_wl_output */
static inline void
wl_output_set_user_data(struct wl_output *wl_output, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_output, user_data);
}

/** @ingroup iface_wl_output */
static inline void *
wl_output_get_user_data(struct wl_output *wl_output)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_output);
}

static inline uint32_t
wl_output_get_version(struct wl_output *wl_output)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_output);
}

/** @ingroup iface_wl_output */
static inline void
wl_output_destroy(struct wl_output *wl_output)
{
	wl_proxy_destroy((struct wl_proxy *) wl_output);
}

/**
 * @ingroup iface_wl_output
 *
 * Using this request a client can tell the server that it is not going to
 * use the output object anymore.
 */
static inline void
wl_output_release(struct wl_output *wl_output)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_output,
			 WL_OUTPUT_RELEASE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_output), WL_MARSHAL_FLAG_DESTROY);
}

#define WL_REGION_DESTROY 0
#define WL_REGION_ADD 1
#define WL_REGION_SUBTRACT 2


/**
 * @ingroup iface_wl_region
 */
#define WL_REGION_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_wl_region
 */
#define WL_REGION_ADD_SINCE_VERSION 1
/**
 * @ingroup iface_wl_region
 */
#define WL_REGION_SUBTRACT_SINCE_VERSION 1

/** @ingroup iface_wl_region */
static inline void
wl_region_set_user_data(struct wl_region *wl_region, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_region, user_data);
}

/** @ingroup iface_wl_region */
static inline void *
wl_region_get_user_data(struct wl_region *wl_region)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_region);
}

static inline uint32_t
wl_region_get_version(struct wl_region *wl_region)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_region);
}

/**
 * @ingroup iface_wl_region
 *
 * Destroy the region.  This will invalidate the object ID.
 */
static inline void
wl_region_destroy(struct wl_region *wl_region)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_region,
			 WL_REGION_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) wl_region), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_wl_region
 *
 * Add the specified rectangle to the region.
 */
static inline void
wl_region_add(struct wl_region *wl_region, int32_t x, int32_t y, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_region,
			 WL_REGION_ADD, NULL, wl_proxy_get_version((struct wl_proxy *) wl_region), 0, x, y, width, height);
}

/**
 * @ingroup iface_wl_region
 *
 * Subtract the specified rectangle from the region.
 */
static inline void
wl_region_subtract(struct wl_region *wl_region, int32_t x, int32_t y, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_region,
			 WL_REGION_SUBTRACT, NULL, wl_proxy_get_version((struct wl_proxy *) wl_region), 0, x, y, width, height);
}

#ifndef WL_SUBCOMPOSITOR_ERROR_ENUM
#define WL_SUBCOMPOSITOR_ERROR_ENUM
enum wl_subcompositor_error {
	/**
	 * the to-be sub-surface is invalid
	 */
	WL_SUBCOMPOSITOR_ERROR_BAD_SURFACE = 0,
	/**
	 * the to-be sub-surface parent is invalid
	 */
	WL_SUBCOMPOSITOR_ERROR_BAD_PARENT = 1,
};
#endif /* WL_SUBCOMPOSITOR_ERROR_ENUM */

#define WL_SUBCOMPOSITOR_DESTROY 0
#define WL_SUBCOMPOSITOR_GET_SUBSURFACE 1


/**
 * @ingroup iface_wl_subcompositor
 */
#define WL_SUBCOMPOSITOR_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_wl_subcompositor
 */
#define WL_SUBCOMPOSITOR_GET_SUBSURFACE_SINCE_VERSION 1

/** @ingroup iface_wl_subcompositor */
static inline void
wl_subcompositor_set_user_data(struct wl_subcompositor *wl_subcompositor, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_subcompositor, user_data);
}

/** @ingroup iface_wl_subcompositor */
static inline void *
wl_subcompositor_get_user_data(struct wl_subcompositor *wl_subcompositor)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_subcompositor);
}

static inline uint32_t
wl_subcompositor_get_version(struct wl_subcompositor *wl_subcompositor)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_subcompositor);
}

/**
 * @ingroup iface_wl_subcompositor
 *
 * Informs the server that the client will not be using this
 * protocol object anymore. This does not affect any other
 * objects, wl_subsurface objects included.
 */
static inline void
wl_subcompositor_destroy(struct wl_subcompositor *wl_subcompositor)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_subcompositor,
			 WL_SUBCOMPOSITOR_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) wl_subcompositor), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_wl_subcompositor
 *
 * Create a sub-surface interface for the given surface, and
 * associate it with the given parent surface. This turns a
 * plain wl_surface into a sub-surface.
 *
 * The to-be sub-surface must not already have another role, and it
 * must not have an existing wl_subsurface object. Otherwise the
 * bad_surface protocol error is raised.
 *
 * Adding sub-surfaces to a parent is a double-buffered operation on the
 * parent (see wl_surface.commit). The effect of adding a sub-surface
 * becomes visible on the next time the state of the parent surface is
 * applied.
 *
 * The parent surface must not be one of the child surface's descendants,
 * and the parent must be different from the child surface, otherwise the
 * bad_parent protocol error is raised.
 *
 * This request modifies the behaviour of wl_surface.commit request on
 * the sub-surface, see the documentation on wl_subsurface interface.
 */
static inline struct wl_subsurface *
wl_subcompositor_get_subsurface(struct wl_subcompositor *wl_subcompositor, struct wl_surface *surface, struct wl_surface *parent)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) wl_subcompositor,
			 WL_SUBCOMPOSITOR_GET_SUBSURFACE, &wl_subsurface_interface, wl_proxy_get_version((struct wl_proxy *) wl_subcompositor), 0, NULL, surface, parent);

	return (struct wl_subsurface *) id;
}

#ifndef WL_SUBSURFACE_ERROR_ENUM
#define WL_SUBSURFACE_ERROR_ENUM
enum wl_subsurface_error {
	/**
	 * wl_surface is not a sibling or the parent
	 */
	WL_SUBSURFACE_ERROR_BAD_SURFACE = 0,
};
#endif /* WL_SUBSURFACE_ERROR_ENUM */

#define WL_SUBSURFACE_DESTROY 0
#define WL_SUBSURFACE_SET_POSITION 1
#define WL_SUBSURFACE_PLACE_ABOVE 2
#define WL_SUBSURFACE_PLACE_BELOW 3
#define WL_SUBSURFACE_SET_SYNC 4
#define WL_SUBSURFACE_SET_DESYNC 5


/**
 * @ingroup iface_wl_subsurface
 */
#define WL_SUBSURFACE_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_wl_subsurface
 */
#define WL_SUBSURFACE_SET_POSITION_SINCE_VERSION 1
/**
 * @ingroup iface_wl_subsurface
 */
#define WL_SUBSURFACE_PLACE_ABOVE_SINCE_VERSION 1
/**
 * @ingroup iface_wl_subsurface
 */
#define WL_SUBSURFACE_PLACE_BELOW_SINCE_VERSION 1
/**
 * @ingroup iface_wl_subsurface
 */
#define WL_SUBSURFACE_SET_SYNC_SINCE_VERSION 1
/**
 * @ingroup iface_wl_subsurface
 */
#define WL_SUBSURFACE_SET_DESYNC_SINCE_VERSION 1

/** @ingroup iface_wl_subsurface */
static inline void
wl_subsurface_set_user_data(struct wl_subsurface *wl_subsurface, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_subsurface, user_data);
}

/** @ingroup iface_wl_subsurface */
static inline void *
wl_subsurface_get_user_data(struct wl_subsurface *wl_subsurface)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_subsurface);
}

static inline uint32_t
wl_subsurface_get_version(struct wl_subsurface *wl_subsurface)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_subsurface);
}

/**
 * @ingroup iface_wl_subsurface
 *
 * The sub-surface interface is removed from the wl_surface object
 * that was turned into a sub-surface with a
 * wl_subcompositor.get_subsurface request. The wl_surface's association
 * to the parent is deleted. The wl_surface is unmapped immediately.
 */
static inline void
wl_subsurface_destroy(struct wl_subsurface *wl_subsurface)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_subsurface,
			 WL_SUBSURFACE_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) wl_subsurface), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_wl_subsurface
 *
 * This schedules a sub-surface position change.
 * The sub-surface will be moved so that its origin (top left
 * corner pixel) will be at the location x, y of the parent surface
 * coordinate system. The coordinates are not restricted to the parent
 * surface area. Negative values are allowed.
 *
 * The scheduled coordinates will take effect whenever the state of the
 * parent surface is applied.
 *
 * If more than one set_position request is invoked by the client before
 * the commit of the parent surface, the position of a new request always
 * replaces the scheduled position from any previous request.
 *
 * The initial position is 0, 0.
 */
static inline void
wl_subsurface_set_position(struct wl_subsurface *wl_subsurface, int32_t x, int32_t y)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_subsurface,
			 WL_SUBSURFACE_SET_POSITION, NULL, wl_proxy_get_version((struct wl_proxy *) wl_subsurface), 0, x, y);
}

/**
 * @ingroup iface_wl_subsurface
 *
 * This sub-surface is taken from the stack, and put back just
 * above the reference surface, changing the z-order of the sub-surfaces.
 * The reference surface must be one of the sibling surfaces, or the
 * parent surface. Using any other surface, including this sub-surface,
 * will cause a protocol error.
 *
 * The z-order is double-buffered. Requests are handled in order and
 * applied immediately to a pending state. The final pending state is
 * copied to the active state the next time the state of the parent
 * surface is applied.
 *
 * A new sub-surface is initially added as the top-most in the stack
 * of its siblings and parent.
 */
static inline void
wl_subsurface_place_above(struct wl_subsurface *wl_subsurface, struct wl_surface *sibling)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_subsurface,
			 WL_SUBSURFACE_PLACE_ABOVE, NULL, wl_proxy_get_version((struct wl_proxy *) wl_subsurface), 0, sibling);
}

/**
 * @ingroup iface_wl_subsurface
 *
 * The sub-surface is placed just below the reference surface.
 * See wl_subsurface.place_above.
 */
static inline void
wl_subsurface_place_below(struct wl_subsurface *wl_subsurface, struct wl_surface *sibling)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_subsurface,
			 WL_SUBSURFACE_PLACE_BELOW, NULL, wl_proxy_get_version((struct wl_proxy *) wl_subsurface), 0, sibling);
}

/**
 * @ingroup iface_wl_subsurface
 *
 * Change the commit behaviour of the sub-surface to synchronized
 * mode, also described as the parent dependent mode.
 *
 * In synchronized mode, wl_surface.commit on a sub-surface will
 * accumulate the committed state in a cache, but the state will
 * not be applied and hence will not change the compositor output.
 * The cached state is applied to the sub-surface immediately after
 * the parent surface's state is applied. This ensures atomic
 * updates of the parent and all its synchronized sub-surfaces.
 * Applying the cached state will invalidate the cache, so further
 * parent surface commits do not (re-)apply old state.
 *
 * See wl_subsurface for the recursive effect of this mode.
 */
static inline void
wl_subsurface_set_sync(struct wl_subsurface *wl_subsurface)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_subsurface,
			 WL_SUBSURFACE_SET_SYNC, NULL, wl_proxy_get_version((struct wl_proxy *) wl_subsurface), 0);
}

/**
 * @ingroup iface_wl_subsurface
 *
 * Change the commit behaviour of the sub-surface to desynchronized
 * mode, also described as independent or freely running mode.
 *
 * In desynchronized mode, wl_surface.commit on a sub-surface will
 * apply the pending state directly, without caching, as happens
 * normally with a wl_surface. Calling wl_surface.commit on the
 * parent surface has no effect on the sub-surface's wl_surface
 * state. This mode allows a sub-surface to be updated on its own.
 *
 * If cached state exists when wl_surface.commit is called in
 * desynchronized mode, the pending state is added to the cached
 * state, and applied as a whole. This invalidates the cache.
 *
 * Note: even if a sub-surface is set to desynchronized, a parent
 * sub-surface may override it to behave as synchronized. For details,
 * see wl_subsurface.
 *
 * If a surface's parent surface behaves as desynchronized, then
 * the cached state is applied on set_desync.
 */
static inline void
wl_subsurface_set_desync(struct wl_subsurface *wl_subsurface)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wl_subsurface,
			 WL_SUBSURFACE_SET_DESYNC, NULL, wl_proxy_get_version((struct wl_proxy *) wl_subsurface), 0);
}

#ifdef  __cplusplus
}
#endif

#endif

/* Generated by wayland-scanner 1.23.1 */

/*
 * Copyright © 2008-2011 Kristian Høgsberg
 * Copyright © 2010-2011 Intel Corporation
 * Copyright © 2012-2013 Collabora, Ltd.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

extern const struct wl_interface wl_buffer_interface;
extern const struct wl_interface wl_callback_interface;
extern const struct wl_interface wl_data_device_interface;
extern const struct wl_interface wl_data_offer_interface;
extern const struct wl_interface wl_data_source_interface;
extern const struct wl_interface wl_keyboard_interface;
extern const struct wl_interface wl_output_interface;
extern const struct wl_interface wl_pointer_interface;
extern const struct wl_interface wl_region_interface;
extern const struct wl_interface wl_registry_interface;
extern const struct wl_interface wl_seat_interface;
extern const struct wl_interface wl_shell_surface_interface;
extern const struct wl_interface wl_shm_pool_interface;
extern const struct wl_interface wl_subsurface_interface;
extern const struct wl_interface wl_surface_interface;
extern const struct wl_interface wl_touch_interface;

static const struct wl_interface *wayland_types[] = {
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	&wl_callback_interface,
	&wl_registry_interface,
	&wl_surface_interface,
	&wl_region_interface,
	&wl_buffer_interface,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	&wl_shm_pool_interface,
	NULL,
	NULL,
	&wl_data_source_interface,
	&wl_surface_interface,
	&wl_surface_interface,
	NULL,
	&wl_data_source_interface,
	NULL,
	&wl_data_offer_interface,
	NULL,
	&wl_surface_interface,
	NULL,
	NULL,
	&wl_data_offer_interface,
	&wl_data_offer_interface,
	&wl_data_source_interface,
	&wl_data_device_interface,
	&wl_seat_interface,
	&wl_shell_surface_interface,
	&wl_surface_interface,
	&wl_seat_interface,
	NULL,
	&wl_seat_interface,
	NULL,
	NULL,
	&wl_surface_interface,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	&wl_output_interface,
	&wl_seat_interface,
	NULL,
	&wl_surface_interface,
	NULL,
	NULL,
	NULL,
	&wl_output_interface,
	&wl_buffer_interface,
	NULL,
	NULL,
	&wl_callback_interface,
	&wl_region_interface,
	&wl_region_interface,
	&wl_output_interface,
	&wl_output_interface,
	&wl_pointer_interface,
	&wl_keyboard_interface,
	&wl_touch_interface,
	NULL,
	&wl_surface_interface,
	NULL,
	NULL,
	NULL,
	&wl_surface_interface,
	NULL,
	NULL,
	NULL,
	&wl_surface_interface,
	NULL,
	&wl_surface_interface,
	NULL,
	NULL,
	&wl_surface_interface,
	NULL,
	NULL,
	&wl_surface_interface,
	NULL,
	NULL,
	NULL,
	&wl_subsurface_interface,
	&wl_surface_interface,
	&wl_surface_interface,
	&wl_surface_interface,
	&wl_surface_interface,
};

static const struct wl_message wl_display_requests[] = {
	{ "sync", "n", wayland_types + 8 },
	{ "get_registry", "n", wayland_types + 9 },
};

static const struct wl_message wl_display_events[] = {
	{ "error", "ous", wayland_types + 0 },
	{ "delete_id", "u", wayland_types + 0 },
};

const struct wl_interface wl_display_interface = {
	"wl_display", 1,
	2, wl_display_requests,
	2, wl_display_events,
};

static const struct wl_message wl_registry_requests[] = {
	{ "bind", "usun", wayland_types + 0 },
};

static const struct wl_message wl_registry_events[] = {
	{ "global", "usu", wayland_types + 0 },
	{ "global_remove", "u", wayland_types + 0 },
};

const struct wl_interface wl_registry_interface = {
	"wl_registry", 1,
	1, wl_registry_requests,
	2, wl_registry_events,
};

static const struct wl_message wl_callback_events[] = {
	{ "done", "u", wayland_types + 0 },
};

const struct wl_interface wl_callback_interface = {
	"wl_callback", 1,
	0, NULL,
	1, wl_callback_events,
};

static const struct wl_message wl_compositor_requests[] = {
	{ "create_surface", "n", wayland_types + 10 },
	{ "create_region", "n", wayland_types + 11 },
};

const struct wl_interface wl_compositor_interface = {
	"wl_compositor", 6,
	2, wl_compositor_requests,
	0, NULL,
};

static const struct wl_message wl_shm_pool_requests[] = {
	{ "create_buffer", "niiiiu", wayland_types + 12 },
	{ "destroy", "", wayland_types + 0 },
	{ "resize", "i", wayland_types + 0 },
};

const struct wl_interface wl_shm_pool_interface = {
	"wl_shm_pool", 2,
	3, wl_shm_pool_requests,
	0, NULL,
};

static const struct wl_message wl_shm_requests[] = {
	{ "create_pool", "nhi", wayland_types + 18 },
	{ "release", "2", wayland_types + 0 },
};

static const struct wl_message wl_shm_events[] = {
	{ "format", "u", wayland_types + 0 },
};

const struct wl_interface wl_shm_interface = {
	"wl_shm", 2,
	2, wl_shm_requests,
	1, wl_shm_events,
};

static const struct wl_message wl_buffer_requests[] = {
	{ "destroy", "", wayland_types + 0 },
};

static const struct wl_message wl_buffer_events[] = {
	{ "release", "", wayland_types + 0 },
};

const struct wl_interface wl_buffer_interface = {
	"wl_buffer", 1,
	1, wl_buffer_requests,
	1, wl_buffer_events,
};

static const struct wl_message wl_data_offer_requests[] = {
	{ "accept", "u?s", wayland_types + 0 },
	{ "receive", "sh", wayland_types + 0 },
	{ "destroy", "", wayland_types + 0 },
	{ "finish", "3", wayland_types + 0 },
	{ "set_actions", "3uu", wayland_types + 0 },
};

static const struct wl_message wl_data_offer_events[] = {
	{ "offer", "s", wayland_types + 0 },
	{ "source_actions", "3u", wayland_types + 0 },
	{ "action", "3u", wayland_types + 0 },
};

const struct wl_interface wl_data_offer_interface = {
	"wl_data_offer", 3,
	5, wl_data_offer_requests,
	3, wl_data_offer_events,
};

static const struct wl_message wl_data_source_requests[] = {
	{ "offer", "s", wayland_types + 0 },
	{ "destroy", "", wayland_types + 0 },
	{ "set_actions", "3u", wayland_types + 0 },
};

static const struct wl_message wl_data_source_events[] = {
	{ "target", "?s", wayland_types + 0 },
	{ "send", "sh", wayland_types + 0 },
	{ "cancelled", "", wayland_types + 0 },
	{ "dnd_drop_performed", "3", wayland_types + 0 },
	{ "dnd_finished", "3", wayland_types + 0 },
	{ "action", "3u", wayland_types + 0 },
};

const struct wl_interface wl_data_source_interface = {
	"wl_data_source", 3,
	3, wl_data_source_requests,
	6, wl_data_source_events,
};

static const struct wl_message wl_data_device_requests[] = {
	{ "start_drag", "?oo?ou", wayland_types + 21 },
	{ "set_selection", "?ou", wayland_types + 25 },
	{ "release", "2", wayland_types + 0 },
};

static const struct wl_message wl_data_device_events[] = {
	{ "data_offer", "n", wayland_types + 27 },
	{ "enter", "uoff?o", wayland_types + 28 },
	{ "leave", "", wayland_types + 0 },
	{ "motion", "uff", wayland_types + 0 },
	{ "drop", "", wayland_types + 0 },
	{ "selection", "?o", wayland_types + 33 },
};

const struct wl_interface wl_data_device_interface = {
	"wl_data_device", 3,
	3, wl_data_device_requests,
	6, wl_data_device_events,
};

static const struct wl_message wl_data_device_manager_requests[] = {
	{ "create_data_source", "n", wayland_types + 34 },
	{ "get_data_device", "no", wayland_types + 35 },
};

const struct wl_interface wl_data_device_manager_interface = {
	"wl_data_device_manager", 3,
	2, wl_data_device_manager_requests,
	0, NULL,
};

static const struct wl_message wl_shell_requests[] = {
	{ "get_shell_surface", "no", wayland_types + 37 },
};

const struct wl_interface wl_shell_interface = {
	"wl_shell", 1,
	1, wl_shell_requests,
	0, NULL,
};

static const struct wl_message wl_shell_surface_requests[] = {
	{ "pong", "u", wayland_types + 0 },
	{ "move", "ou", wayland_types + 39 },
	{ "resize", "ouu", wayland_types + 41 },
	{ "set_toplevel", "", wayland_types + 0 },
	{ "set_transient", "oiiu", wayland_types + 44 },
	{ "set_fullscreen", "uu?o", wayland_types + 48 },
	{ "set_popup", "ouoiiu", wayland_types + 51 },
	{ "set_maximized", "?o", wayland_types + 57 },
	{ "set_title", "s", wayland_types + 0 },
	{ "set_class", "s", wayland_types + 0 },
};

static const struct wl_message wl_shell_surface_events[] = {
	{ "ping", "u", wayland_types + 0 },
	{ "configure", "uii", wayland_types + 0 },
	{ "popup_done", "", wayland_types + 0 },
};

const struct wl_interface wl_shell_surface_interface = {
	"wl_shell_surface", 1,
	10, wl_shell_surface_requests,
	3, wl_shell_surface_events,
};

static const struct wl_message wl_surface_requests[] = {
	{ "destroy", "", wayland_types + 0 },
	{ "attach", "?oii", wayland_types + 58 },
	{ "damage", "iiii", wayland_types + 0 },
	{ "frame", "n", wayland_types + 61 },
	{ "set_opaque_region", "?o", wayland_types + 62 },
	{ "set_input_region", "?o", wayland_types + 63 },
	{ "commit", "", wayland_types + 0 },
	{ "set_buffer_transform", "2i", wayland_types + 0 },
	{ "set_buffer_scale", "3i", wayland_types + 0 },
	{ "damage_buffer", "4iiii", wayland_types + 0 },
	{ "offset", "5ii", wayland_types + 0 },
};

static const struct wl_message wl_surface_events[] = {
	{ "enter", "o", wayland_types + 64 },
	{ "leave", "o", wayland_types + 65 },
	{ "preferred_buffer_scale", "6i", wayland_types + 0 },
	{ "preferred_buffer_transform", "6u", wayland_types + 0 },
};

const struct wl_interface wl_surface_interface = {
	"wl_surface", 6,
	11, wl_surface_requests,
	4, wl_surface_events,
};

static const struct wl_message wl_seat_requests[] = {
	{ "get_pointer", "n", wayland_types + 66 },
	{ "get_keyboard", "n", wayland_types + 67 },
	{ "get_touch", "n", wayland_types + 68 },
	{ "release", "5", wayland_types + 0 },
};

static const struct wl_message wl_seat_events[] = {
	{ "capabilities", "u", wayland_types + 0 },
	{ "name", "2s", wayland_types + 0 },
};

const struct wl_interface wl_seat_interface = {
	"wl_seat", 9,
	4, wl_seat_requests,
	2, wl_seat_events,
};

static const struct wl_message wl_pointer_requests[] = {
	{ "set_cursor", "u?oii", wayland_types + 69 },
	{ "release", "3", wayland_types + 0 },
};

static const struct wl_message wl_pointer_events[] = {
	{ "enter", "uoff", wayland_types + 73 },
	{ "leave", "uo", wayland_types + 77 },
	{ "motion", "uff", wayland_types + 0 },
	{ "button", "uuuu", wayland_types + 0 },
	{ "axis", "uuf", wayland_types + 0 },
	{ "frame", "5", wayland_types + 0 },
	{ "axis_source", "5u", wayland_types + 0 },
	{ "axis_stop", "5uu", wayland_types + 0 },
	{ "axis_discrete", "5ui", wayland_types + 0 },
	{ "axis_value120", "8ui", wayland_types + 0 },
	{ "axis_relative_direction", "9uu", wayland_types + 0 },
};

const struct wl_interface wl_pointer_interface = {
	"wl_pointer", 9,
	2, wl_pointer_requests,
	11, wl_pointer_events,
};

static const struct wl_message wl_keyboard_requests[] = {
	{ "release", "3", wayland_types + 0 },
};

static const struct wl_message wl_keyboard_events[] = {
	{ "keymap", "uhu", wayland_types + 0 },
	{ "enter", "uoa", wayland_types + 79 },
	{ "leave", "uo", wayland_types + 82 },
	{ "key", "uuuu", wayland_types + 0 },
	{ "modifiers", "uuuuu", wayland_types + 0 },
	{ "repeat_info", "4ii", wayland_types + 0 },
};

const struct wl_interface wl_keyboard_interface = {
	"wl_keyboard", 9,
	1, wl_keyboard_requests,
	6, wl_keyboard_events,
};

static const struct wl_message wl_touch_requests[] = {
	{ "release", "3", wayland_types + 0 },
};

static const struct wl_message wl_touch_events[] = {
	{ "down", "uuoiff", wayland_types + 84 },
	{ "up", "uui", wayland_types + 0 },
	{ "motion", "uiff", wayland_types + 0 },
	{ "frame", "", wayland_types + 0 },
	{ "cancel", "", wayland_types + 0 },
	{ "shape", "6iff", wayland_types + 0 },
	{ "orientation", "6if", wayland_types + 0 },
};

const struct wl_interface wl_touch_interface = {
	"wl_touch", 9,
	1, wl_touch_requests,
	7, wl_touch_events,
};

static const struct wl_message wl_output_requests[] = {
	{ "release", "3", wayland_types + 0 },
};

static const struct wl_message wl_output_events[] = {
	{ "geometry", "iiiiissi", wayland_types + 0 },
	{ "mode", "uiii", wayland_types + 0 },
	{ "done", "2", wayland_types + 0 },
	{ "scale", "2i", wayland_types + 0 },
	{ "name", "4s", wayland_types + 0 },
	{ "description", "4s", wayland_types + 0 },
};

const struct wl_interface wl_output_interface = {
	"wl_output", 4,
	1, wl_output_requests,
	6, wl_output_events,
};

static const struct wl_message wl_region_requests[] = {
	{ "destroy", "", wayland_types + 0 },
	{ "add", "iiii", wayland_types + 0 },
	{ "subtract", "iiii", wayland_types + 0 },
};

const struct wl_interface wl_region_interface = {
	"wl_region", 1,
	3, wl_region_requests,
	0, NULL,
};

static const struct wl_message wl_subcompositor_requests[] = {
	{ "destroy", "", wayland_types + 0 },
	{ "get_subsurface", "noo", wayland_types + 90 },
};

const struct wl_interface wl_subcompositor_interface = {
	"wl_subcompositor", 1,
	2, wl_subcompositor_requests,
	0, NULL,
};

static const struct wl_message wl_subsurface_requests[] = {
	{ "destroy", "", wayland_types + 0 },
	{ "set_position", "ii", wayland_types + 0 },
	{ "place_above", "o", wayland_types + 93 },
	{ "place_below", "o", wayland_types + 94 },
	{ "set_sync", "", wayland_types + 0 },
	{ "set_desync", "", wayland_types + 0 },
};

const struct wl_interface wl_subsurface_interface = {
	"wl_subsurface", 1,
	6, wl_subsurface_requests,
	0, NULL,
};
/* Generated by wayland-scanner 1.23.1 */

#ifndef XDG_OUTPUT_UNSTABLE_V1_CLIENT_PROTOCOL_H
#define XDG_OUTPUT_UNSTABLE_V1_CLIENT_PROTOCOL_H

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_xdg_output_unstable_v1 The xdg_output_unstable_v1 protocol
 * Protocol to describe output regions
 *
 * @section page_desc_xdg_output_unstable_v1 Description
 *
 * This protocol aims at describing outputs in a way which is more in line
 * with the concept of an output on desktop oriented systems.
 *
 * Some information are more specific to the concept of an output for
 * a desktop oriented system and may not make sense in other applications,
 * such as IVI systems for example.
 *
 * Typically, the global compositor space on a desktop system is made of
 * a contiguous or overlapping set of rectangular regions.
 *
 * The logical_position and logical_size events defined in this protocol
 * might provide information identical to their counterparts already
 * available from wl_output, in which case the information provided by this
 * protocol should be preferred to their equivalent in wl_output. The goal is
 * to move the desktop specific concepts (such as output location within the
 * global compositor space, etc.) out of the core wl_output protocol.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible
 * changes may be added together with the corresponding interface
 * version bump.
 * Backward incompatible changes are done by bumping the version
 * number in the protocol and interface names and resetting the
 * interface version. Once the protocol is to be declared stable,
 * the 'z' prefix and the version number in the protocol and
 * interface names are removed and the interface version number is
 * reset.
 *
 * @section page_ifaces_xdg_output_unstable_v1 Interfaces
 * - @subpage page_iface_zxdg_output_manager_v1 - manage xdg_output objects
 * - @subpage page_iface_zxdg_output_v1 - compositor logical output region
 * @section page_copyright_xdg_output_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2017 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct wl_output;
struct zxdg_output_manager_v1;
struct zxdg_output_v1;

#ifndef ZXDG_OUTPUT_MANAGER_V1_INTERFACE
#define ZXDG_OUTPUT_MANAGER_V1_INTERFACE
/**
 * @page page_iface_zxdg_output_manager_v1 zxdg_output_manager_v1
 * @section page_iface_zxdg_output_manager_v1_desc Description
 *
 * A global factory interface for xdg_output objects.
 * @section page_iface_zxdg_output_manager_v1_api API
 * See @ref iface_zxdg_output_manager_v1.
 */
/**
 * @defgroup iface_zxdg_output_manager_v1 The zxdg_output_manager_v1 interface
 *
 * A global factory interface for xdg_output objects.
 */
extern const struct wl_interface zxdg_output_manager_v1_interface;
#endif
#ifndef ZXDG_OUTPUT_V1_INTERFACE
#define ZXDG_OUTPUT_V1_INTERFACE
/**
 * @page page_iface_zxdg_output_v1 zxdg_output_v1
 * @section page_iface_zxdg_output_v1_desc Description
 *
 * An xdg_output describes part of the compositor geometry.
 *
 * This typically corresponds to a monitor that displays part of the
 * compositor space.
 *
 * For objects version 3 onwards, after all xdg_output properties have been
 * sent (when the object is created and when properties are updated), a
 * wl_output.done event is sent. This allows changes to the output
 * properties to be seen as atomic, even if they happen via multiple events.
 * @section page_iface_zxdg_output_v1_api API
 * See @ref iface_zxdg_output_v1.
 */
/**
 * @defgroup iface_zxdg_output_v1 The zxdg_output_v1 interface
 *
 * An xdg_output describes part of the compositor geometry.
 *
 * This typically corresponds to a monitor that displays part of the
 * compositor space.
 *
 * For objects version 3 onwards, after all xdg_output properties have been
 * sent (when the object is created and when properties are updated), a
 * wl_output.done event is sent. This allows changes to the output
 * properties to be seen as atomic, even if they happen via multiple events.
 */
extern const struct wl_interface zxdg_output_v1_interface;
#endif

#define ZXDG_OUTPUT_MANAGER_V1_DESTROY 0
#define ZXDG_OUTPUT_MANAGER_V1_GET_XDG_OUTPUT 1


/**
 * @ingroup iface_zxdg_output_manager_v1
 */
#define ZXDG_OUTPUT_MANAGER_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_zxdg_output_manager_v1
 */
#define ZXDG_OUTPUT_MANAGER_V1_GET_XDG_OUTPUT_SINCE_VERSION 1

/** @ingroup iface_zxdg_output_manager_v1 */
static inline void
zxdg_output_manager_v1_set_user_data(struct zxdg_output_manager_v1 *zxdg_output_manager_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zxdg_output_manager_v1, user_data);
}

/** @ingroup iface_zxdg_output_manager_v1 */
static inline void *
zxdg_output_manager_v1_get_user_data(struct zxdg_output_manager_v1 *zxdg_output_manager_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_output_manager_v1);
}

static inline uint32_t
zxdg_output_manager_v1_get_version(struct zxdg_output_manager_v1 *zxdg_output_manager_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zxdg_output_manager_v1);
}

/**
 * @ingroup iface_zxdg_output_manager_v1
 *
 * Using this request a client can tell the server that it is not
 * going to use the xdg_output_manager object anymore.
 *
 * Any objects already created through this instance are not affected.
 */
static inline void
zxdg_output_manager_v1_destroy(struct zxdg_output_manager_v1 *zxdg_output_manager_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zxdg_output_manager_v1,
			 ZXDG_OUTPUT_MANAGER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zxdg_output_manager_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_zxdg_output_manager_v1
 *
 * This creates a new xdg_output object for the given wl_output.
 */
static inline struct zxdg_output_v1 *
zxdg_output_manager_v1_get_xdg_output(struct zxdg_output_manager_v1 *zxdg_output_manager_v1, struct wl_output *output)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) zxdg_output_manager_v1,
			 ZXDG_OUTPUT_MANAGER_V1_GET_XDG_OUTPUT, &zxdg_output_v1_interface, wl_proxy_get_version((struct wl_proxy *) zxdg_output_manager_v1), 0, NULL, output);

	return (struct zxdg_output_v1 *) id;
}

/**
 * @ingroup iface_zxdg_output_v1
 * @struct zxdg_output_v1_listener
 */
struct zxdg_output_v1_listener {
	/**
	 * position of the output within the global compositor space
	 *
	 * The position event describes the location of the wl_output
	 * within the global compositor space.
	 *
	 * The logical_position event is sent after creating an xdg_output
	 * (see xdg_output_manager.get_xdg_output) and whenever the
	 * location of the output changes within the global compositor
	 * space.
	 * @param x x position within the global compositor space
	 * @param y y position within the global compositor space
	 */
	void (*logical_position)(void *data,
				 struct zxdg_output_v1 *zxdg_output_v1,
				 int32_t x,
				 int32_t y);
	/**
	 * size of the output in the global compositor space
	 *
	 * The logical_size event describes the size of the output in the
	 * global compositor space.
	 *
	 * Most regular Wayland clients should not pay attention to the
	 * logical size and would rather rely on xdg_shell interfaces.
	 *
	 * Some clients such as Xwayland, however, need this to configure
	 * their surfaces in the global compositor space as the compositor
	 * may apply a different scale from what is advertised by the
	 * output scaling property (to achieve fractional scaling, for
	 * example).
	 *
	 * For example, for a wl_output mode 3840×2160 and a scale factor
	 * 2:
	 *
	 * - A compositor not scaling the monitor viewport in its
	 * compositing space will advertise a logical size of 3840×2160,
	 *
	 * - A compositor scaling the monitor viewport with scale factor 2
	 * will advertise a logical size of 1920×1080,
	 *
	 * - A compositor scaling the monitor viewport using a fractional
	 * scale of 1.5 will advertise a logical size of 2560×1440.
	 *
	 * For example, for a wl_output mode 1920×1080 and a 90 degree
	 * rotation, the compositor will advertise a logical size of
	 * 1080x1920.
	 *
	 * The logical_size event is sent after creating an xdg_output (see
	 * xdg_output_manager.get_xdg_output) and whenever the logical size
	 * of the output changes, either as a result of a change in the
	 * applied scale or because of a change in the corresponding output
	 * mode(see wl_output.mode) or transform (see wl_output.transform).
	 * @param width width in global compositor space
	 * @param height height in global compositor space
	 */
	void (*logical_size)(void *data,
			     struct zxdg_output_v1 *zxdg_output_v1,
			     int32_t width,
			     int32_t height);
	/**
	 * all information about the output have been sent
	 *
	 * This event is sent after all other properties of an xdg_output
	 * have been sent.
	 *
	 * This allows changes to the xdg_output properties to be seen as
	 * atomic, even if they happen via multiple events.
	 *
	 * For objects version 3 onwards, this event is deprecated.
	 * Compositors are not required to send it anymore and must send
	 * wl_output.done instead.
	 * @deprecated Deprecated since version 3
	 */
	void (*done)(void *data,
		     struct zxdg_output_v1 *zxdg_output_v1);
	/**
	 * name of this output
	 *
	 * Many compositors will assign names to their outputs, show them
	 * to the user, allow them to be configured by name, etc. The
	 * client may wish to know this name as well to offer the user
	 * similar behaviors.
	 *
	 * The naming convention is compositor defined, but limited to
	 * alphanumeric characters and dashes (-). Each name is unique
	 * among all wl_output globals, but if a wl_output global is
	 * destroyed the same name may be reused later. The names will also
	 * remain consistent across sessions with the same hardware and
	 * software configuration.
	 *
	 * Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc.
	 * However, do not assume that the name is a reflection of an
	 * underlying DRM connector, X11 connection, etc.
	 *
	 * The name event is sent after creating an xdg_output (see
	 * xdg_output_manager.get_xdg_output). This event is only sent once
	 * per xdg_output, and the name does not change over the lifetime
	 * of the wl_output global.
	 *
	 * This event is deprecated, instead clients should use
	 * wl_output.name. Compositors must still support this event.
	 * @param name output name
	 * @since 2
	 */
	void (*name)(void *data,
		     struct zxdg_output_v1 *zxdg_output_v1,
		     const char *name);
	/**
	 * human-readable description of this output
	 *
	 * Many compositors can produce human-readable descriptions of
	 * their outputs. The client may wish to know this description as
	 * well, to communicate the user for various purposes.
	 *
	 * The description is a UTF-8 string with no convention defined for
	 * its contents. Examples might include 'Foocorp 11" Display' or
	 * 'Virtual X11 output via :1'.
	 *
	 * The description event is sent after creating an xdg_output (see
	 * xdg_output_manager.get_xdg_output) and whenever the description
	 * changes. The description is optional, and may not be sent at
	 * all.
	 *
	 * For objects of version 2 and lower, this event is only sent once
	 * per xdg_output, and the description does not change over the
	 * lifetime of the wl_output global.
	 *
	 * This event is deprecated, instead clients should use
	 * wl_output.description. Compositors must still support this
	 * event.
	 * @param description output description
	 * @since 2
	 */
	void (*description)(void *data,
			    struct zxdg_output_v1 *zxdg_output_v1,
			    const char *description);
};

/**
 * @ingroup iface_zxdg_output_v1
 */
static inline int
zxdg_output_v1_add_listener(struct zxdg_output_v1 *zxdg_output_v1,
			    const struct zxdg_output_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zxdg_output_v1,
				     (void (**)(void)) listener, data);
}

#define ZXDG_OUTPUT_V1_DESTROY 0

/**
 * @ingroup iface_zxdg_output_v1
 */
#define ZXDG_OUTPUT_V1_LOGICAL_POSITION_SINCE_VERSION 1
/**
 * @ingroup iface_zxdg_output_v1
 */
#define ZXDG_OUTPUT_V1_LOGICAL_SIZE_SINCE_VERSION 1
/**
 * @ingroup iface_zxdg_output_v1
 */
#define ZXDG_OUTPUT_V1_DONE_SINCE_VERSION 1
/**
 * @ingroup iface_zxdg_output_v1
 */
#define ZXDG_OUTPUT_V1_NAME_SINCE_VERSION 2
/**
 * @ingroup iface_zxdg_output_v1
 */
#define ZXDG_OUTPUT_V1_DESCRIPTION_SINCE_VERSION 2

/**
 * @ingroup iface_zxdg_output_v1
 */
#define ZXDG_OUTPUT_V1_DESTROY_SINCE_VERSION 1

/** @ingroup iface_zxdg_output_v1 */
static inline void
zxdg_output_v1_set_user_data(struct zxdg_output_v1 *zxdg_output_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zxdg_output_v1, user_data);
}

/** @ingroup iface_zxdg_output_v1 */
static inline void *
zxdg_output_v1_get_user_data(struct zxdg_output_v1 *zxdg_output_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_output_v1);
}

static inline uint32_t
zxdg_output_v1_get_version(struct zxdg_output_v1 *zxdg_output_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zxdg_output_v1);
}

/**
 * @ingroup iface_zxdg_output_v1
 *
 * Using this request a client can tell the server that it is not
 * going to use the xdg_output object anymore.
 */
static inline void
zxdg_output_v1_destroy(struct zxdg_output_v1 *zxdg_output_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zxdg_output_v1,
			 ZXDG_OUTPUT_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zxdg_output_v1), WL_MARSHAL_FLAG_DESTROY);
}

#ifdef  __cplusplus
}
#endif

#endif
/* Generated by wayland-scanner 1.23.1 */

/*
 * Copyright © 2017 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

extern const struct wl_interface wl_output_interface;
extern const struct wl_interface zxdg_output_v1_interface;

static const struct wl_interface *xdg_output_unstable_v1_types[] = {
	NULL,
	NULL,
	&zxdg_output_v1_interface,
	&wl_output_interface,
};

static const struct wl_message zxdg_output_manager_v1_requests[] = {
	{ "destroy", "", xdg_output_unstable_v1_types + 0 },
	{ "get_xdg_output", "no", xdg_output_unstable_v1_types + 2 },
};

const struct wl_interface zxdg_output_manager_v1_interface = {
	"zxdg_output_manager_v1", 3,
	2, zxdg_output_manager_v1_requests,
	0, NULL,
};

static const struct wl_message zxdg_output_v1_requests[] = {
	{ "destroy", "", xdg_output_unstable_v1_types + 0 },
};

static const struct wl_message zxdg_output_v1_events[] = {
	{ "logical_position", "ii", xdg_output_unstable_v1_types + 0 },
	{ "logical_size", "ii", xdg_output_unstable_v1_types + 0 },
	{ "done", "", xdg_output_unstable_v1_types + 0 },
	{ "name", "2s", xdg_output_unstable_v1_types + 0 },
	{ "description", "2s", xdg_output_unstable_v1_types + 0 },
};

const struct wl_interface zxdg_output_v1_interface = {
	"zxdg_output_v1", 3,
	1, zxdg_output_v1_requests,
	5, zxdg_output_v1_events,
};
/* Generated by wayland-scanner 1.23.1 */

#ifndef XDG_SHELL_CLIENT_PROTOCOL_H
#define XDG_SHELL_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_xdg_shell The xdg_shell protocol
 * @section page_ifaces_xdg_shell Interfaces
 * - @subpage page_iface_xdg_wm_base - create desktop-style surfaces
 * - @subpage page_iface_xdg_positioner - child surface positioner
 * - @subpage page_iface_xdg_surface - desktop user interface surface base interface
 * - @subpage page_iface_xdg_toplevel - toplevel surface
 * - @subpage page_iface_xdg_popup - short-lived, popup surfaces for menus
 * @section page_copyright_xdg_shell Copyright
 * <pre>
 *
 * Copyright © 2008-2013 Kristian Høgsberg
 * Copyright © 2013      Rafael Antognolli
 * Copyright © 2013      Jasper St. Pierre
 * Copyright © 2010-2013 Intel Corporation
 * Copyright © 2015-2017 Samsung Electronics Co., Ltd
 * Copyright © 2015-2017 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct wl_output;
struct wl_seat;
struct wl_surface;
struct xdg_popup;
struct xdg_positioner;
struct xdg_surface;
struct xdg_toplevel;
struct xdg_wm_base;

#ifndef XDG_WM_BASE_INTERFACE
#define XDG_WM_BASE_INTERFACE
/**
 * @page page_iface_xdg_wm_base xdg_wm_base
 * @section page_iface_xdg_wm_base_desc Description
 *
 * The xdg_wm_base interface is exposed as a global object enabling clients
 * to turn their wl_surfaces into windows in a desktop environment. It
 * defines the basic functionality needed for clients and the compositor to
 * create windows that can be dragged, resized, maximized, etc, as well as
 * creating transient windows such as popup menus.
 * @section page_iface_xdg_wm_base_api API
 * See @ref iface_xdg_wm_base.
 */
/**
 * @defgroup iface_xdg_wm_base The xdg_wm_base interface
 *
 * The xdg_wm_base interface is exposed as a global object enabling clients
 * to turn their wl_surfaces into windows in a desktop environment. It
 * defines the basic functionality needed for clients and the compositor to
 * create windows that can be dragged, resized, maximized, etc, as well as
 * creating transient windows such as popup menus.
 */
extern const struct wl_interface xdg_wm_base_interface;
#endif
#ifndef XDG_POSITIONER_INTERFACE
#define XDG_POSITIONER_INTERFACE
/**
 * @page page_iface_xdg_positioner xdg_positioner
 * @section page_iface_xdg_positioner_desc Description
 *
 * The xdg_positioner provides a collection of rules for the placement of a
 * child surface relative to a parent surface. Rules can be defined to ensure
 * the child surface remains within the visible area's borders, and to
 * specify how the child surface changes its position, such as sliding along
 * an axis, or flipping around a rectangle. These positioner-created rules are
 * constrained by the requirement that a child surface must intersect with or
 * be at least partially adjacent to its parent surface.
 *
 * See the various requests for details about possible rules.
 *
 * At the time of the request, the compositor makes a copy of the rules
 * specified by the xdg_positioner. Thus, after the request is complete the
 * xdg_positioner object can be destroyed or reused; further changes to the
 * object will have no effect on previous usages.
 *
 * For an xdg_positioner object to be considered complete, it must have a
 * non-zero size set by set_size, and a non-zero anchor rectangle set by
 * set_anchor_rect. Passing an incomplete xdg_positioner object when
 * positioning a surface raises an invalid_positioner error.
 * @section page_iface_xdg_positioner_api API
 * See @ref iface_xdg_positioner.
 */
/**
 * @defgroup iface_xdg_positioner The xdg_positioner interface
 *
 * The xdg_positioner provides a collection of rules for the placement of a
 * child surface relative to a parent surface. Rules can be defined to ensure
 * the child surface remains within the visible area's borders, and to
 * specify how the child surface changes its position, such as sliding along
 * an axis, or flipping around a rectangle. These positioner-created rules are
 * constrained by the requirement that a child surface must intersect with or
 * be at least partially adjacent to its parent surface.
 *
 * See the various requests for details about possible rules.
 *
 * At the time of the request, the compositor makes a copy of the rules
 * specified by the xdg_positioner. Thus, after the request is complete the
 * xdg_positioner object can be destroyed or reused; further changes to the
 * object will have no effect on previous usages.
 *
 * For an xdg_positioner object to be considered complete, it must have a
 * non-zero size set by set_size, and a non-zero anchor rectangle set by
 * set_anchor_rect. Passing an incomplete xdg_positioner object when
 * positioning a surface raises an invalid_positioner error.
 */
extern const struct wl_interface xdg_positioner_interface;
#endif
#ifndef XDG_SURFACE_INTERFACE
#define XDG_SURFACE_INTERFACE
/**
 * @page page_iface_xdg_surface xdg_surface
 * @section page_iface_xdg_surface_desc Description
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides a base set of functionality required to construct user
 * interface elements requiring management by the compositor, such as
 * toplevel windows, menus, etc. The types of functionality are split into
 * xdg_surface roles.
 *
 * Creating an xdg_surface does not set the role for a wl_surface. In order
 * to map an xdg_surface, the client must create a role-specific object
 * using, e.g., get_toplevel, get_popup. The wl_surface for any given
 * xdg_surface can have at most one role, and may not be assigned any role
 * not based on xdg_surface.
 *
 * A role must be assigned before any other requests are made to the
 * xdg_surface object.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_surface state to take effect.
 *
 * Creating an xdg_surface from a wl_surface which has a buffer attached or
 * committed is a client error, and any attempts by a client to attach or
 * manipulate a buffer prior to the first xdg_surface.configure call must
 * also be treated as errors.
 *
 * After creating a role-specific object and setting it up (e.g. by sending
 * the title, app ID, size constraints, parent, etc), the client must
 * perform an initial commit without any buffer attached. The compositor
 * will reply with initial wl_surface state such as
 * wl_surface.preferred_buffer_scale followed by an xdg_surface.configure
 * event. The client must acknowledge it and is then allowed to attach a
 * buffer to map the surface.
 *
 * Mapping an xdg_surface-based role surface is defined as making it
 * possible for the surface to be shown by the compositor. Note that
 * a mapped surface is not guaranteed to be visible once it is mapped.
 *
 * For an xdg_surface to be mapped by the compositor, the following
 * conditions must be met:
 * (1) the client has assigned an xdg_surface-based role to the surface
 * (2) the client has set and committed the xdg_surface state and the
 * role-dependent state to the surface
 * (3) the client has committed a buffer to the surface
 *
 * A newly-unmapped surface is considered to have met condition (1) out
 * of the 3 required conditions for mapping a surface if its role surface
 * has not been destroyed, i.e. the client must perform the initial commit
 * again before attaching a buffer.
 * @section page_iface_xdg_surface_api API
 * See @ref iface_xdg_surface.
 */
/**
 * @defgroup iface_xdg_surface The xdg_surface interface
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides a base set of functionality required to construct user
 * interface elements requiring management by the compositor, such as
 * toplevel windows, menus, etc. The types of functionality are split into
 * xdg_surface roles.
 *
 * Creating an xdg_surface does not set the role for a wl_surface. In order
 * to map an xdg_surface, the client must create a role-specific object
 * using, e.g., get_toplevel, get_popup. The wl_surface for any given
 * xdg_surface can have at most one role, and may not be assigned any role
 * not based on xdg_surface.
 *
 * A role must be assigned before any other requests are made to the
 * xdg_surface object.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_surface state to take effect.
 *
 * Creating an xdg_surface from a wl_surface which has a buffer attached or
 * committed is a client error, and any attempts by a client to attach or
 * manipulate a buffer prior to the first xdg_surface.configure call must
 * also be treated as errors.
 *
 * After creating a role-specific object and setting it up (e.g. by sending
 * the title, app ID, size constraints, parent, etc), the client must
 * perform an initial commit without any buffer attached. The compositor
 * will reply with initial wl_surface state such as
 * wl_surface.preferred_buffer_scale followed by an xdg_surface.configure
 * event. The client must acknowledge it and is then allowed to attach a
 * buffer to map the surface.
 *
 * Mapping an xdg_surface-based role surface is defined as making it
 * possible for the surface to be shown by the compositor. Note that
 * a mapped surface is not guaranteed to be visible once it is mapped.
 *
 * For an xdg_surface to be mapped by the compositor, the following
 * conditions must be met:
 * (1) the client has assigned an xdg_surface-based role to the surface
 * (2) the client has set and committed the xdg_surface state and the
 * role-dependent state to the surface
 * (3) the client has committed a buffer to the surface
 *
 * A newly-unmapped surface is considered to have met condition (1) out
 * of the 3 required conditions for mapping a surface if its role surface
 * has not been destroyed, i.e. the client must perform the initial commit
 * again before attaching a buffer.
 */
extern const struct wl_interface xdg_surface_interface;
#endif
#ifndef XDG_TOPLEVEL_INTERFACE
#define XDG_TOPLEVEL_INTERFACE
/**
 * @page page_iface_xdg_toplevel xdg_toplevel
 * @section page_iface_xdg_toplevel_desc Description
 *
 * This interface defines an xdg_surface role which allows a surface to,
 * among other things, set window-like properties such as maximize,
 * fullscreen, and minimize, set application-specific metadata like title and
 * id, and well as trigger user interactive operations such as interactive
 * resize and move.
 *
 * A xdg_toplevel by default is responsible for providing the full intended
 * visual representation of the toplevel, which depending on the window
 * state, may mean things like a title bar, window controls and drop shadow.
 *
 * Unmapping an xdg_toplevel means that the surface cannot be shown
 * by the compositor until it is explicitly mapped again.
 * All active operations (e.g., move, resize) are canceled and all
 * attributes (e.g. title, state, stacking, ...) are discarded for
 * an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to
 * the state it had right after xdg_surface.get_toplevel. The client
 * can re-map the toplevel by performing a commit without any buffer
 * attached, waiting for a configure event and handling it as usual (see
 * xdg_surface description).
 *
 * Attaching a null buffer to a toplevel unmaps the surface.
 * @section page_iface_xdg_toplevel_api API
 * See @ref iface_xdg_toplevel.
 */
/**
 * @defgroup iface_xdg_toplevel The xdg_toplevel interface
 *
 * This interface defines an xdg_surface role which allows a surface to,
 * among other things, set window-like properties such as maximize,
 * fullscreen, and minimize, set application-specific metadata like title and
 * id, and well as trigger user interactive operations such as interactive
 * resize and move.
 *
 * A xdg_toplevel by default is responsible for providing the full intended
 * visual representation of the toplevel, which depending on the window
 * state, may mean things like a title bar, window controls and drop shadow.
 *
 * Unmapping an xdg_toplevel means that the surface cannot be shown
 * by the compositor until it is explicitly mapped again.
 * All active operations (e.g., move, resize) are canceled and all
 * attributes (e.g. title, state, stacking, ...) are discarded for
 * an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to
 * the state it had right after xdg_surface.get_toplevel. The client
 * can re-map the toplevel by performing a commit without any buffer
 * attached, waiting for a configure event and handling it as usual (see
 * xdg_surface description).
 *
 * Attaching a null buffer to a toplevel unmaps the surface.
 */
extern const struct wl_interface xdg_toplevel_interface;
#endif
#ifndef XDG_POPUP_INTERFACE
#define XDG_POPUP_INTERFACE
/**
 * @page page_iface_xdg_popup xdg_popup
 * @section page_iface_xdg_popup_desc Description
 *
 * A popup surface is a short-lived, temporary surface. It can be used to
 * implement for example menus, popovers, tooltips and other similar user
 * interface concepts.
 *
 * A popup can be made to take an explicit grab. See xdg_popup.grab for
 * details.
 *
 * When the popup is dismissed, a popup_done event will be sent out, and at
 * the same time the surface will be unmapped. See the xdg_popup.popup_done
 * event for details.
 *
 * Explicitly destroying the xdg_popup object will also dismiss the popup and
 * unmap the surface. Clients that want to dismiss the popup when another
 * surface of their own is clicked should dismiss the popup using the destroy
 * request.
 *
 * A newly created xdg_popup will be stacked on top of all previously created
 * xdg_popup surfaces associated with the same xdg_toplevel.
 *
 * The parent of an xdg_popup must be mapped (see the xdg_surface
 * description) before the xdg_popup itself.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_popup state to take effect.
 * @section page_iface_xdg_popup_api API
 * See @ref iface_xdg_popup.
 */
/**
 * @defgroup iface_xdg_popup The xdg_popup interface
 *
 * A popup surface is a short-lived, temporary surface. It can be used to
 * implement for example menus, popovers, tooltips and other similar user
 * interface concepts.
 *
 * A popup can be made to take an explicit grab. See xdg_popup.grab for
 * details.
 *
 * When the popup is dismissed, a popup_done event will be sent out, and at
 * the same time the surface will be unmapped. See the xdg_popup.popup_done
 * event for details.
 *
 * Explicitly destroying the xdg_popup object will also dismiss the popup and
 * unmap the surface. Clients that want to dismiss the popup when another
 * surface of their own is clicked should dismiss the popup using the destroy
 * request.
 *
 * A newly created xdg_popup will be stacked on top of all previously created
 * xdg_popup surfaces associated with the same xdg_toplevel.
 *
 * The parent of an xdg_popup must be mapped (see the xdg_surface
 * description) before the xdg_popup itself.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_popup state to take effect.
 */
extern const struct wl_interface xdg_popup_interface;
#endif

#ifndef XDG_WM_BASE_ERROR_ENUM
#define XDG_WM_BASE_ERROR_ENUM
enum xdg_wm_base_error {
	/**
	 * given wl_surface has another role
	 */
	XDG_WM_BASE_ERROR_ROLE = 0,
	/**
	 * xdg_wm_base was destroyed before children
	 */
	XDG_WM_BASE_ERROR_DEFUNCT_SURFACES = 1,
	/**
	 * the client tried to map or destroy a non-topmost popup
	 */
	XDG_WM_BASE_ERROR_NOT_THE_TOPMOST_POPUP = 2,
	/**
	 * the client specified an invalid popup parent surface
	 */
	XDG_WM_BASE_ERROR_INVALID_POPUP_PARENT = 3,
	/**
	 * the client provided an invalid surface state
	 */
	XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE = 4,
	/**
	 * the client provided an invalid positioner
	 */
	XDG_WM_BASE_ERROR_INVALID_POSITIONER = 5,
	/**
	 * the client didn’t respond to a ping event in time
	 */
	XDG_WM_BASE_ERROR_UNRESPONSIVE = 6,
};
#endif /* XDG_WM_BASE_ERROR_ENUM */

/**
 * @ingroup iface_xdg_wm_base
 * @struct xdg_wm_base_listener
 */
struct xdg_wm_base_listener {
	/**
	 * check if the client is alive
	 *
	 * The ping event asks the client if it's still alive. Pass the
	 * serial specified in the event back to the compositor by sending
	 * a "pong" request back with the specified serial. See
	 * xdg_wm_base.pong.
	 *
	 * Compositors can use this to determine if the client is still
	 * alive. It's unspecified what will happen if the client doesn't
	 * respond to the ping request, or in what timeframe. Clients
	 * should try to respond in a reasonable amount of time. The
	 * “unresponsive” error is provided for compositors that wish
	 * to disconnect unresponsive clients.
	 *
	 * A compositor is free to ping in any way it wants, but a client
	 * must always respond to any xdg_wm_base object it created.
	 * @param serial pass this to the pong request
	 */
	void (*ping)(void *data,
		     struct xdg_wm_base *xdg_wm_base,
		     uint32_t serial);
};

/**
 * @ingroup iface_xdg_wm_base
 */
static inline int
xdg_wm_base_add_listener(struct xdg_wm_base *xdg_wm_base,
			 const struct xdg_wm_base_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) xdg_wm_base,
				     (void (**)(void)) listener, data);
}

#define XDG_WM_BASE_DESTROY 0
#define XDG_WM_BASE_CREATE_POSITIONER 1
#define XDG_WM_BASE_GET_XDG_SURFACE 2
#define XDG_WM_BASE_PONG 3

/**
 * @ingroup iface_xdg_wm_base
 */
#define XDG_WM_BASE_PING_SINCE_VERSION 1

/**
 * @ingroup iface_xdg_wm_base
 */
#define XDG_WM_BASE_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_wm_base
 */
#define XDG_WM_BASE_CREATE_POSITIONER_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_wm_base
 */
#define XDG_WM_BASE_GET_XDG_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_wm_base
 */
#define XDG_WM_BASE_PONG_SINCE_VERSION 1

/** @ingroup iface_xdg_wm_base */
static inline void
xdg_wm_base_set_user_data(struct xdg_wm_base *xdg_wm_base, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xdg_wm_base, user_data);
}

/** @ingroup iface_xdg_wm_base */
static inline void *
xdg_wm_base_get_user_data(struct xdg_wm_base *xdg_wm_base)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xdg_wm_base);
}

static inline uint32_t
xdg_wm_base_get_version(struct xdg_wm_base *xdg_wm_base)
{
	return wl_proxy_get_version((struct wl_proxy *) xdg_wm_base);
}

/**
 * @ingroup iface_xdg_wm_base
 *
 * Destroy this xdg_wm_base object.
 *
 * Destroying a bound xdg_wm_base object while there are surfaces
 * still alive created by this xdg_wm_base object instance is illegal
 * and will result in a defunct_surfaces error.
 */
static inline void
xdg_wm_base_destroy(struct xdg_wm_base *xdg_wm_base)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
			 XDG_WM_BASE_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xdg_wm_base
 *
 * Create a positioner object. A positioner object is used to position
 * surfaces relative to some parent surface. See the interface description
 * and xdg_surface.get_popup for details.
 */
static inline struct xdg_positioner *
xdg_wm_base_create_positioner(struct xdg_wm_base *xdg_wm_base)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
			 XDG_WM_BASE_CREATE_POSITIONER, &xdg_positioner_interface, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), 0, NULL);

	return (struct xdg_positioner *) id;
}

/**
 * @ingroup iface_xdg_wm_base
 *
 * This creates an xdg_surface for the given surface. While xdg_surface
 * itself is not a role, the corresponding surface may only be assigned
 * a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is
 * illegal to create an xdg_surface for a wl_surface which already has an
 * assigned role and this will result in a role error.
 *
 * This creates an xdg_surface for the given surface. An xdg_surface is
 * used as basis to define a role to a given surface, such as xdg_toplevel
 * or xdg_popup. It also manages functionality shared between xdg_surface
 * based surface roles.
 *
 * See the documentation of xdg_surface for more details about what an
 * xdg_surface is and how it is used.
 */
static inline struct xdg_surface *
xdg_wm_base_get_xdg_surface(struct xdg_wm_base *xdg_wm_base, struct wl_surface *surface)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
			 XDG_WM_BASE_GET_XDG_SURFACE, &xdg_surface_interface, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), 0, NULL, surface);

	return (struct xdg_surface *) id;
}

/**
 * @ingroup iface_xdg_wm_base
 *
 * A client must respond to a ping event with a pong request or
 * the client may be deemed unresponsive. See xdg_wm_base.ping
 * and xdg_wm_base.error.unresponsive.
 */
static inline void
xdg_wm_base_pong(struct xdg_wm_base *xdg_wm_base, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
			 XDG_WM_BASE_PONG, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), 0, serial);
}

#ifndef XDG_POSITIONER_ERROR_ENUM
#define XDG_POSITIONER_ERROR_ENUM
enum xdg_positioner_error {
	/**
	 * invalid input provided
	 */
	XDG_POSITIONER_ERROR_INVALID_INPUT = 0,
};
#endif /* XDG_POSITIONER_ERROR_ENUM */

#ifndef XDG_POSITIONER_ANCHOR_ENUM
#define XDG_POSITIONER_ANCHOR_ENUM
enum xdg_positioner_anchor {
	XDG_POSITIONER_ANCHOR_NONE = 0,
	XDG_POSITIONER_ANCHOR_TOP = 1,
	XDG_POSITIONER_ANCHOR_BOTTOM = 2,
	XDG_POSITIONER_ANCHOR_LEFT = 3,
	XDG_POSITIONER_ANCHOR_RIGHT = 4,
	XDG_POSITIONER_ANCHOR_TOP_LEFT = 5,
	XDG_POSITIONER_ANCHOR_BOTTOM_LEFT = 6,
	XDG_POSITIONER_ANCHOR_TOP_RIGHT = 7,
	XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT = 8,
};
#endif /* XDG_POSITIONER_ANCHOR_ENUM */

#ifndef XDG_POSITIONER_GRAVITY_ENUM
#define XDG_POSITIONER_GRAVITY_ENUM
enum xdg_positioner_gravity {
	XDG_POSITIONER_GRAVITY_NONE = 0,
	XDG_POSITIONER_GRAVITY_TOP = 1,
	XDG_POSITIONER_GRAVITY_BOTTOM = 2,
	XDG_POSITIONER_GRAVITY_LEFT = 3,
	XDG_POSITIONER_GRAVITY_RIGHT = 4,
	XDG_POSITIONER_GRAVITY_TOP_LEFT = 5,
	XDG_POSITIONER_GRAVITY_BOTTOM_LEFT = 6,
	XDG_POSITIONER_GRAVITY_TOP_RIGHT = 7,
	XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT = 8,
};
#endif /* XDG_POSITIONER_GRAVITY_ENUM */

#ifndef XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM
#define XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM
/**
 * @ingroup iface_xdg_positioner
 * constraint adjustments
 *
 * The constraint adjustment value define ways the compositor will adjust
 * the position of the surface, if the unadjusted position would result
 * in the surface being partly constrained.
 *
 * Whether a surface is considered 'constrained' is left to the compositor
 * to determine. For example, the surface may be partly outside the
 * compositor's defined 'work area', thus necessitating the child surface's
 * position be adjusted until it is entirely inside the work area.
 *
 * The adjustments can be combined, according to a defined precedence: 1)
 * Flip, 2) Slide, 3) Resize.
 */
enum xdg_positioner_constraint_adjustment {
	/**
	 * don't move the child surface when constrained
	 *
	 * Don't alter the surface position even if it is constrained on
	 * some axis, for example partially outside the edge of an output.
	 */
	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_NONE = 0,
	/**
	 * move along the x axis until unconstrained
	 *
	 * Slide the surface along the x axis until it is no longer
	 * constrained.
	 *
	 * First try to slide towards the direction of the gravity on the x
	 * axis until either the edge in the opposite direction of the
	 * gravity is unconstrained or the edge in the direction of the
	 * gravity is constrained.
	 *
	 * Then try to slide towards the opposite direction of the gravity
	 * on the x axis until either the edge in the direction of the
	 * gravity is unconstrained or the edge in the opposite direction
	 * of the gravity is constrained.
	 */
	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X = 1,
	/**
	 * move along the y axis until unconstrained
	 *
	 * Slide the surface along the y axis until it is no longer
	 * constrained.
	 *
	 * First try to slide towards the direction of the gravity on the y
	 * axis until either the edge in the opposite direction of the
	 * gravity is unconstrained or the edge in the direction of the
	 * gravity is constrained.
	 *
	 * Then try to slide towards the opposite direction of the gravity
	 * on the y axis until either the edge in the direction of the
	 * gravity is unconstrained or the edge in the opposite direction
	 * of the gravity is constrained.
	 */
	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y = 2,
	/**
	 * invert the anchor and gravity on the x axis
	 *
	 * Invert the anchor and gravity on the x axis if the surface is
	 * constrained on the x axis. For example, if the left edge of the
	 * surface is constrained, the gravity is 'left' and the anchor is
	 * 'left', change the gravity to 'right' and the anchor to 'right'.
	 *
	 * If the adjusted position also ends up being constrained, the
	 * resulting position of the flip_x adjustment will be the one
	 * before the adjustment.
	 */
	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_X = 4,
	/**
	 * invert the anchor and gravity on the y axis
	 *
	 * Invert the anchor and gravity on the y axis if the surface is
	 * constrained on the y axis. For example, if the bottom edge of
	 * the surface is constrained, the gravity is 'bottom' and the
	 * anchor is 'bottom', change the gravity to 'top' and the anchor
	 * to 'top'.
	 *
	 * The adjusted position is calculated given the original anchor
	 * rectangle and offset, but with the new flipped anchor and
	 * gravity values.
	 *
	 * If the adjusted position also ends up being constrained, the
	 * resulting position of the flip_y adjustment will be the one
	 * before the adjustment.
	 */
	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y = 8,
	/**
	 * horizontally resize the surface
	 *
	 * Resize the surface horizontally so that it is completely
	 * unconstrained.
	 */
	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_X = 16,
	/**
	 * vertically resize the surface
	 *
	 * Resize the surface vertically so that it is completely
	 * unconstrained.
	 */
	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_Y = 32,
};
#endif /* XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM */

#define XDG_POSITIONER_DESTROY 0
#define XDG_POSITIONER_SET_SIZE 1
#define XDG_POSITIONER_SET_ANCHOR_RECT 2
#define XDG_POSITIONER_SET_ANCHOR 3
#define XDG_POSITIONER_SET_GRAVITY 4
#define XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT 5
#define XDG_POSITIONER_SET_OFFSET 6
#define XDG_POSITIONER_SET_REACTIVE 7
#define XDG_POSITIONER_SET_PARENT_SIZE 8
#define XDG_POSITIONER_SET_PARENT_CONFIGURE 9


/**
 * @ingroup iface_xdg_positioner
 */
#define XDG_POSITIONER_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_positioner
 */
#define XDG_POSITIONER_SET_SIZE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_positioner
 */
#define XDG_POSITIONER_SET_ANCHOR_RECT_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_positioner
 */
#define XDG_POSITIONER_SET_ANCHOR_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_positioner
 */
#define XDG_POSITIONER_SET_GRAVITY_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_positioner
 */
#define XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_positioner
 */
#define XDG_POSITIONER_SET_OFFSET_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_positioner
 */
#define XDG_POSITIONER_SET_REACTIVE_SINCE_VERSION 3
/**
 * @ingroup iface_xdg_positioner
 */
#define XDG_POSITIONER_SET_PARENT_SIZE_SINCE_VERSION 3
/**
 * @ingroup iface_xdg_positioner
 */
#define XDG_POSITIONER_SET_PARENT_CONFIGURE_SINCE_VERSION 3

/** @ingroup iface_xdg_positioner */
static inline void
xdg_positioner_set_user_data(struct xdg_positioner *xdg_positioner, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xdg_positioner, user_data);
}

/** @ingroup iface_xdg_positioner */
static inline void *
xdg_positioner_get_user_data(struct xdg_positioner *xdg_positioner)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xdg_positioner);
}

static inline uint32_t
xdg_positioner_get_version(struct xdg_positioner *xdg_positioner)
{
	return wl_proxy_get_version((struct wl_proxy *) xdg_positioner);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Notify the compositor that the xdg_positioner will no longer be used.
 */
static inline void
xdg_positioner_destroy(struct xdg_positioner *xdg_positioner)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Set the size of the surface that is to be positioned with the positioner
 * object. The size is in surface-local coordinates and corresponds to the
 * window geometry. See xdg_surface.set_window_geometry.
 *
 * If a zero or negative size is set the invalid_input error is raised.
 */
static inline void
xdg_positioner_set_size(struct xdg_positioner *xdg_positioner, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, width, height);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Specify the anchor rectangle within the parent surface that the child
 * surface will be placed relative to. The rectangle is relative to the
 * window geometry as defined by xdg_surface.set_window_geometry of the
 * parent surface.
 *
 * When the xdg_positioner object is used to position a child surface, the
 * anchor rectangle may not extend outside the window geometry of the
 * positioned child's parent surface.
 *
 * If a negative size is set the invalid_input error is raised.
 */
static inline void
xdg_positioner_set_anchor_rect(struct xdg_positioner *xdg_positioner, int32_t x, int32_t y, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_ANCHOR_RECT, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, x, y, width, height);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Defines the anchor point for the anchor rectangle. The specified anchor
 * is used derive an anchor point that the child surface will be
 * positioned relative to. If a corner anchor is set (e.g. 'top_left' or
 * 'bottom_right'), the anchor point will be at the specified corner;
 * otherwise, the derived anchor point will be centered on the specified
 * edge, or in the center of the anchor rectangle if no edge is specified.
 */
static inline void
xdg_positioner_set_anchor(struct xdg_positioner *xdg_positioner, uint32_t anchor)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_ANCHOR, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, anchor);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Defines in what direction a surface should be positioned, relative to
 * the anchor point of the parent surface. If a corner gravity is
 * specified (e.g. 'bottom_right' or 'top_left'), then the child surface
 * will be placed towards the specified gravity; otherwise, the child
 * surface will be centered over the anchor point on any axis that had no
 * gravity specified. If the gravity is not in the ‘gravity’ enum, an
 * invalid_input error is raised.
 */
static inline void
xdg_positioner_set_gravity(struct xdg_positioner *xdg_positioner, uint32_t gravity)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_GRAVITY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, gravity);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Specify how the window should be positioned if the originally intended
 * position caused the surface to be constrained, meaning at least
 * partially outside positioning boundaries set by the compositor. The
 * adjustment is set by constructing a bitmask describing the adjustment to
 * be made when the surface is constrained on that axis.
 *
 * If no bit for one axis is set, the compositor will assume that the child
 * surface should not change its position on that axis when constrained.
 *
 * If more than one bit for one axis is set, the order of how adjustments
 * are applied is specified in the corresponding adjustment descriptions.
 *
 * The default adjustment is none.
 */
static inline void
xdg_positioner_set_constraint_adjustment(struct xdg_positioner *xdg_positioner, uint32_t constraint_adjustment)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, constraint_adjustment);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Specify the surface position offset relative to the position of the
 * anchor on the anchor rectangle and the anchor on the surface. For
 * example if the anchor of the anchor rectangle is at (x, y), the surface
 * has the gravity bottom|right, and the offset is (ox, oy), the calculated
 * surface position will be (x + ox, y + oy). The offset position of the
 * surface is the one used for constraint testing. See
 * set_constraint_adjustment.
 *
 * An example use case is placing a popup menu on top of a user interface
 * element, while aligning the user interface element of the parent surface
 * with some user interface element placed somewhere in the popup surface.
 */
static inline void
xdg_positioner_set_offset(struct xdg_positioner *xdg_positioner, int32_t x, int32_t y)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_OFFSET, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, x, y);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * When set reactive, the surface is reconstrained if the conditions used
 * for constraining changed, e.g. the parent window moved.
 *
 * If the conditions changed and the popup was reconstrained, an
 * xdg_popup.configure event is sent with updated geometry, followed by an
 * xdg_surface.configure event.
 */
static inline void
xdg_positioner_set_reactive(struct xdg_positioner *xdg_positioner)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_REACTIVE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Set the parent window geometry the compositor should use when
 * positioning the popup. The compositor may use this information to
 * determine the future state the popup should be constrained using. If
 * this doesn't match the dimension of the parent the popup is eventually
 * positioned against, the behavior is undefined.
 *
 * The arguments are given in the surface-local coordinate space.
 */
static inline void
xdg_positioner_set_parent_size(struct xdg_positioner *xdg_positioner, int32_t parent_width, int32_t parent_height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_PARENT_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, parent_width, parent_height);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Set the serial of an xdg_surface.configure event this positioner will be
 * used in response to. The compositor may use this information together
 * with set_parent_size to determine what future state the popup should be
 * constrained using.
 */
static inline void
xdg_positioner_set_parent_configure(struct xdg_positioner *xdg_positioner, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_PARENT_CONFIGURE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, serial);
}

#ifndef XDG_SURFACE_ERROR_ENUM
#define XDG_SURFACE_ERROR_ENUM
enum xdg_surface_error {
	/**
	 * Surface was not fully constructed
	 */
	XDG_SURFACE_ERROR_NOT_CONSTRUCTED = 1,
	/**
	 * Surface was already constructed
	 */
	XDG_SURFACE_ERROR_ALREADY_CONSTRUCTED = 2,
	/**
	 * Attaching a buffer to an unconfigured surface
	 */
	XDG_SURFACE_ERROR_UNCONFIGURED_BUFFER = 3,
	/**
	 * Invalid serial number when acking a configure event
	 */
	XDG_SURFACE_ERROR_INVALID_SERIAL = 4,
	/**
	 * Width or height was zero or negative
	 */
	XDG_SURFACE_ERROR_INVALID_SIZE = 5,
	/**
	 * Surface was destroyed before its role object
	 */
	XDG_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT = 6,
};
#endif /* XDG_SURFACE_ERROR_ENUM */

/**
 * @ingroup iface_xdg_surface
 * @struct xdg_surface_listener
 */
struct xdg_surface_listener {
	/**
	 * suggest a surface change
	 *
	 * The configure event marks the end of a configure sequence. A
	 * configure sequence is a set of one or more events configuring
	 * the state of the xdg_surface, including the final
	 * xdg_surface.configure event.
	 *
	 * Where applicable, xdg_surface surface roles will during a
	 * configure sequence extend this event as a latched state sent as
	 * events before the xdg_surface.configure event. Such events
	 * should be considered to make up a set of atomically applied
	 * configuration states, where the xdg_surface.configure commits
	 * the accumulated state.
	 *
	 * Clients should arrange their surface for the new states, and
	 * then send an ack_configure request with the serial sent in this
	 * configure event at some point before committing the new surface.
	 *
	 * If the client receives multiple configure events before it can
	 * respond to one, it is free to discard all but the last event it
	 * received.
	 * @param serial serial of the configure event
	 */
	void (*configure)(void *data,
			  struct xdg_surface *xdg_surface,
			  uint32_t serial);
};

/**
 * @ingroup iface_xdg_surface
 */
static inline int
xdg_surface_add_listener(struct xdg_surface *xdg_surface,
			 const struct xdg_surface_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) xdg_surface,
				     (void (**)(void)) listener, data);
}

#define XDG_SURFACE_DESTROY 0
#define XDG_SURFACE_GET_TOPLEVEL 1
#define XDG_SURFACE_GET_POPUP 2
#define XDG_SURFACE_SET_WINDOW_GEOMETRY 3
#define XDG_SURFACE_ACK_CONFIGURE 4

/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_CONFIGURE_SINCE_VERSION 1

/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_GET_TOPLEVEL_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_GET_POPUP_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_SET_WINDOW_GEOMETRY_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_ACK_CONFIGURE_SINCE_VERSION 1

/** @ingroup iface_xdg_surface */
static inline void
xdg_surface_set_user_data(struct xdg_surface *xdg_surface, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xdg_surface, user_data);
}

/** @ingroup iface_xdg_surface */
static inline void *
xdg_surface_get_user_data(struct xdg_surface *xdg_surface)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xdg_surface);
}

static inline uint32_t
xdg_surface_get_version(struct xdg_surface *xdg_surface)
{
	return wl_proxy_get_version((struct wl_proxy *) xdg_surface);
}

/**
 * @ingroup iface_xdg_surface
 *
 * Destroy the xdg_surface object. An xdg_surface must only be destroyed
 * after its role object has been destroyed, otherwise
 * a defunct_role_object error is raised.
 */
static inline void
xdg_surface_destroy(struct xdg_surface *xdg_surface)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_surface), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xdg_surface
 *
 * This creates an xdg_toplevel object for the given xdg_surface and gives
 * the associated wl_surface the xdg_toplevel role.
 *
 * See the documentation of xdg_toplevel for more details about what an
 * xdg_toplevel is and how it is used.
 */
static inline struct xdg_toplevel *
xdg_surface_get_toplevel(struct xdg_surface *xdg_surface)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_GET_TOPLEVEL, &xdg_toplevel_interface, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, NULL);

	return (struct xdg_toplevel *) id;
}

/**
 * @ingroup iface_xdg_surface
 *
 * This creates an xdg_popup object for the given xdg_surface and gives
 * the associated wl_surface the xdg_popup role.
 *
 * If null is passed as a parent, a parent surface must be specified using
 * some other protocol, before committing the initial state.
 *
 * See the documentation of xdg_popup for more details about what an
 * xdg_popup is and how it is used.
 */
static inline struct xdg_popup *
xdg_surface_get_popup(struct xdg_surface *xdg_surface, struct xdg_surface *parent, struct xdg_positioner *positioner)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_GET_POPUP, &xdg_popup_interface, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, NULL, parent, positioner);

	return (struct xdg_popup *) id;
}

/**
 * @ingroup iface_xdg_surface
 *
 * The window geometry of a surface is its "visible bounds" from the
 * user's perspective. Client-side decorations often have invisible
 * portions like drop-shadows which should be ignored for the
 * purposes of aligning, placing and constraining windows.
 *
 * The window geometry is double-buffered state, see wl_surface.commit.
 *
 * When maintaining a position, the compositor should treat the (x, y)
 * coordinate of the window geometry as the top left corner of the window.
 * A client changing the (x, y) window geometry coordinate should in
 * general not alter the position of the window.
 *
 * Once the window geometry of the surface is set, it is not possible to
 * unset it, and it will remain the same until set_window_geometry is
 * called again, even if a new subsurface or buffer is attached.
 *
 * If never set, the value is the full bounds of the surface,
 * including any subsurfaces. This updates dynamically on every
 * commit. This unset is meant for extremely simple clients.
 *
 * The arguments are given in the surface-local coordinate space of
 * the wl_surface associated with this xdg_surface, and may extend outside
 * of the wl_surface itself to mark parts of the subsurface tree as part of
 * the window geometry.
 *
 * When applied, the effective window geometry will be the set window
 * geometry clamped to the bounding rectangle of the combined
 * geometry of the surface of the xdg_surface and the associated
 * subsurfaces.
 *
 * The effective geometry will not be recalculated unless a new call to
 * set_window_geometry is done and the new pending surface state is
 * subsequently applied.
 *
 * The width and height of the effective window geometry must be
 * greater than zero. Setting an invalid size will raise an
 * invalid_size error.
 */
static inline void
xdg_surface_set_window_geometry(struct xdg_surface *xdg_surface, int32_t x, int32_t y, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_SET_WINDOW_GEOMETRY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, x, y, width, height);
}

/**
 * @ingroup iface_xdg_surface
 *
 * When a configure event is received, if a client commits the
 * surface in response to the configure event, then the client
 * must make an ack_configure request sometime before the commit
 * request, passing along the serial of the configure event.
 *
 * For instance, for toplevel surfaces the compositor might use this
 * information to move a surface to the top left only when the client has
 * drawn itself for the maximized or fullscreen state.
 *
 * If the client receives multiple configure events before it
 * can respond to one, it only has to ack the last configure event.
 * Acking a configure event that was never sent raises an invalid_serial
 * error.
 *
 * A client is not required to commit immediately after sending
 * an ack_configure request - it may even ack_configure several times
 * before its next surface commit.
 *
 * A client may send multiple ack_configure requests before committing, but
 * only the last request sent before a commit indicates which configure
 * event the client really is responding to.
 *
 * Sending an ack_configure request consumes the serial number sent with
 * the request, as well as serial numbers sent by all configure events
 * sent on this xdg_surface prior to the configure event referenced by
 * the committed serial.
 *
 * It is an error to issue multiple ack_configure requests referencing a
 * serial from the same configure event, or to issue an ack_configure
 * request referencing a serial from a configure event issued before the
 * event identified by the last ack_configure request for the same
 * xdg_surface. Doing so will raise an invalid_serial error.
 */
static inline void
xdg_surface_ack_configure(struct xdg_surface *xdg_surface, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_ACK_CONFIGURE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, serial);
}

#ifndef XDG_TOPLEVEL_ERROR_ENUM
#define XDG_TOPLEVEL_ERROR_ENUM
enum xdg_toplevel_error {
	/**
	 * provided value is         not a valid variant of the resize_edge enum
	 */
	XDG_TOPLEVEL_ERROR_INVALID_RESIZE_EDGE = 0,
	/**
	 * invalid parent toplevel
	 */
	XDG_TOPLEVEL_ERROR_INVALID_PARENT = 1,
	/**
	 * client provided an invalid min or max size
	 */
	XDG_TOPLEVEL_ERROR_INVALID_SIZE = 2,
};
#endif /* XDG_TOPLEVEL_ERROR_ENUM */

#ifndef XDG_TOPLEVEL_RESIZE_EDGE_ENUM
#define XDG_TOPLEVEL_RESIZE_EDGE_ENUM
/**
 * @ingroup iface_xdg_toplevel
 * edge values for resizing
 *
 * These values are used to indicate which edge of a surface
 * is being dragged in a resize operation.
 */
enum xdg_toplevel_resize_edge {
	XDG_TOPLEVEL_RESIZE_EDGE_NONE = 0,
	XDG_TOPLEVEL_RESIZE_EDGE_TOP = 1,
	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM = 2,
	XDG_TOPLEVEL_RESIZE_EDGE_LEFT = 4,
	XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT = 5,
	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT = 6,
	XDG_TOPLEVEL_RESIZE_EDGE_RIGHT = 8,
	XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT = 9,
	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT = 10,
};
#endif /* XDG_TOPLEVEL_RESIZE_EDGE_ENUM */

#ifndef XDG_TOPLEVEL_STATE_ENUM
#define XDG_TOPLEVEL_STATE_ENUM
/**
 * @ingroup iface_xdg_toplevel
 * types of state on the surface
 *
 * The different state values used on the surface. This is designed for
 * state values like maximized, fullscreen. It is paired with the
 * configure event to ensure that both the client and the compositor
 * setting the state can be synchronized.
 *
 * States set in this way are double-buffered, see wl_surface.commit.
 */
enum xdg_toplevel_state {
	/**
	 * the surface is maximized
	 * the surface is maximized
	 *
	 * The surface is maximized. The window geometry specified in the
	 * configure event must be obeyed by the client, or the
	 * xdg_wm_base.invalid_surface_state error is raised.
	 *
	 * The client should draw without shadow or other decoration
	 * outside of the window geometry.
	 */
	XDG_TOPLEVEL_STATE_MAXIMIZED = 1,
	/**
	 * the surface is fullscreen
	 * the surface is fullscreen
	 *
	 * The surface is fullscreen. The window geometry specified in
	 * the configure event is a maximum; the client cannot resize
	 * beyond it. For a surface to cover the whole fullscreened area,
	 * the geometry dimensions must be obeyed by the client. For more
	 * details, see xdg_toplevel.set_fullscreen.
	 */
	XDG_TOPLEVEL_STATE_FULLSCREEN = 2,
	/**
	 * the surface is being resized
	 * the surface is being resized
	 *
	 * The surface is being resized. The window geometry specified in
	 * the configure event is a maximum; the client cannot resize
	 * beyond it. Clients that have aspect ratio or cell sizing
	 * configuration can use a smaller size, however.
	 */
	XDG_TOPLEVEL_STATE_RESIZING = 3,
	/**
	 * the surface is now activated
	 * the surface is now activated
	 *
	 * Client window decorations should be painted as if the window
	 * is active. Do not assume this means that the window actually has
	 * keyboard or pointer focus.
	 */
	XDG_TOPLEVEL_STATE_ACTIVATED = 4,
	/**
	 * the surface’s left edge is tiled
	 *
	 * The window is currently in a tiled layout and the left edge is
	 * considered to be adjacent to another part of the tiling grid.
	 *
	 * The client should draw without shadow or other decoration
	 * outside of the window geometry on the left edge.
	 * @since 2
	 */
	XDG_TOPLEVEL_STATE_TILED_LEFT = 5,
	/**
	 * the surface’s right edge is tiled
	 *
	 * The window is currently in a tiled layout and the right edge
	 * is considered to be adjacent to another part of the tiling grid.
	 *
	 * The client should draw without shadow or other decoration
	 * outside of the window geometry on the right edge.
	 * @since 2
	 */
	XDG_TOPLEVEL_STATE_TILED_RIGHT = 6,
	/**
	 * the surface’s top edge is tiled
	 *
	 * The window is currently in a tiled layout and the top edge is
	 * considered to be adjacent to another part of the tiling grid.
	 *
	 * The client should draw without shadow or other decoration
	 * outside of the window geometry on the top edge.
	 * @since 2
	 */
	XDG_TOPLEVEL_STATE_TILED_TOP = 7,
	/**
	 * the surface’s bottom edge is tiled
	 *
	 * The window is currently in a tiled layout and the bottom edge
	 * is considered to be adjacent to another part of the tiling grid.
	 *
	 * The client should draw without shadow or other decoration
	 * outside of the window geometry on the bottom edge.
	 * @since 2
	 */
	XDG_TOPLEVEL_STATE_TILED_BOTTOM = 8,
	/**
	 * surface repaint is suspended
	 *
	 * The surface is currently not ordinarily being repainted; for
	 * example because its content is occluded by another window, or
	 * its outputs are switched off due to screen locking.
	 * @since 6
	 */
	XDG_TOPLEVEL_STATE_SUSPENDED = 9,
};
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_STATE_TILED_LEFT_SINCE_VERSION 2
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_STATE_TILED_RIGHT_SINCE_VERSION 2
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_STATE_TILED_TOP_SINCE_VERSION 2
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_STATE_TILED_BOTTOM_SINCE_VERSION 2
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_STATE_SUSPENDED_SINCE_VERSION 6
#endif /* XDG_TOPLEVEL_STATE_ENUM */

#ifndef XDG_TOPLEVEL_WM_CAPABILITIES_ENUM
#define XDG_TOPLEVEL_WM_CAPABILITIES_ENUM
enum xdg_toplevel_wm_capabilities {
	/**
	 * show_window_menu is available
	 */
	XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU = 1,
	/**
	 * set_maximized and unset_maximized are available
	 */
	XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE = 2,
	/**
	 * set_fullscreen and unset_fullscreen are available
	 */
	XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN = 3,
	/**
	 * set_minimized is available
	 */
	XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE = 4,
};
#endif /* XDG_TOPLEVEL_WM_CAPABILITIES_ENUM */

/**
 * @ingroup iface_xdg_toplevel
 * @struct xdg_toplevel_listener
 */
struct xdg_toplevel_listener {
	/**
	 * suggest a surface change
	 *
	 * This configure event asks the client to resize its toplevel
	 * surface or to change its state. The configured state should not
	 * be applied immediately. See xdg_surface.configure for details.
	 *
	 * The width and height arguments specify a hint to the window
	 * about how its surface should be resized in window geometry
	 * coordinates. See set_window_geometry.
	 *
	 * If the width or height arguments are zero, it means the client
	 * should decide its own window dimension. This may happen when the
	 * compositor needs to configure the state of the surface but
	 * doesn't have any information about any previous or expected
	 * dimension.
	 *
	 * The states listed in the event specify how the width/height
	 * arguments should be interpreted, and possibly how it should be
	 * drawn.
	 *
	 * Clients must send an ack_configure in response to this event.
	 * See xdg_surface.configure and xdg_surface.ack_configure for
	 * details.
	 */
	void (*configure)(void *data,
			  struct xdg_toplevel *xdg_toplevel,
			  int32_t width,
			  int32_t height,
			  struct wl_array *states);
	/**
	 * surface wants to be closed
	 *
	 * The close event is sent by the compositor when the user wants
	 * the surface to be closed. This should be equivalent to the user
	 * clicking the close button in client-side decorations, if your
	 * application has any.
	 *
	 * This is only a request that the user intends to close the
	 * window. The client may choose to ignore this request, or show a
	 * dialog to ask the user to save their data, etc.
	 */
	void (*close)(void *data,
		      struct xdg_toplevel *xdg_toplevel);
	/**
	 * recommended window geometry bounds
	 *
	 * The configure_bounds event may be sent prior to a
	 * xdg_toplevel.configure event to communicate the bounds a window
	 * geometry size is recommended to constrain to.
	 *
	 * The passed width and height are in surface coordinate space. If
	 * width and height are 0, it means bounds is unknown and
	 * equivalent to as if no configure_bounds event was ever sent for
	 * this surface.
	 *
	 * The bounds can for example correspond to the size of a monitor
	 * excluding any panels or other shell components, so that a
	 * surface isn't created in a way that it cannot fit.
	 *
	 * The bounds may change at any point, and in such a case, a new
	 * xdg_toplevel.configure_bounds will be sent, followed by
	 * xdg_toplevel.configure and xdg_surface.configure.
	 * @since 4
	 */
	void (*configure_bounds)(void *data,
				 struct xdg_toplevel *xdg_toplevel,
				 int32_t width,
				 int32_t height);
	/**
	 * compositor capabilities
	 *
	 * This event advertises the capabilities supported by the
	 * compositor. If a capability isn't supported, clients should hide
	 * or disable the UI elements that expose this functionality. For
	 * instance, if the compositor doesn't advertise support for
	 * minimized toplevels, a button triggering the set_minimized
	 * request should not be displayed.
	 *
	 * The compositor will ignore requests it doesn't support. For
	 * instance, a compositor which doesn't advertise support for
	 * minimized will ignore set_minimized requests.
	 *
	 * Compositors must send this event once before the first
	 * xdg_surface.configure event. When the capabilities change,
	 * compositors must send this event again and then send an
	 * xdg_surface.configure event.
	 *
	 * The configured state should not be applied immediately. See
	 * xdg_surface.configure for details.
	 *
	 * The capabilities are sent as an array of 32-bit unsigned
	 * integers in native endianness.
	 * @param capabilities array of 32-bit capabilities
	 * @since 5
	 */
	void (*wm_capabilities)(void *data,
				struct xdg_toplevel *xdg_toplevel,
				struct wl_array *capabilities);
};

/**
 * @ingroup iface_xdg_toplevel
 */
static inline int
xdg_toplevel_add_listener(struct xdg_toplevel *xdg_toplevel,
			  const struct xdg_toplevel_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) xdg_toplevel,
				     (void (**)(void)) listener, data);
}

#define XDG_TOPLEVEL_DESTROY 0
#define XDG_TOPLEVEL_SET_PARENT 1
#define XDG_TOPLEVEL_SET_TITLE 2
#define XDG_TOPLEVEL_SET_APP_ID 3
#define XDG_TOPLEVEL_SHOW_WINDOW_MENU 4
#define XDG_TOPLEVEL_MOVE 5
#define XDG_TOPLEVEL_RESIZE 6
#define XDG_TOPLEVEL_SET_MAX_SIZE 7
#define XDG_TOPLEVEL_SET_MIN_SIZE 8
#define XDG_TOPLEVEL_SET_MAXIMIZED 9
#define XDG_TOPLEVEL_UNSET_MAXIMIZED 10
#define XDG_TOPLEVEL_SET_FULLSCREEN 11
#define XDG_TOPLEVEL_UNSET_FULLSCREEN 12
#define XDG_TOPLEVEL_SET_MINIMIZED 13

/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_CONFIGURE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_CLOSE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_CONFIGURE_BOUNDS_SINCE_VERSION 4
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_WM_CAPABILITIES_SINCE_VERSION 5

/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_SET_PARENT_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_SET_TITLE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_SET_APP_ID_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_SHOW_WINDOW_MENU_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_MOVE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_RESIZE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_SET_MAX_SIZE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_SET_MIN_SIZE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_SET_MAXIMIZED_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_UNSET_MAXIMIZED_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_SET_FULLSCREEN_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_UNSET_FULLSCREEN_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_SET_MINIMIZED_SINCE_VERSION 1

/** @ingroup iface_xdg_toplevel */
static inline void
xdg_toplevel_set_user_data(struct xdg_toplevel *xdg_toplevel, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xdg_toplevel, user_data);
}

/** @ingroup iface_xdg_toplevel */
static inline void *
xdg_toplevel_get_user_data(struct xdg_toplevel *xdg_toplevel)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xdg_toplevel);
}

static inline uint32_t
xdg_toplevel_get_version(struct xdg_toplevel *xdg_toplevel)
{
	return wl_proxy_get_version((struct wl_proxy *) xdg_toplevel);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * This request destroys the role surface and unmaps the surface;
 * see "Unmapping" behavior in interface section for details.
 */
static inline void
xdg_toplevel_destroy(struct xdg_toplevel *xdg_toplevel)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Set the "parent" of this surface. This surface should be stacked
 * above the parent surface and all other ancestor surfaces.
 *
 * Parent surfaces should be set on dialogs, toolboxes, or other
 * "auxiliary" surfaces, so that the parent is raised when the dialog
 * is raised.
 *
 * Setting a null parent for a child surface unsets its parent. Setting
 * a null parent for a surface which currently has no parent is a no-op.
 *
 * Only mapped surfaces can have child surfaces. Setting a parent which
 * is not mapped is equivalent to setting a null parent. If a surface
 * becomes unmapped, its children's parent is set to the parent of
 * the now-unmapped surface. If the now-unmapped surface has no parent,
 * its children's parent is unset. If the now-unmapped surface becomes
 * mapped again, its parent-child relationship is not restored.
 *
 * The parent toplevel must not be one of the child toplevel's
 * descendants, and the parent must be different from the child toplevel,
 * otherwise the invalid_parent protocol error is raised.
 */
static inline void
xdg_toplevel_set_parent(struct xdg_toplevel *xdg_toplevel, struct xdg_toplevel *parent)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_PARENT, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, parent);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Set a short title for the surface.
 *
 * This string may be used to identify the surface in a task bar,
 * window list, or other user interface elements provided by the
 * compositor.
 *
 * The string must be encoded in UTF-8.
 */
static inline void
xdg_toplevel_set_title(struct xdg_toplevel *xdg_toplevel, const char *title)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_TITLE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, title);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Set an application identifier for the surface.
 *
 * The app ID identifies the general class of applications to which
 * the surface belongs. The compositor can use this to group multiple
 * surfaces together, or to determine how to launch a new application.
 *
 * For D-Bus activatable applications, the app ID is used as the D-Bus
 * service name.
 *
 * The compositor shell will try to group application surfaces together
 * by their app ID. As a best practice, it is suggested to select app
 * ID's that match the basename of the application's .desktop file.
 * For example, "org.freedesktop.FooViewer" where the .desktop file is
 * "org.freedesktop.FooViewer.desktop".
 *
 * Like other properties, a set_app_id request can be sent after the
 * xdg_toplevel has been mapped to update the property.
 *
 * See the desktop-entry specification [0] for more details on
 * application identifiers and how they relate to well-known D-Bus
 * names and .desktop files.
 *
 * [0] https://standards.freedesktop.org/desktop-entry-spec/
 */
static inline void
xdg_toplevel_set_app_id(struct xdg_toplevel *xdg_toplevel, const char *app_id)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_APP_ID, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, app_id);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Clients implementing client-side decorations might want to show
 * a context menu when right-clicking on the decorations, giving the
 * user a menu that they can use to maximize or minimize the window.
 *
 * This request asks the compositor to pop up such a window menu at
 * the given position, relative to the local surface coordinates of
 * the parent surface. There are no guarantees as to what menu items
 * the window menu contains, or even if a window menu will be drawn
 * at all.
 *
 * This request must be used in response to some sort of user action
 * like a button press, key press, or touch down event.
 */
static inline void
xdg_toplevel_show_window_menu(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial, int32_t x, int32_t y)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SHOW_WINDOW_MENU, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, seat, serial, x, y);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Start an interactive, user-driven move of the surface.
 *
 * This request must be used in response to some sort of user action
 * like a button press, key press, or touch down event. The passed
 * serial is used to determine the type of interactive move (touch,
 * pointer, etc).
 *
 * The server may ignore move requests depending on the state of
 * the surface (e.g. fullscreen or maximized), or if the passed serial
 * is no longer valid.
 *
 * If triggered, the surface will lose the focus of the device
 * (wl_pointer, wl_touch, etc) used for the move. It is up to the
 * compositor to visually indicate that the move is taking place, such as
 * updating a pointer cursor, during the move. There is no guarantee
 * that the device focus will return when the move is completed.
 */
static inline void
xdg_toplevel_move(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_MOVE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, seat, serial);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Start a user-driven, interactive resize of the surface.
 *
 * This request must be used in response to some sort of user action
 * like a button press, key press, or touch down event. The passed
 * serial is used to determine the type of interactive resize (touch,
 * pointer, etc).
 *
 * The server may ignore resize requests depending on the state of
 * the surface (e.g. fullscreen or maximized).
 *
 * If triggered, the client will receive configure events with the
 * "resize" state enum value and the expected sizes. See the "resize"
 * enum value for more details about what is required. The client
 * must also acknowledge configure events using "ack_configure". After
 * the resize is completed, the client will receive another "configure"
 * event without the resize state.
 *
 * If triggered, the surface also will lose the focus of the device
 * (wl_pointer, wl_touch, etc) used for the resize. It is up to the
 * compositor to visually indicate that the resize is taking place,
 * such as updating a pointer cursor, during the resize. There is no
 * guarantee that the device focus will return when the resize is
 * completed.
 *
 * The edges parameter specifies how the surface should be resized, and
 * is one of the values of the resize_edge enum. Values not matching
 * a variant of the enum will cause the invalid_resize_edge protocol error.
 * The compositor may use this information to update the surface position
 * for example when dragging the top left corner. The compositor may also
 * use this information to adapt its behavior, e.g. choose an appropriate
 * cursor image.
 */
static inline void
xdg_toplevel_resize(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial, uint32_t edges)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_RESIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, seat, serial, edges);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Set a maximum size for the window.
 *
 * The client can specify a maximum size so that the compositor does
 * not try to configure the window beyond this size.
 *
 * The width and height arguments are in window geometry coordinates.
 * See xdg_surface.set_window_geometry.
 *
 * Values set in this way are double-buffered, see wl_surface.commit.
 *
 * The compositor can use this information to allow or disallow
 * different states like maximize or fullscreen and draw accurate
 * animations.
 *
 * Similarly, a tiling window manager may use this information to
 * place and resize client windows in a more effective way.
 *
 * The client should not rely on the compositor to obey the maximum
 * size. The compositor may decide to ignore the values set by the
 * client and request a larger size.
 *
 * If never set, or a value of zero in the request, means that the
 * client has no expected maximum size in the given dimension.
 * As a result, a client wishing to reset the maximum size
 * to an unspecified state can use zero for width and height in the
 * request.
 *
 * Requesting a maximum size to be smaller than the minimum size of
 * a surface is illegal and will result in an invalid_size error.
 *
 * The width and height must be greater than or equal to zero. Using
 * strictly negative values for width or height will result in a
 * invalid_size error.
 */
static inline void
xdg_toplevel_set_max_size(struct xdg_toplevel *xdg_toplevel, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_MAX_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, width, height);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Set a minimum size for the window.
 *
 * The client can specify a minimum size so that the compositor does
 * not try to configure the window below this size.
 *
 * The width and height arguments are in window geometry coordinates.
 * See xdg_surface.set_window_geometry.
 *
 * Values set in this way are double-buffered, see wl_surface.commit.
 *
 * The compositor can use this information to allow or disallow
 * different states like maximize or fullscreen and draw accurate
 * animations.
 *
 * Similarly, a tiling window manager may use this information to
 * place and resize client windows in a more effective way.
 *
 * The client should not rely on the compositor to obey the minimum
 * size. The compositor may decide to ignore the values set by the
 * client and request a smaller size.
 *
 * If never set, or a value of zero in the request, means that the
 * client has no expected minimum size in the given dimension.
 * As a result, a client wishing to reset the minimum size
 * to an unspecified state can use zero for width and height in the
 * request.
 *
 * Requesting a minimum size to be larger than the maximum size of
 * a surface is illegal and will result in an invalid_size error.
 *
 * The width and height must be greater than or equal to zero. Using
 * strictly negative values for width and height will result in a
 * invalid_size error.
 */
static inline void
xdg_toplevel_set_min_size(struct xdg_toplevel *xdg_toplevel, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_MIN_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, width, height);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Maximize the surface.
 *
 * After requesting that the surface should be maximized, the compositor
 * will respond by emitting a configure event. Whether this configure
 * actually sets the window maximized is subject to compositor policies.
 * The client must then update its content, drawing in the configured
 * state. The client must also acknowledge the configure when committing
 * the new content (see ack_configure).
 *
 * It is up to the compositor to decide how and where to maximize the
 * surface, for example which output and what region of the screen should
 * be used.
 *
 * If the surface was already maximized, the compositor will still emit
 * a configure event with the "maximized" state.
 *
 * If the surface is in a fullscreen state, this request has no direct
 * effect. It may alter the state the surface is returned to when
 * unmaximized unless overridden by the compositor.
 */
static inline void
xdg_toplevel_set_maximized(struct xdg_toplevel *xdg_toplevel)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_MAXIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Unmaximize the surface.
 *
 * After requesting that the surface should be unmaximized, the compositor
 * will respond by emitting a configure event. Whether this actually
 * un-maximizes the window is subject to compositor policies.
 * If available and applicable, the compositor will include the window
 * geometry dimensions the window had prior to being maximized in the
 * configure event. The client must then update its content, drawing it in
 * the configured state. The client must also acknowledge the configure
 * when committing the new content (see ack_configure).
 *
 * It is up to the compositor to position the surface after it was
 * unmaximized; usually the position the surface had before maximizing, if
 * applicable.
 *
 * If the surface was already not maximized, the compositor will still
 * emit a configure event without the "maximized" state.
 *
 * If the surface is in a fullscreen state, this request has no direct
 * effect. It may alter the state the surface is returned to when
 * unmaximized unless overridden by the compositor.
 */
static inline void
xdg_toplevel_unset_maximized(struct xdg_toplevel *xdg_toplevel)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_UNSET_MAXIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Make the surface fullscreen.
 *
 * After requesting that the surface should be fullscreened, the
 * compositor will respond by emitting a configure event. Whether the
 * client is actually put into a fullscreen state is subject to compositor
 * policies. The client must also acknowledge the configure when
 * committing the new content (see ack_configure).
 *
 * The output passed by the request indicates the client's preference as
 * to which display it should be set fullscreen on. If this value is NULL,
 * it's up to the compositor to choose which display will be used to map
 * this surface.
 *
 * If the surface doesn't cover the whole output, the compositor will
 * position the surface in the center of the output and compensate with
 * with border fill covering the rest of the output. The content of the
 * border fill is undefined, but should be assumed to be in some way that
 * attempts to blend into the surrounding area (e.g. solid black).
 *
 * If the fullscreened surface is not opaque, the compositor must make
 * sure that other screen content not part of the same surface tree (made
 * up of subsurfaces, popups or similarly coupled surfaces) are not
 * visible below the fullscreened surface.
 */
static inline void
xdg_toplevel_set_fullscreen(struct xdg_toplevel *xdg_toplevel, struct wl_output *output)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_FULLSCREEN, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, output);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Make the surface no longer fullscreen.
 *
 * After requesting that the surface should be unfullscreened, the
 * compositor will respond by emitting a configure event.
 * Whether this actually removes the fullscreen state of the client is
 * subject to compositor policies.
 *
 * Making a surface unfullscreen sets states for the surface based on the following:
 * * the state(s) it may have had before becoming fullscreen
 * * any state(s) decided by the compositor
 * * any state(s) requested by the client while the surface was fullscreen
 *
 * The compositor may include the previous window geometry dimensions in
 * the configure event, if applicable.
 *
 * The client must also acknowledge the configure when committing the new
 * content (see ack_configure).
 */
static inline void
xdg_toplevel_unset_fullscreen(struct xdg_toplevel *xdg_toplevel)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_UNSET_FULLSCREEN, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Request that the compositor minimize your surface. There is no
 * way to know if the surface is currently minimized, nor is there
 * any way to unset minimization on this surface.
 *
 * If you are looking to throttle redrawing when minimized, please
 * instead use the wl_surface.frame event for this, as this will
 * also work with live previews on windows in Alt-Tab, Expose or
 * similar compositor features.
 */
static inline void
xdg_toplevel_set_minimized(struct xdg_toplevel *xdg_toplevel)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_MINIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
}

#ifndef XDG_POPUP_ERROR_ENUM
#define XDG_POPUP_ERROR_ENUM
enum xdg_popup_error {
	/**
	 * tried to grab after being mapped
	 */
	XDG_POPUP_ERROR_INVALID_GRAB = 0,
};
#endif /* XDG_POPUP_ERROR_ENUM */

/**
 * @ingroup iface_xdg_popup
 * @struct xdg_popup_listener
 */
struct xdg_popup_listener {
	/**
	 * configure the popup surface
	 *
	 * This event asks the popup surface to configure itself given
	 * the configuration. The configured state should not be applied
	 * immediately. See xdg_surface.configure for details.
	 *
	 * The x and y arguments represent the position the popup was
	 * placed at given the xdg_positioner rule, relative to the upper
	 * left corner of the window geometry of the parent surface.
	 *
	 * For version 2 or older, the configure event for an xdg_popup is
	 * only ever sent once for the initial configuration. Starting with
	 * version 3, it may be sent again if the popup is setup with an
	 * xdg_positioner with set_reactive requested, or in response to
	 * xdg_popup.reposition requests.
	 * @param x x position relative to parent surface window geometry
	 * @param y y position relative to parent surface window geometry
	 * @param width window geometry width
	 * @param height window geometry height
	 */
	void (*configure)(void *data,
			  struct xdg_popup *xdg_popup,
			  int32_t x,
			  int32_t y,
			  int32_t width,
			  int32_t height);
	/**
	 * popup interaction is done
	 *
	 * The popup_done event is sent out when a popup is dismissed by
	 * the compositor. The client should destroy the xdg_popup object
	 * at this point.
	 */
	void (*popup_done)(void *data,
			   struct xdg_popup *xdg_popup);
	/**
	 * signal the completion of a repositioned request
	 *
	 * The repositioned event is sent as part of a popup
	 * configuration sequence, together with xdg_popup.configure and
	 * lastly xdg_surface.configure to notify the completion of a
	 * reposition request.
	 *
	 * The repositioned event is to notify about the completion of a
	 * xdg_popup.reposition request. The token argument is the token
	 * passed in the xdg_popup.reposition request.
	 *
	 * Immediately after this event is emitted, xdg_popup.configure and
	 * xdg_surface.configure will be sent with the updated size and
	 * position, as well as a new configure serial.
	 *
	 * The client should optionally update the content of the popup,
	 * but must acknowledge the new popup configuration for the new
	 * position to take effect. See xdg_surface.ack_configure for
	 * details.
	 * @param token reposition request token
	 * @since 3
	 */
	void (*repositioned)(void *data,
			     struct xdg_popup *xdg_popup,
			     uint32_t token);
};

/**
 * @ingroup iface_xdg_popup
 */
static inline int
xdg_popup_add_listener(struct xdg_popup *xdg_popup,
		       const struct xdg_popup_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) xdg_popup,
				     (void (**)(void)) listener, data);
}

#define XDG_POPUP_DESTROY 0
#define XDG_POPUP_GRAB 1
#define XDG_POPUP_REPOSITION 2

/**
 * @ingroup iface_xdg_popup
 */
#define XDG_POPUP_CONFIGURE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_popup
 */
#define XDG_POPUP_POPUP_DONE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_popup
 */
#define XDG_POPUP_REPOSITIONED_SINCE_VERSION 3

/**
 * @ingroup iface_xdg_popup
 */
#define XDG_POPUP_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_popup
 */
#define XDG_POPUP_GRAB_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_popup
 */
#define XDG_POPUP_REPOSITION_SINCE_VERSION 3

/** @ingroup iface_xdg_popup */
static inline void
xdg_popup_set_user_data(struct xdg_popup *xdg_popup, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xdg_popup, user_data);
}

/** @ingroup iface_xdg_popup */
static inline void *
xdg_popup_get_user_data(struct xdg_popup *xdg_popup)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xdg_popup);
}

static inline uint32_t
xdg_popup_get_version(struct xdg_popup *xdg_popup)
{
	return wl_proxy_get_version((struct wl_proxy *) xdg_popup);
}

/**
 * @ingroup iface_xdg_popup
 *
 * This destroys the popup. Explicitly destroying the xdg_popup
 * object will also dismiss the popup, and unmap the surface.
 *
 * If this xdg_popup is not the "topmost" popup, the
 * xdg_wm_base.not_the_topmost_popup protocol error will be sent.
 */
static inline void
xdg_popup_destroy(struct xdg_popup *xdg_popup)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_popup,
			 XDG_POPUP_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_popup), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xdg_popup
 *
 * This request makes the created popup take an explicit grab. An explicit
 * grab will be dismissed when the user dismisses the popup, or when the
 * client destroys the xdg_popup. This can be done by the user clicking
 * outside the surface, using the keyboard, or even locking the screen
 * through closing the lid or a timeout.
 *
 * If the compositor denies the grab, the popup will be immediately
 * dismissed.
 *
 * This request must be used in response to some sort of user action like a
 * button press, key press, or touch down event. The serial number of the
 * event should be passed as 'serial'.
 *
 * The parent of a grabbing popup must either be an xdg_toplevel surface or
 * another xdg_popup with an explicit grab. If the parent is another
 * xdg_popup it means that the popups are nested, with this popup now being
 * the topmost popup.
 *
 * Nested popups must be destroyed in the reverse order they were created
 * in, e.g. the only popup you are allowed to destroy at all times is the
 * topmost one.
 *
 * When compositors choose to dismiss a popup, they may dismiss every
 * nested grabbing popup as well. When a compositor dismisses popups, it
 * will follow the same dismissing order as required from the client.
 *
 * If the topmost grabbing popup is destroyed, the grab will be returned to
 * the parent of the popup, if that parent previously had an explicit grab.
 *
 * If the parent is a grabbing popup which has already been dismissed, this
 * popup will be immediately dismissed. If the parent is a popup that did
 * not take an explicit grab, an error will be raised.
 *
 * During a popup grab, the client owning the grab will receive pointer
 * and touch events for all their surfaces as normal (similar to an
 * "owner-events" grab in X11 parlance), while the top most grabbing popup
 * will always have keyboard focus.
 */
static inline void
xdg_popup_grab(struct xdg_popup *xdg_popup, struct wl_seat *seat, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_popup,
			 XDG_POPUP_GRAB, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_popup), 0, seat, serial);
}

/**
 * @ingroup iface_xdg_popup
 *
 * Reposition an already-mapped popup. The popup will be placed given the
 * details in the passed xdg_positioner object, and a
 * xdg_popup.repositioned followed by xdg_popup.configure and
 * xdg_surface.configure will be emitted in response. Any parameters set
 * by the previous positioner will be discarded.
 *
 * The passed token will be sent in the corresponding
 * xdg_popup.repositioned event. The new popup position will not take
 * effect until the corresponding configure event is acknowledged by the
 * client. See xdg_popup.repositioned for details. The token itself is
 * opaque, and has no other special meaning.
 *
 * If multiple reposition requests are sent, the compositor may skip all
 * but the last one.
 *
 * If the popup is repositioned in response to a configure event for its
 * parent, the client should send an xdg_positioner.set_parent_configure
 * and possibly an xdg_positioner.set_parent_size request to allow the
 * compositor to properly constrain the popup.
 *
 * If the popup is repositioned together with a parent that is being
 * resized, but not in response to a configure event, the client should
 * send an xdg_positioner.set_parent_size request.
 */
static inline void
xdg_popup_reposition(struct xdg_popup *xdg_popup, struct xdg_positioner *positioner, uint32_t token)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_popup,
			 XDG_POPUP_REPOSITION, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_popup), 0, positioner, token);
}

#ifdef  __cplusplus
}
#endif

#endif
/* Generated by wayland-scanner 1.23.1 */

/*
 * Copyright © 2008-2013 Kristian Høgsberg
 * Copyright © 2013      Rafael Antognolli
 * Copyright © 2013      Jasper St. Pierre
 * Copyright © 2010-2013 Intel Corporation
 * Copyright © 2015-2017 Samsung Electronics Co., Ltd
 * Copyright © 2015-2017 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <stdbool.h>
#include <stdlib.h>
#include <stdint.h>
#include "wayland-util.h"

#ifndef __has_attribute
# define __has_attribute(x) 0  /* Compatibility with non-clang compilers. */
#endif

#if (__has_attribute(visibility) || defined(__GNUC__) && __GNUC__ >= 4)
#define WL_PRIVATE __attribute__ ((visibility("hidden")))
#else
#define WL_PRIVATE
#endif

extern const struct wl_interface wl_output_interface;
extern const struct wl_interface wl_seat_interface;
extern const struct wl_interface wl_surface_interface;
extern const struct wl_interface xdg_popup_interface;
extern const struct wl_interface xdg_positioner_interface;
extern const struct wl_interface xdg_surface_interface;
extern const struct wl_interface xdg_toplevel_interface;

static const struct wl_interface *xdg_shell_types[] = {
	NULL,
	NULL,
	NULL,
	NULL,
	&xdg_positioner_interface,
	&xdg_surface_interface,
	&wl_surface_interface,
	&xdg_toplevel_interface,
	&xdg_popup_interface,
	&xdg_surface_interface,
	&xdg_positioner_interface,
	&xdg_toplevel_interface,
	&wl_seat_interface,
	NULL,
	NULL,
	NULL,
	&wl_seat_interface,
	NULL,
	&wl_seat_interface,
	NULL,
	NULL,
	&wl_output_interface,
	&wl_seat_interface,
	NULL,
	&xdg_positioner_interface,
	NULL,
};

static const struct wl_message xdg_wm_base_requests[] = {
	{ "destroy", "", xdg_shell_types + 0 },
	{ "create_positioner", "n", xdg_shell_types + 4 },
	{ "get_xdg_surface", "no", xdg_shell_types + 5 },
	{ "pong", "u", xdg_shell_types + 0 },
};

static const struct wl_message xdg_wm_base_events[] = {
	{ "ping", "u", xdg_shell_types + 0 },
};

WL_PRIVATE const struct wl_interface xdg_wm_base_interface = {
	"xdg_wm_base", 6,
	4, xdg_wm_base_requests,
	1, xdg_wm_base_events,
};

static const struct wl_message xdg_positioner_requests[] = {
	{ "destroy", "", xdg_shell_types + 0 },
	{ "set_size", "ii", xdg_shell_types + 0 },
	{ "set_anchor_rect", "iiii", xdg_shell_types + 0 },
	{ "set_anchor", "u", xdg_shell_types + 0 },
	{ "set_gravity", "u", xdg_shell_types + 0 },
	{ "set_constraint_adjustment", "u", xdg_shell_types + 0 },
	{ "set_offset", "ii", xdg_shell_types + 0 },
	{ "set_reactive", "3", xdg_shell_types + 0 },
	{ "set_parent_size", "3ii", xdg_shell_types + 0 },
	{ "set_parent_configure", "3u", xdg_shell_types + 0 },
};

WL_PRIVATE const struct wl_interface xdg_positioner_interface = {
	"xdg_positioner", 6,
	10, xdg_positioner_requests,
	0, NULL,
};

static const struct wl_message xdg_surface_requests[] = {
	{ "destroy", "", xdg_shell_types + 0 },
	{ "get_toplevel", "n", xdg_shell_types + 7 },
	{ "get_popup", "n?oo", xdg_shell_types + 8 },
	{ "set_window_geometry", "iiii", xdg_shell_types + 0 },
	{ "ack_configure", "u", xdg_shell_types + 0 },
};

static const struct wl_message xdg_surface_events[] = {
	{ "configure", "u", xdg_shell_types + 0 },
};

WL_PRIVATE const struct wl_interface xdg_surface_interface = {
	"xdg_surface", 6,
	5, xdg_surface_requests,
	1, xdg_surface_events,
};

static const struct wl_message xdg_toplevel_requests[] = {
	{ "destroy", "", xdg_shell_types + 0 },
	{ "set_parent", "?o", xdg_shell_types + 11 },
	{ "set_title", "s", xdg_shell_types + 0 },
	{ "set_app_id", "s", xdg_shell_types + 0 },
	{ "show_window_menu", "ouii", xdg_shell_types + 12 },
	{ "move", "ou", xdg_shell_types + 16 },
	{ "resize", "ouu", xdg_shell_types + 18 },
	{ "set_max_size", "ii", xdg_shell_types + 0 },
	{ "set_min_size", "ii", xdg_shell_types + 0 },
	{ "set_maximized", "", xdg_shell_types + 0 },
	{ "unset_maximized", "", xdg_shell_types + 0 },
	{ "set_fullscreen", "?o", xdg_shell_types + 21 },
	{ "unset_fullscreen", "", xdg_shell_types + 0 },
	{ "set_minimized", "", xdg_shell_types + 0 },
};

static const struct wl_message xdg_toplevel_events[] = {
	{ "configure", "iia", xdg_shell_types + 0 },
	{ "close", "", xdg_shell_types + 0 },
	{ "configure_bounds", "4ii", xdg_shell_types + 0 },
	{ "wm_capabilities", "5a", xdg_shell_types + 0 },
};

WL_PRIVATE const struct wl_interface xdg_toplevel_interface = {
	"xdg_toplevel", 6,
	14, xdg_toplevel_requests,
	4, xdg_toplevel_events,
};

static const struct wl_message xdg_popup_requests[] = {
	{ "destroy", "", xdg_shell_types + 0 },
	{ "grab", "ou", xdg_shell_types + 22 },
	{ "reposition", "3ou", xdg_shell_types + 24 },
};

static const struct wl_message xdg_popup_events[] = {
	{ "configure", "iiii", xdg_shell_types + 0 },
	{ "popup_done", "", xdg_shell_types + 0 },
	{ "repositioned", "3u", xdg_shell_types + 0 },
};

WL_PRIVATE const struct wl_interface xdg_popup_interface = {
	"xdg_popup", 6,
	3, xdg_popup_requests,
	3, xdg_popup_events,
};

/* Generated by wayland-scanner 1.23.1 */

#ifndef CURSOR_SHAPE_V1_CLIENT_PROTOCOL_H
#define CURSOR_SHAPE_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_cursor_shape_v1 The cursor_shape_v1 protocol
 * @section page_ifaces_cursor_shape_v1 Interfaces
 * - @subpage page_iface_wp_cursor_shape_manager_v1 - cursor shape manager
 * - @subpage page_iface_wp_cursor_shape_device_v1 - cursor shape for a device
 * @section page_copyright_cursor_shape_v1 Copyright
 * <pre>
 *
 * Copyright 2018 The Chromium Authors
 * Copyright 2023 Simon Ser
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct wl_pointer;
struct wp_cursor_shape_device_v1;
struct wp_cursor_shape_manager_v1;
struct zwp_tablet_tool_v2;

#ifndef WP_CURSOR_SHAPE_MANAGER_V1_INTERFACE
#define WP_CURSOR_SHAPE_MANAGER_V1_INTERFACE
/**
 * @page page_iface_wp_cursor_shape_manager_v1 wp_cursor_shape_manager_v1
 * @section page_iface_wp_cursor_shape_manager_v1_desc Description
 *
 * This global offers an alternative, optional way to set cursor images. This
 * new way uses enumerated cursors instead of a wl_surface like
 * wl_pointer.set_cursor does.
 *
 * Warning! The protocol described in this file is currently in the testing
 * phase. Backward compatible changes may be added together with the
 * corresponding interface version bump. Backward incompatible changes can
 * only be done by creating a new major version of the extension.
 * @section page_iface_wp_cursor_shape_manager_v1_api API
 * See @ref iface_wp_cursor_shape_manager_v1.
 */
/**
 * @defgroup iface_wp_cursor_shape_manager_v1 The wp_cursor_shape_manager_v1 interface
 *
 * This global offers an alternative, optional way to set cursor images. This
 * new way uses enumerated cursors instead of a wl_surface like
 * wl_pointer.set_cursor does.
 *
 * Warning! The protocol described in this file is currently in the testing
 * phase. Backward compatible changes may be added together with the
 * corresponding interface version bump. Backward incompatible changes can
 * only be done by creating a new major version of the extension.
 */
extern const struct wl_interface wp_cursor_shape_manager_v1_interface;
#endif
#ifndef WP_CURSOR_SHAPE_DEVICE_V1_INTERFACE
#define WP_CURSOR_SHAPE_DEVICE_V1_INTERFACE
/**
 * @page page_iface_wp_cursor_shape_device_v1 wp_cursor_shape_device_v1
 * @section page_iface_wp_cursor_shape_device_v1_desc Description
 *
 * This interface allows clients to set the cursor shape.
 * @section page_iface_wp_cursor_shape_device_v1_api API
 * See @ref iface_wp_cursor_shape_device_v1.
 */
/**
 * @defgroup iface_wp_cursor_shape_device_v1 The wp_cursor_shape_device_v1 interface
 *
 * This interface allows clients to set the cursor shape.
 */
extern const struct wl_interface wp_cursor_shape_device_v1_interface;
#endif

#define WP_CURSOR_SHAPE_MANAGER_V1_DESTROY 0
#define WP_CURSOR_SHAPE_MANAGER_V1_GET_POINTER 1
#define WP_CURSOR_SHAPE_MANAGER_V1_GET_TABLET_TOOL_V2 2


/**
 * @ingroup iface_wp_cursor_shape_manager_v1
 */
#define WP_CURSOR_SHAPE_MANAGER_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_wp_cursor_shape_manager_v1
 */
#define WP_CURSOR_SHAPE_MANAGER_V1_GET_POINTER_SINCE_VERSION 1
/**
 * @ingroup iface_wp_cursor_shape_manager_v1
 */
#define WP_CURSOR_SHAPE_MANAGER_V1_GET_TABLET_TOOL_V2_SINCE_VERSION 1

/** @ingroup iface_wp_cursor_shape_manager_v1 */
static inline void
wp_cursor_shape_manager_v1_set_user_data(struct wp_cursor_shape_manager_v1 *wp_cursor_shape_manager_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wp_cursor_shape_manager_v1, user_data);
}

/** @ingroup iface_wp_cursor_shape_manager_v1 */
static inline void *
wp_cursor_shape_manager_v1_get_user_data(struct wp_cursor_shape_manager_v1 *wp_cursor_shape_manager_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wp_cursor_shape_manager_v1);
}

static inline uint32_t
wp_cursor_shape_manager_v1_get_version(struct wp_cursor_shape_manager_v1 *wp_cursor_shape_manager_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) wp_cursor_shape_manager_v1);
}

/**
 * @ingroup iface_wp_cursor_shape_manager_v1
 *
 * Destroy the cursor shape manager.
 */
static inline void
wp_cursor_shape_manager_v1_destroy(struct wp_cursor_shape_manager_v1 *wp_cursor_shape_manager_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wp_cursor_shape_manager_v1,
			 WP_CURSOR_SHAPE_MANAGER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) wp_cursor_shape_manager_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_wp_cursor_shape_manager_v1
 *
 * Obtain a wp_cursor_shape_device_v1 for a wl_pointer object.
 *
 * When the pointer capability is removed from the wl_seat, the
 * wp_cursor_shape_device_v1 object becomes inert.
 */
static inline struct wp_cursor_shape_device_v1 *
wp_cursor_shape_manager_v1_get_pointer(struct wp_cursor_shape_manager_v1 *wp_cursor_shape_manager_v1, struct wl_pointer *pointer)
{
	struct wl_proxy *cursor_shape_device;

	cursor_shape_device = wl_proxy_marshal_flags((struct wl_proxy *) wp_cursor_shape_manager_v1,
			 WP_CURSOR_SHAPE_MANAGER_V1_GET_POINTER, &wp_cursor_shape_device_v1_interface, wl_proxy_get_version((struct wl_proxy *) wp_cursor_shape_manager_v1), 0, NULL, pointer);

	return (struct wp_cursor_shape_device_v1 *) cursor_shape_device;
}

/**
 * @ingroup iface_wp_cursor_shape_manager_v1
 *
 * Obtain a wp_cursor_shape_device_v1 for a zwp_tablet_tool_v2 object.
 *
 * When the zwp_tablet_tool_v2 is removed, the wp_cursor_shape_device_v1
 * object becomes inert.
 */
static inline struct wp_cursor_shape_device_v1 *
wp_cursor_shape_manager_v1_get_tablet_tool_v2(struct wp_cursor_shape_manager_v1 *wp_cursor_shape_manager_v1, struct zwp_tablet_tool_v2 *tablet_tool)
{
	struct wl_proxy *cursor_shape_device;

	cursor_shape_device = wl_proxy_marshal_flags((struct wl_proxy *) wp_cursor_shape_manager_v1,
			 WP_CURSOR_SHAPE_MANAGER_V1_GET_TABLET_TOOL_V2, &wp_cursor_shape_device_v1_interface, wl_proxy_get_version((struct wl_proxy *) wp_cursor_shape_manager_v1), 0, NULL, tablet_tool);

	return (struct wp_cursor_shape_device_v1 *) cursor_shape_device;
}

#ifndef WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ENUM
#define WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ENUM
/**
 * @ingroup iface_wp_cursor_shape_device_v1
 * cursor shapes
 *
 * This enum describes cursor shapes.
 *
 * The names are taken from the CSS W3C specification:
 * https://w3c.github.io/csswg-drafts/css-ui/#cursor
 */
enum wp_cursor_shape_device_v1_shape {
	/**
	 * default cursor
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DEFAULT = 1,
	/**
	 * a context menu is available for the object under the cursor
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_CONTEXT_MENU = 2,
	/**
	 * help is available for the object under the cursor
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_HELP = 3,
	/**
	 * pointer that indicates a link or another interactive element
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_POINTER = 4,
	/**
	 * progress indicator
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_PROGRESS = 5,
	/**
	 * program is busy, user should wait
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_WAIT = 6,
	/**
	 * a cell or set of cells may be selected
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_CELL = 7,
	/**
	 * simple crosshair
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_CROSSHAIR = 8,
	/**
	 * text may be selected
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_TEXT = 9,
	/**
	 * vertical text may be selected
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_VERTICAL_TEXT = 10,
	/**
	 * drag-and-drop: alias of/shortcut to something is to be created
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALIAS = 11,
	/**
	 * drag-and-drop: something is to be copied
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COPY = 12,
	/**
	 * drag-and-drop: something is to be moved
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_MOVE = 13,
	/**
	 * drag-and-drop: the dragged item cannot be dropped at the current cursor location
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NO_DROP = 14,
	/**
	 * drag-and-drop: the requested action will not be carried out
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NOT_ALLOWED = 15,
	/**
	 * drag-and-drop: something can be grabbed
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_GRAB = 16,
	/**
	 * drag-and-drop: something is being grabbed
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_GRABBING = 17,
	/**
	 * resizing: the east border is to be moved
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_E_RESIZE = 18,
	/**
	 * resizing: the north border is to be moved
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_N_RESIZE = 19,
	/**
	 * resizing: the north-east corner is to be moved
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NE_RESIZE = 20,
	/**
	 * resizing: the north-west corner is to be moved
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NW_RESIZE = 21,
	/**
	 * resizing: the south border is to be moved
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_S_RESIZE = 22,
	/**
	 * resizing: the south-east corner is to be moved
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_SE_RESIZE = 23,
	/**
	 * resizing: the south-west corner is to be moved
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_SW_RESIZE = 24,
	/**
	 * resizing: the west border is to be moved
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_W_RESIZE = 25,
	/**
	 * resizing: the east and west borders are to be moved
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_EW_RESIZE = 26,
	/**
	 * resizing: the north and south borders are to be moved
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NS_RESIZE = 27,
	/**
	 * resizing: the north-east and south-west corners are to be moved
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NESW_RESIZE = 28,
	/**
	 * resizing: the north-west and south-east corners are to be moved
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NWSE_RESIZE = 29,
	/**
	 * resizing: that the item/column can be resized horizontally
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COL_RESIZE = 30,
	/**
	 * resizing: that the item/row can be resized vertically
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ROW_RESIZE = 31,
	/**
	 * something can be scrolled in any direction
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALL_SCROLL = 32,
	/**
	 * something can be zoomed in
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ZOOM_IN = 33,
	/**
	 * something can be zoomed out
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ZOOM_OUT = 34,
};
#endif /* WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ENUM */

#ifndef WP_CURSOR_SHAPE_DEVICE_V1_ERROR_ENUM
#define WP_CURSOR_SHAPE_DEVICE_V1_ERROR_ENUM
enum wp_cursor_shape_device_v1_error {
	/**
	 * the specified shape value is invalid
	 */
	WP_CURSOR_SHAPE_DEVICE_V1_ERROR_INVALID_SHAPE = 1,
};
#endif /* WP_CURSOR_SHAPE_DEVICE_V1_ERROR_ENUM */

#define WP_CURSOR_SHAPE_DEVICE_V1_DESTROY 0
#define WP_CURSOR_SHAPE_DEVICE_V1_SET_SHAPE 1


/**
 * @ingroup iface_wp_cursor_shape_device_v1
 */
#define WP_CURSOR_SHAPE_DEVICE_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_wp_cursor_shape_device_v1
 */
#define WP_CURSOR_SHAPE_DEVICE_V1_SET_SHAPE_SINCE_VERSION 1

/** @ingroup iface_wp_cursor_shape_device_v1 */
static inline void
wp_cursor_shape_device_v1_set_user_data(struct wp_cursor_shape_device_v1 *wp_cursor_shape_device_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wp_cursor_shape_device_v1, user_data);
}

/** @ingroup iface_wp_cursor_shape_device_v1 */
static inline void *
wp_cursor_shape_device_v1_get_user_data(struct wp_cursor_shape_device_v1 *wp_cursor_shape_device_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wp_cursor_shape_device_v1);
}

static inline uint32_t
wp_cursor_shape_device_v1_get_version(struct wp_cursor_shape_device_v1 *wp_cursor_shape_device_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) wp_cursor_shape_device_v1);
}

/**
 * @ingroup iface_wp_cursor_shape_device_v1
 *
 * Destroy the cursor shape device.
 *
 * The device cursor shape remains unchanged.
 */
static inline void
wp_cursor_shape_device_v1_destroy(struct wp_cursor_shape_device_v1 *wp_cursor_shape_device_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wp_cursor_shape_device_v1,
			 WP_CURSOR_SHAPE_DEVICE_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) wp_cursor_shape_device_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_wp_cursor_shape_device_v1
 *
 * Sets the device cursor to the specified shape. The compositor will
 * change the cursor image based on the specified shape.
 *
 * The cursor actually changes only if the input device focus is one of
 * the requesting client's surfaces. If any, the previous cursor image
 * (surface or shape) is replaced.
 *
 * The "shape" argument must be a valid enum entry, otherwise the
 * invalid_shape protocol error is raised.
 *
 * This is similar to the wl_pointer.set_cursor and
 * zwp_tablet_tool_v2.set_cursor requests, but this request accepts a
 * shape instead of contents in the form of a surface. Clients can mix
 * set_cursor and set_shape requests.
 *
 * The serial parameter must match the latest wl_pointer.enter or
 * zwp_tablet_tool_v2.proximity_in serial number sent to the client.
 * Otherwise the request will be ignored.
 */
static inline void
wp_cursor_shape_device_v1_set_shape(struct wp_cursor_shape_device_v1 *wp_cursor_shape_device_v1, uint32_t serial, uint32_t shape)
{
	wl_proxy_marshal_flags((struct wl_proxy *) wp_cursor_shape_device_v1,
			 WP_CURSOR_SHAPE_DEVICE_V1_SET_SHAPE, NULL, wl_proxy_get_version((struct wl_proxy *) wp_cursor_shape_device_v1), 0, serial, shape);
}

#ifdef  __cplusplus
}
#endif

#endif
/* Generated by wayland-scanner 1.23.1 */

/*
 * Copyright 2018 The Chromium Authors
 * Copyright 2023 Simon Ser
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <stdbool.h>
#include <stdlib.h>
#include <stdint.h>
#include "wayland-util.h"

#ifndef __has_attribute
# define __has_attribute(x) 0  /* Compatibility with non-clang compilers. */
#endif

#if (__has_attribute(visibility) || defined(__GNUC__) && __GNUC__ >= 4)
#define WL_PRIVATE __attribute__ ((visibility("hidden")))
#else
#define WL_PRIVATE
#endif

extern const struct wl_interface wl_pointer_interface;
extern const struct wl_interface wp_cursor_shape_device_v1_interface;
extern const struct wl_interface zwp_tablet_tool_v2_interface;

static const struct wl_interface *cursor_shape_v1_types[] = {
	NULL,
	NULL,
	&wp_cursor_shape_device_v1_interface,
	&wl_pointer_interface,
	&wp_cursor_shape_device_v1_interface,
	&zwp_tablet_tool_v2_interface,
};

static const struct wl_message wp_cursor_shape_manager_v1_requests[] = {
	{ "destroy", "", cursor_shape_v1_types + 0 },
	{ "get_pointer", "no", cursor_shape_v1_types + 2 },
	{ "get_tablet_tool_v2", "no", cursor_shape_v1_types + 4 },
};

WL_PRIVATE const struct wl_interface wp_cursor_shape_manager_v1_interface = {
	"wp_cursor_shape_manager_v1", 1,
	3, wp_cursor_shape_manager_v1_requests,
	0, NULL,
};

static const struct wl_message wp_cursor_shape_device_v1_requests[] = {
	{ "destroy", "", cursor_shape_v1_types + 0 },
	{ "set_shape", "uu", cursor_shape_v1_types + 0 },
};

WL_PRIVATE const struct wl_interface wp_cursor_shape_device_v1_interface = {
	"wp_cursor_shape_device_v1", 1,
	2, wp_cursor_shape_device_v1_requests,
	0, NULL,
};

/* Generated by wayland-scanner 1.23.1 */

#ifndef XDG_DECORATION_UNSTABLE_V1_CLIENT_PROTOCOL_H
#define XDG_DECORATION_UNSTABLE_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_xdg_decoration_unstable_v1 The xdg_decoration_unstable_v1 protocol
 * @section page_ifaces_xdg_decoration_unstable_v1 Interfaces
 * - @subpage page_iface_zxdg_decoration_manager_v1 - window decoration manager
 * - @subpage page_iface_zxdg_toplevel_decoration_v1 - decoration object for a toplevel surface
 * @section page_copyright_xdg_decoration_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2018 Simon Ser
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct xdg_toplevel;
struct zxdg_decoration_manager_v1;
struct zxdg_toplevel_decoration_v1;

#ifndef ZXDG_DECORATION_MANAGER_V1_INTERFACE
#define ZXDG_DECORATION_MANAGER_V1_INTERFACE
/**
 * @page page_iface_zxdg_decoration_manager_v1 zxdg_decoration_manager_v1
 * @section page_iface_zxdg_decoration_manager_v1_desc Description
 *
 * This interface allows a compositor to announce support for server-side
 * decorations.
 *
 * A window decoration is a set of window controls as deemed appropriate by
 * the party managing them, such as user interface components used to move,
 * resize and change a window's state.
 *
 * A client can use this protocol to request being decorated by a supporting
 * compositor.
 *
 * If compositor and client do not negotiate the use of a server-side
 * decoration using this protocol, clients continue to self-decorate as they
 * see fit.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 * @section page_iface_zxdg_decoration_manager_v1_api API
 * See @ref iface_zxdg_decoration_manager_v1.
 */
/**
 * @defgroup iface_zxdg_decoration_manager_v1 The zxdg_decoration_manager_v1 interface
 *
 * This interface allows a compositor to announce support for server-side
 * decorations.
 *
 * A window decoration is a set of window controls as deemed appropriate by
 * the party managing them, such as user interface components used to move,
 * resize and change a window's state.
 *
 * A client can use this protocol to request being decorated by a supporting
 * compositor.
 *
 * If compositor and client do not negotiate the use of a server-side
 * decoration using this protocol, clients continue to self-decorate as they
 * see fit.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 */
extern const struct wl_interface zxdg_decoration_manager_v1_interface;
#endif
#ifndef ZXDG_TOPLEVEL_DECORATION_V1_INTERFACE
#define ZXDG_TOPLEVEL_DECORATION_V1_INTERFACE
/**
 * @page page_iface_zxdg_toplevel_decoration_v1 zxdg_toplevel_decoration_v1
 * @section page_iface_zxdg_toplevel_decoration_v1_desc Description
 *
 * The decoration object allows the compositor to toggle server-side window
 * decorations for a toplevel surface. The client can request to switch to
 * another mode.
 *
 * The xdg_toplevel_decoration object must be destroyed before its
 * xdg_toplevel.
 * @section page_iface_zxdg_toplevel_decoration_v1_api API
 * See @ref iface_zxdg_toplevel_decoration_v1.
 */
/**
 * @defgroup iface_zxdg_toplevel_decoration_v1 The zxdg_toplevel_decoration_v1 interface
 *
 * The decoration object allows the compositor to toggle server-side window
 * decorations for a toplevel surface. The client can request to switch to
 * another mode.
 *
 * The xdg_toplevel_decoration object must be destroyed before its
 * xdg_toplevel.
 */
extern const struct wl_interface zxdg_toplevel_decoration_v1_interface;
#endif

#define ZXDG_DECORATION_MANAGER_V1_DESTROY 0
#define ZXDG_DECORATION_MANAGER_V1_GET_TOPLEVEL_DECORATION 1


/**
 * @ingroup iface_zxdg_decoration_manager_v1
 */
#define ZXDG_DECORATION_MANAGER_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_zxdg_decoration_manager_v1
 */
#define ZXDG_DECORATION_MANAGER_V1_GET_TOPLEVEL_DECORATION_SINCE_VERSION 1

/** @ingroup iface_zxdg_decoration_manager_v1 */
static inline void
zxdg_decoration_manager_v1_set_user_data(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zxdg_decoration_manager_v1, user_data);
}

/** @ingroup iface_zxdg_decoration_manager_v1 */
static inline void *
zxdg_decoration_manager_v1_get_user_data(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_decoration_manager_v1);
}

static inline uint32_t
zxdg_decoration_manager_v1_get_version(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zxdg_decoration_manager_v1);
}

/**
 * @ingroup iface_zxdg_decoration_manager_v1
 *
 * Destroy the decoration manager. This doesn't destroy objects created
 * with the manager.
 */
static inline void
zxdg_decoration_manager_v1_destroy(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zxdg_decoration_manager_v1,
			 ZXDG_DECORATION_MANAGER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zxdg_decoration_manager_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_zxdg_decoration_manager_v1
 *
 * Create a new decoration object associated with the given toplevel.
 *
 * Creating an xdg_toplevel_decoration from an xdg_toplevel which has a
 * buffer attached or committed is a client error, and any attempts by a
 * client to attach or manipulate a buffer prior to the first
 * xdg_toplevel_decoration.configure event must also be treated as
 * errors.
 */
static inline struct zxdg_toplevel_decoration_v1 *
zxdg_decoration_manager_v1_get_toplevel_decoration(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1, struct xdg_toplevel *toplevel)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) zxdg_decoration_manager_v1,
			 ZXDG_DECORATION_MANAGER_V1_GET_TOPLEVEL_DECORATION, &zxdg_toplevel_decoration_v1_interface, wl_proxy_get_version((struct wl_proxy *) zxdg_decoration_manager_v1), 0, NULL, toplevel);

	return (struct zxdg_toplevel_decoration_v1 *) id;
}

#ifndef ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ENUM
#define ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ENUM
enum zxdg_toplevel_decoration_v1_error {
	/**
	 * xdg_toplevel has a buffer attached before configure
	 */
	ZXDG_TOPLEVEL_DECORATION_V1_ERROR_UNCONFIGURED_BUFFER = 0,
	/**
	 * xdg_toplevel already has a decoration object
	 */
	ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ALREADY_CONSTRUCTED = 1,
	/**
	 * xdg_toplevel destroyed before the decoration object
	 */
	ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ORPHANED = 2,
	/**
	 * invalid mode
	 */
	ZXDG_TOPLEVEL_DECORATION_V1_ERROR_INVALID_MODE = 3,
};
#endif /* ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ENUM */

#ifndef ZXDG_TOPLEVEL_DECORATION_V1_MODE_ENUM
#define ZXDG_TOPLEVEL_DECORATION_V1_MODE_ENUM
/**
 * @ingroup iface_zxdg_toplevel_decoration_v1
 * window decoration modes
 *
 * These values describe window decoration modes.
 */
enum zxdg_toplevel_decoration_v1_mode {
	/**
	 * no server-side window decoration
	 */
	ZXDG_TOPLEVEL_DECORATION_V1_MODE_CLIENT_SIDE = 1,
	/**
	 * server-side window decoration
	 */
	ZXDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE = 2,
};
#endif /* ZXDG_TOPLEVEL_DECORATION_V1_MODE_ENUM */

/**
 * @ingroup iface_zxdg_toplevel_decoration_v1
 * @struct zxdg_toplevel_decoration_v1_listener
 */
struct zxdg_toplevel_decoration_v1_listener {
	/**
	 * notify a decoration mode change
	 *
	 * The configure event configures the effective decoration mode.
	 * The configured state should not be applied immediately. Clients
	 * must send an ack_configure in response to this event. See
	 * xdg_surface.configure and xdg_surface.ack_configure for details.
	 *
	 * A configure event can be sent at any time. The specified mode
	 * must be obeyed by the client.
	 * @param mode the decoration mode
	 */
	void (*configure)(void *data,
			  struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1,
			  uint32_t mode);
};

/**
 * @ingroup iface_zxdg_toplevel_decoration_v1
 */
static inline int
zxdg_toplevel_decoration_v1_add_listener(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1,
					 const struct zxdg_toplevel_decoration_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zxdg_toplevel_decoration_v1,
				     (void (**)(void)) listener, data);
}

#define ZXDG_TOPLEVEL_DECORATION_V1_DESTROY 0
#define ZXDG_TOPLEVEL_DECORATION_V1_SET_MODE 1
#define ZXDG_TOPLEVEL_DECORATION_V1_UNSET_MODE 2

/**
 * @ingroup iface_zxdg_toplevel_decoration_v1
 */
#define ZXDG_TOPLEVEL_DECORATION_V1_CONFIGURE_SINCE_VERSION 1

/**
 * @ingroup iface_zxdg_toplevel_decoration_v1
 */
#define ZXDG_TOPLEVEL_DECORATION_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_zxdg_toplevel_decoration_v1
 */
#define ZXDG_TOPLEVEL_DECORATION_V1_SET_MODE_SINCE_VERSION 1
/**
 * @ingroup iface_zxdg_toplevel_decoration_v1
 */
#define ZXDG_TOPLEVEL_DECORATION_V1_UNSET_MODE_SINCE_VERSION 1

/** @ingroup iface_zxdg_toplevel_decoration_v1 */
static inline void
zxdg_toplevel_decoration_v1_set_user_data(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zxdg_toplevel_decoration_v1, user_data);
}

/** @ingroup iface_zxdg_toplevel_decoration_v1 */
static inline void *
zxdg_toplevel_decoration_v1_get_user_data(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_toplevel_decoration_v1);
}

static inline uint32_t
zxdg_toplevel_decoration_v1_get_version(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zxdg_toplevel_decoration_v1);
}

/**
 * @ingroup iface_zxdg_toplevel_decoration_v1
 *
 * Switch back to a mode without any server-side decorations at the next
 * commit.
 */
static inline void
zxdg_toplevel_decoration_v1_destroy(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zxdg_toplevel_decoration_v1,
			 ZXDG_TOPLEVEL_DECORATION_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zxdg_toplevel_decoration_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_zxdg_toplevel_decoration_v1
 *
 * Set the toplevel surface decoration mode. This informs the compositor
 * that the client prefers the provided decoration mode.
 *
 * After requesting a decoration mode, the compositor will respond by
 * emitting an xdg_surface.configure event. The client should then update
 * its content, drawing it without decorations if the received mode is
 * server-side decorations. The client must also acknowledge the configure
 * when committing the new content (see xdg_surface.ack_configure).
 *
 * The compositor can decide not to use the client's mode and enforce a
 * different mode instead.
 *
 * Clients whose decoration mode depend on the xdg_toplevel state may send
 * a set_mode request in response to an xdg_surface.configure event and wait
 * for the next xdg_surface.configure event to prevent unwanted state.
 * Such clients are responsible for preventing configure loops and must
 * make sure not to send multiple successive set_mode requests with the
 * same decoration mode.
 *
 * If an invalid mode is supplied by the client, the invalid_mode protocol
 * error is raised by the compositor.
 */
static inline void
zxdg_toplevel_decoration_v1_set_mode(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1, uint32_t mode)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zxdg_toplevel_decoration_v1,
			 ZXDG_TOPLEVEL_DECORATION_V1_SET_MODE, NULL, wl_proxy_get_version((struct wl_proxy *) zxdg_toplevel_decoration_v1), 0, mode);
}

/**
 * @ingroup iface_zxdg_toplevel_decoration_v1
 *
 * Unset the toplevel surface decoration mode. This informs the compositor
 * that the client doesn't prefer a particular decoration mode.
 *
 * This request has the same semantics as set_mode.
 */
static inline void
zxdg_toplevel_decoration_v1_unset_mode(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zxdg_toplevel_decoration_v1,
			 ZXDG_TOPLEVEL_DECORATION_V1_UNSET_MODE, NULL, wl_proxy_get_version((struct wl_proxy *) zxdg_toplevel_decoration_v1), 0);
}

#ifdef  __cplusplus
}
#endif

#endif
/* Generated by wayland-scanner 1.23.1 */

/*
 * Copyright © 2018 Simon Ser
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <stdbool.h>
#include <stdlib.h>
#include <stdint.h>
#include "wayland-util.h"

#ifndef __has_attribute
# define __has_attribute(x) 0  /* Compatibility with non-clang compilers. */
#endif

#if (__has_attribute(visibility) || defined(__GNUC__) && __GNUC__ >= 4)
#define WL_PRIVATE __attribute__ ((visibility("hidden")))
#else
#define WL_PRIVATE
#endif

extern const struct wl_interface xdg_toplevel_interface;
extern const struct wl_interface zxdg_toplevel_decoration_v1_interface;

static const struct wl_interface *xdg_decoration_unstable_v1_types[] = {
	NULL,
	&zxdg_toplevel_decoration_v1_interface,
	&xdg_toplevel_interface,
};

static const struct wl_message zxdg_decoration_manager_v1_requests[] = {
	{ "destroy", "", xdg_decoration_unstable_v1_types + 0 },
	{ "get_toplevel_decoration", "no", xdg_decoration_unstable_v1_types + 1 },
};

WL_PRIVATE const struct wl_interface zxdg_decoration_manager_v1_interface = {
	"zxdg_decoration_manager_v1", 1,
	2, zxdg_decoration_manager_v1_requests,
	0, NULL,
};

static const struct wl_message zxdg_toplevel_decoration_v1_requests[] = {
	{ "destroy", "", xdg_decoration_unstable_v1_types + 0 },
	{ "set_mode", "u", xdg_decoration_unstable_v1_types + 0 },
	{ "unset_mode", "", xdg_decoration_unstable_v1_types + 0 },
};

static const struct wl_message zxdg_toplevel_decoration_v1_events[] = {
	{ "configure", "u", xdg_decoration_unstable_v1_types + 0 },
};

WL_PRIVATE const struct wl_interface zxdg_toplevel_decoration_v1_interface = {
	"zxdg_toplevel_decoration_v1", 1,
	3, zxdg_toplevel_decoration_v1_requests,
	1, zxdg_toplevel_decoration_v1_events,
};
/* Generated by wayland-scanner 1.23.1 */

#ifndef RELATIVE_POINTER_UNSTABLE_V1_CLIENT_PROTOCOL_H
#define RELATIVE_POINTER_UNSTABLE_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_relative_pointer_unstable_v1 The relative_pointer_unstable_v1 protocol
 * protocol for relative pointer motion events
 *
 * @section page_desc_relative_pointer_unstable_v1 Description
 *
 * This protocol specifies a set of interfaces used for making clients able to
 * receive relative pointer events not obstructed by barriers (such as the
 * monitor edge or other pointer barriers).
 *
 * To start receiving relative pointer events, a client must first bind the
 * global interface "wp_relative_pointer_manager" which, if a compositor
 * supports relative pointer motion events, is exposed by the registry. After
 * having created the relative pointer manager proxy object, the client uses
 * it to create the actual relative pointer object using the
 * "get_relative_pointer" request given a wl_pointer. The relative pointer
 * motion events will then, when applicable, be transmitted via the proxy of
 * the newly created relative pointer object. See the documentation of the
 * relative pointer interface for more details.
 *
 * Warning! The protocol described in this file is experimental and backward
 * incompatible changes may be made. Backward compatible changes may be added
 * together with the corresponding interface version bump. Backward
 * incompatible changes are done by bumping the version number in the protocol
 * and interface names and resetting the interface version. Once the protocol
 * is to be declared stable, the 'z' prefix and the version number in the
 * protocol and interface names are removed and the interface version number is
 * reset.
 *
 * @section page_ifaces_relative_pointer_unstable_v1 Interfaces
 * - @subpage page_iface_zwp_relative_pointer_manager_v1 - get relative pointer objects
 * - @subpage page_iface_zwp_relative_pointer_v1 - relative pointer object
 * @section page_copyright_relative_pointer_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2014      Jonas Ådahl
 * Copyright © 2015      Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct wl_pointer;
struct zwp_relative_pointer_manager_v1;
struct zwp_relative_pointer_v1;

#ifndef ZWP_RELATIVE_POINTER_MANAGER_V1_INTERFACE
#define ZWP_RELATIVE_POINTER_MANAGER_V1_INTERFACE
/**
 * @page page_iface_zwp_relative_pointer_manager_v1 zwp_relative_pointer_manager_v1
 * @section page_iface_zwp_relative_pointer_manager_v1_desc Description
 *
 * A global interface used for getting the relative pointer object for a
 * given pointer.
 * @section page_iface_zwp_relative_pointer_manager_v1_api API
 * See @ref iface_zwp_relative_pointer_manager_v1.
 */
/**
 * @defgroup iface_zwp_relative_pointer_manager_v1 The zwp_relative_pointer_manager_v1 interface
 *
 * A global interface used for getting the relative pointer object for a
 * given pointer.
 */
extern const struct wl_interface zwp_relative_pointer_manager_v1_interface;
#endif
#ifndef ZWP_RELATIVE_POINTER_V1_INTERFACE
#define ZWP_RELATIVE_POINTER_V1_INTERFACE
/**
 * @page page_iface_zwp_relative_pointer_v1 zwp_relative_pointer_v1
 * @section page_iface_zwp_relative_pointer_v1_desc Description
 *
 * A wp_relative_pointer object is an extension to the wl_pointer interface
 * used for emitting relative pointer events. It shares the same focus as
 * wl_pointer objects of the same seat and will only emit events when it has
 * focus.
 * @section page_iface_zwp_relative_pointer_v1_api API
 * See @ref iface_zwp_relative_pointer_v1.
 */
/**
 * @defgroup iface_zwp_relative_pointer_v1 The zwp_relative_pointer_v1 interface
 *
 * A wp_relative_pointer object is an extension to the wl_pointer interface
 * used for emitting relative pointer events. It shares the same focus as
 * wl_pointer objects of the same seat and will only emit events when it has
 * focus.
 */
extern const struct wl_interface zwp_relative_pointer_v1_interface;
#endif

#define ZWP_RELATIVE_POINTER_MANAGER_V1_DESTROY 0
#define ZWP_RELATIVE_POINTER_MANAGER_V1_GET_RELATIVE_POINTER 1


/**
 * @ingroup iface_zwp_relative_pointer_manager_v1
 */
#define ZWP_RELATIVE_POINTER_MANAGER_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_relative_pointer_manager_v1
 */
#define ZWP_RELATIVE_POINTER_MANAGER_V1_GET_RELATIVE_POINTER_SINCE_VERSION 1

/** @ingroup iface_zwp_relative_pointer_manager_v1 */
static inline void
zwp_relative_pointer_manager_v1_set_user_data(struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_relative_pointer_manager_v1, user_data);
}

/** @ingroup iface_zwp_relative_pointer_manager_v1 */
static inline void *
zwp_relative_pointer_manager_v1_get_user_data(struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_relative_pointer_manager_v1);
}

static inline uint32_t
zwp_relative_pointer_manager_v1_get_version(struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_relative_pointer_manager_v1);
}

/**
 * @ingroup iface_zwp_relative_pointer_manager_v1
 *
 * Used by the client to notify the server that it will no longer use this
 * relative pointer manager object.
 */
static inline void
zwp_relative_pointer_manager_v1_destroy(struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_relative_pointer_manager_v1,
			 ZWP_RELATIVE_POINTER_MANAGER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_relative_pointer_manager_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_zwp_relative_pointer_manager_v1
 *
 * Create a relative pointer interface given a wl_pointer object. See the
 * wp_relative_pointer interface for more details.
 */
static inline struct zwp_relative_pointer_v1 *
zwp_relative_pointer_manager_v1_get_relative_pointer(struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1, struct wl_pointer *pointer)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) zwp_relative_pointer_manager_v1,
			 ZWP_RELATIVE_POINTER_MANAGER_V1_GET_RELATIVE_POINTER, &zwp_relative_pointer_v1_interface, wl_proxy_get_version((struct wl_proxy *) zwp_relative_pointer_manager_v1), 0, NULL, pointer);

	return (struct zwp_relative_pointer_v1 *) id;
}

/**
 * @ingroup iface_zwp_relative_pointer_v1
 * @struct zwp_relative_pointer_v1_listener
 */
struct zwp_relative_pointer_v1_listener {
	/**
	 * relative pointer motion
	 *
	 * Relative x/y pointer motion from the pointer of the seat
	 * associated with this object.
	 *
	 * A relative motion is in the same dimension as regular wl_pointer
	 * motion events, except they do not represent an absolute
	 * position. For example, moving a pointer from (x, y) to (x', y')
	 * would have the equivalent relative motion (x' - x, y' - y). If a
	 * pointer motion caused the absolute pointer position to be
	 * clipped by for example the edge of the monitor, the relative
	 * motion is unaffected by the clipping and will represent the
	 * unclipped motion.
	 *
	 * This event also contains non-accelerated motion deltas. The
	 * non-accelerated delta is, when applicable, the regular pointer
	 * motion delta as it was before having applied motion acceleration
	 * and other transformations such as normalization.
	 *
	 * Note that the non-accelerated delta does not represent 'raw'
	 * events as they were read from some device. Pointer motion
	 * acceleration is device- and configuration-specific and
	 * non-accelerated deltas and accelerated deltas may have the same
	 * value on some devices.
	 *
	 * Relative motions are not coupled to wl_pointer.motion events,
	 * and can be sent in combination with such events, but also
	 * independently. There may also be scenarios where
	 * wl_pointer.motion is sent, but there is no relative motion. The
	 * order of an absolute and relative motion event originating from
	 * the same physical motion is not guaranteed.
	 *
	 * If the client needs button events or focus state, it can receive
	 * them from a wl_pointer object of the same seat that the
	 * wp_relative_pointer object is associated with.
	 * @param utime_hi high 32 bits of a 64 bit timestamp with microsecond granularity
	 * @param utime_lo low 32 bits of a 64 bit timestamp with microsecond granularity
	 * @param dx the x component of the motion vector
	 * @param dy the y component of the motion vector
	 * @param dx_unaccel the x component of the unaccelerated motion vector
	 * @param dy_unaccel the y component of the unaccelerated motion vector
	 */
	void (*relative_motion)(void *data,
				struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1,
				uint32_t utime_hi,
				uint32_t utime_lo,
				wl_fixed_t dx,
				wl_fixed_t dy,
				wl_fixed_t dx_unaccel,
				wl_fixed_t dy_unaccel);
};

/**
 * @ingroup iface_zwp_relative_pointer_v1
 */
static inline int
zwp_relative_pointer_v1_add_listener(struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1,
				     const struct zwp_relative_pointer_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zwp_relative_pointer_v1,
				     (void (**)(void)) listener, data);
}

#define ZWP_RELATIVE_POINTER_V1_DESTROY 0

/**
 * @ingroup iface_zwp_relative_pointer_v1
 */
#define ZWP_RELATIVE_POINTER_V1_RELATIVE_MOTION_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_relative_pointer_v1
 */
#define ZWP_RELATIVE_POINTER_V1_DESTROY_SINCE_VERSION 1

/** @ingroup iface_zwp_relative_pointer_v1 */
static inline void
zwp_relative_pointer_v1_set_user_data(struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_relative_pointer_v1, user_data);
}

/** @ingroup iface_zwp_relative_pointer_v1 */
static inline void *
zwp_relative_pointer_v1_get_user_data(struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_relative_pointer_v1);
}

static inline uint32_t
zwp_relative_pointer_v1_get_version(struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_relative_pointer_v1);
}

/**
 * @ingroup iface_zwp_relative_pointer_v1
 */
static inline void
zwp_relative_pointer_v1_destroy(struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_relative_pointer_v1,
			 ZWP_RELATIVE_POINTER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_relative_pointer_v1), WL_MARSHAL_FLAG_DESTROY);
}

#ifdef  __cplusplus
}
#endif

#endif
/* Generated by wayland-scanner 1.23.1 */

/*
 * Copyright © 2014      Jonas Ådahl
 * Copyright © 2015      Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <stdbool.h>
#include <stdlib.h>
#include <stdint.h>
#include "wayland-util.h"

#ifndef __has_attribute
# define __has_attribute(x) 0  /* Compatibility with non-clang compilers. */
#endif

#if (__has_attribute(visibility) || defined(__GNUC__) && __GNUC__ >= 4)
#define WL_PRIVATE __attribute__ ((visibility("hidden")))
#else
#define WL_PRIVATE
#endif

extern const struct wl_interface wl_pointer_interface;
extern const struct wl_interface zwp_relative_pointer_v1_interface;

static const struct wl_interface *relative_pointer_unstable_v1_types[] = {
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	&zwp_relative_pointer_v1_interface,
	&wl_pointer_interface,
};

static const struct wl_message zwp_relative_pointer_manager_v1_requests[] = {
	{ "destroy", "", relative_pointer_unstable_v1_types + 0 },
	{ "get_relative_pointer", "no", relative_pointer_unstable_v1_types + 6 },
};

WL_PRIVATE const struct wl_interface zwp_relative_pointer_manager_v1_interface = {
	"zwp_relative_pointer_manager_v1", 1,
	2, zwp_relative_pointer_manager_v1_requests,
	0, NULL,
};

static const struct wl_message zwp_relative_pointer_v1_requests[] = {
	{ "destroy", "", relative_pointer_unstable_v1_types + 0 },
};

static const struct wl_message zwp_relative_pointer_v1_events[] = {
	{ "relative_motion", "uuffff", relative_pointer_unstable_v1_types + 0 },
};

WL_PRIVATE const struct wl_interface zwp_relative_pointer_v1_interface = {
	"zwp_relative_pointer_v1", 1,
	1, zwp_relative_pointer_v1_requests,
	1, zwp_relative_pointer_v1_events,
};

/* Generated by wayland-scanner 1.23.1 */

#ifndef POINTER_CONSTRAINTS_UNSTABLE_V1_CLIENT_PROTOCOL_H
#define POINTER_CONSTRAINTS_UNSTABLE_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_pointer_constraints_unstable_v1 The pointer_constraints_unstable_v1 protocol
 * protocol for constraining pointer motions
 *
 * @section page_desc_pointer_constraints_unstable_v1 Description
 *
 * This protocol specifies a set of interfaces used for adding constraints to
 * the motion of a pointer. Possible constraints include confining pointer
 * motions to a given region, or locking it to its current position.
 *
 * In order to constrain the pointer, a client must first bind the global
 * interface "wp_pointer_constraints" which, if a compositor supports pointer
 * constraints, is exposed by the registry. Using the bound global object, the
 * client uses the request that corresponds to the type of constraint it wants
 * to make. See wp_pointer_constraints for more details.
 *
 * Warning! The protocol described in this file is experimental and backward
 * incompatible changes may be made. Backward compatible changes may be added
 * together with the corresponding interface version bump. Backward
 * incompatible changes are done by bumping the version number in the protocol
 * and interface names and resetting the interface version. Once the protocol
 * is to be declared stable, the 'z' prefix and the version number in the
 * protocol and interface names are removed and the interface version number is
 * reset.
 *
 * @section page_ifaces_pointer_constraints_unstable_v1 Interfaces
 * - @subpage page_iface_zwp_pointer_constraints_v1 - constrain the movement of a pointer
 * - @subpage page_iface_zwp_locked_pointer_v1 - receive relative pointer motion events
 * - @subpage page_iface_zwp_confined_pointer_v1 - confined pointer object
 * @section page_copyright_pointer_constraints_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2014      Jonas Ådahl
 * Copyright © 2015      Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct wl_pointer;
struct wl_region;
struct wl_surface;
struct zwp_confined_pointer_v1;
struct zwp_locked_pointer_v1;
struct zwp_pointer_constraints_v1;

#ifndef ZWP_POINTER_CONSTRAINTS_V1_INTERFACE
#define ZWP_POINTER_CONSTRAINTS_V1_INTERFACE
/**
 * @page page_iface_zwp_pointer_constraints_v1 zwp_pointer_constraints_v1
 * @section page_iface_zwp_pointer_constraints_v1_desc Description
 *
 * The global interface exposing pointer constraining functionality. It
 * exposes two requests: lock_pointer for locking the pointer to its
 * position, and confine_pointer for locking the pointer to a region.
 *
 * The lock_pointer and confine_pointer requests create the objects
 * wp_locked_pointer and wp_confined_pointer respectively, and the client can
 * use these objects to interact with the lock.
 *
 * For any surface, only one lock or confinement may be active across all
 * wl_pointer objects of the same seat. If a lock or confinement is requested
 * when another lock or confinement is active or requested on the same surface
 * and with any of the wl_pointer objects of the same seat, an
 * 'already_constrained' error will be raised.
 * @section page_iface_zwp_pointer_constraints_v1_api API
 * See @ref iface_zwp_pointer_constraints_v1.
 */
/**
 * @defgroup iface_zwp_pointer_constraints_v1 The zwp_pointer_constraints_v1 interface
 *
 * The global interface exposing pointer constraining functionality. It
 * exposes two requests: lock_pointer for locking the pointer to its
 * position, and confine_pointer for locking the pointer to a region.
 *
 * The lock_pointer and confine_pointer requests create the objects
 * wp_locked_pointer and wp_confined_pointer respectively, and the client can
 * use these objects to interact with the lock.
 *
 * For any surface, only one lock or confinement may be active across all
 * wl_pointer objects of the same seat. If a lock or confinement is requested
 * when another lock or confinement is active or requested on the same surface
 * and with any of the wl_pointer objects of the same seat, an
 * 'already_constrained' error will be raised.
 */
extern const struct wl_interface zwp_pointer_constraints_v1_interface;
#endif
#ifndef ZWP_LOCKED_POINTER_V1_INTERFACE
#define ZWP_LOCKED_POINTER_V1_INTERFACE
/**
 * @page page_iface_zwp_locked_pointer_v1 zwp_locked_pointer_v1
 * @section page_iface_zwp_locked_pointer_v1_desc Description
 *
 * The wp_locked_pointer interface represents a locked pointer state.
 *
 * While the lock of this object is active, the wl_pointer objects of the
 * associated seat will not emit any wl_pointer.motion events.
 *
 * This object will send the event 'locked' when the lock is activated.
 * Whenever the lock is activated, it is guaranteed that the locked surface
 * will already have received pointer focus and that the pointer will be
 * within the region passed to the request creating this object.
 *
 * To unlock the pointer, send the destroy request. This will also destroy
 * the wp_locked_pointer object.
 *
 * If the compositor decides to unlock the pointer the unlocked event is
 * sent. See wp_locked_pointer.unlock for details.
 *
 * When unlocking, the compositor may warp the cursor position to the set
 * cursor position hint. If it does, it will not result in any relative
 * motion events emitted via wp_relative_pointer.
 *
 * If the surface the lock was requested on is destroyed and the lock is not
 * yet activated, the wp_locked_pointer object is now defunct and must be
 * destroyed.
 * @section page_iface_zwp_locked_pointer_v1_api API
 * See @ref iface_zwp_locked_pointer_v1.
 */
/**
 * @defgroup iface_zwp_locked_pointer_v1 The zwp_locked_pointer_v1 interface
 *
 * The wp_locked_pointer interface represents a locked pointer state.
 *
 * While the lock of this object is active, the wl_pointer objects of the
 * associated seat will not emit any wl_pointer.motion events.
 *
 * This object will send the event 'locked' when the lock is activated.
 * Whenever the lock is activated, it is guaranteed that the locked surface
 * will already have received pointer focus and that the pointer will be
 * within the region passed to the request creating this object.
 *
 * To unlock the pointer, send the destroy request. This will also destroy
 * the wp_locked_pointer object.
 *
 * If the compositor decides to unlock the pointer the unlocked event is
 * sent. See wp_locked_pointer.unlock for details.
 *
 * When unlocking, the compositor may warp the cursor position to the set
 * cursor position hint. If it does, it will not result in any relative
 * motion events emitted via wp_relative_pointer.
 *
 * If the surface the lock was requested on is destroyed and the lock is not
 * yet activated, the wp_locked_pointer object is now defunct and must be
 * destroyed.
 */
extern const struct wl_interface zwp_locked_pointer_v1_interface;
#endif
#ifndef ZWP_CONFINED_POINTER_V1_INTERFACE
#define ZWP_CONFINED_POINTER_V1_INTERFACE
/**
 * @page page_iface_zwp_confined_pointer_v1 zwp_confined_pointer_v1
 * @section page_iface_zwp_confined_pointer_v1_desc Description
 *
 * The wp_confined_pointer interface represents a confined pointer state.
 *
 * This object will send the event 'confined' when the confinement is
 * activated. Whenever the confinement is activated, it is guaranteed that
 * the surface the pointer is confined to will already have received pointer
 * focus and that the pointer will be within the region passed to the request
 * creating this object. It is up to the compositor to decide whether this
 * requires some user interaction and if the pointer will warp to within the
 * passed region if outside.
 *
 * To unconfine the pointer, send the destroy request. This will also destroy
 * the wp_confined_pointer object.
 *
 * If the compositor decides to unconfine the pointer the unconfined event is
 * sent. The wp_confined_pointer object is at this point defunct and should
 * be destroyed.
 * @section page_iface_zwp_confined_pointer_v1_api API
 * See @ref iface_zwp_confined_pointer_v1.
 */
/**
 * @defgroup iface_zwp_confined_pointer_v1 The zwp_confined_pointer_v1 interface
 *
 * The wp_confined_pointer interface represents a confined pointer state.
 *
 * This object will send the event 'confined' when the confinement is
 * activated. Whenever the confinement is activated, it is guaranteed that
 * the surface the pointer is confined to will already have received pointer
 * focus and that the pointer will be within the region passed to the request
 * creating this object. It is up to the compositor to decide whether this
 * requires some user interaction and if the pointer will warp to within the
 * passed region if outside.
 *
 * To unconfine the pointer, send the destroy request. This will also destroy
 * the wp_confined_pointer object.
 *
 * If the compositor decides to unconfine the pointer the unconfined event is
 * sent. The wp_confined_pointer object is at this point defunct and should
 * be destroyed.
 */
extern const struct wl_interface zwp_confined_pointer_v1_interface;
#endif

#ifndef ZWP_POINTER_CONSTRAINTS_V1_ERROR_ENUM
#define ZWP_POINTER_CONSTRAINTS_V1_ERROR_ENUM
/**
 * @ingroup iface_zwp_pointer_constraints_v1
 * wp_pointer_constraints error values
 *
 * These errors can be emitted in response to wp_pointer_constraints
 * requests.
 */
enum zwp_pointer_constraints_v1_error {
	/**
	 * pointer constraint already requested on that surface
	 */
	ZWP_POINTER_CONSTRAINTS_V1_ERROR_ALREADY_CONSTRAINED = 1,
};
#endif /* ZWP_POINTER_CONSTRAINTS_V1_ERROR_ENUM */

#ifndef ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_ENUM
#define ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_ENUM
/**
 * @ingroup iface_zwp_pointer_constraints_v1
 * constraint lifetime
 *
 * These values represent different lifetime semantics. They are passed
 * as arguments to the factory requests to specify how the constraint
 * lifetimes should be managed.
 */
enum zwp_pointer_constraints_v1_lifetime {
	/**
	 * the pointer constraint is defunct once deactivated
	 *
	 * A oneshot pointer constraint will never reactivate once it has
	 * been deactivated. See the corresponding deactivation event
	 * (wp_locked_pointer.unlocked and wp_confined_pointer.unconfined)
	 * for details.
	 */
	ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_ONESHOT = 1,
	/**
	 * the pointer constraint may reactivate
	 *
	 * A persistent pointer constraint may again reactivate once it
	 * has been deactivated. See the corresponding deactivation event
	 * (wp_locked_pointer.unlocked and wp_confined_pointer.unconfined)
	 * for details.
	 */
	ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT = 2,
};
#endif /* ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_ENUM */

#define ZWP_POINTER_CONSTRAINTS_V1_DESTROY 0
#define ZWP_POINTER_CONSTRAINTS_V1_LOCK_POINTER 1
#define ZWP_POINTER_CONSTRAINTS_V1_CONFINE_POINTER 2


/**
 * @ingroup iface_zwp_pointer_constraints_v1
 */
#define ZWP_POINTER_CONSTRAINTS_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_pointer_constraints_v1
 */
#define ZWP_POINTER_CONSTRAINTS_V1_LOCK_POINTER_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_pointer_constraints_v1
 */
#define ZWP_POINTER_CONSTRAINTS_V1_CONFINE_POINTER_SINCE_VERSION 1

/** @ingroup iface_zwp_pointer_constraints_v1 */
static inline void
zwp_pointer_constraints_v1_set_user_data(struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_pointer_constraints_v1, user_data);
}

/** @ingroup iface_zwp_pointer_constraints_v1 */
static inline void *
zwp_pointer_constraints_v1_get_user_data(struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_pointer_constraints_v1);
}

static inline uint32_t
zwp_pointer_constraints_v1_get_version(struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_pointer_constraints_v1);
}

/**
 * @ingroup iface_zwp_pointer_constraints_v1
 *
 * Used by the client to notify the server that it will no longer use this
 * pointer constraints object.
 */
static inline void
zwp_pointer_constraints_v1_destroy(struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_pointer_constraints_v1,
			 ZWP_POINTER_CONSTRAINTS_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_pointer_constraints_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_zwp_pointer_constraints_v1
 *
 * The lock_pointer request lets the client request to disable movements of
 * the virtual pointer (i.e. the cursor), effectively locking the pointer
 * to a position. This request may not take effect immediately; in the
 * future, when the compositor deems implementation-specific constraints
 * are satisfied, the pointer lock will be activated and the compositor
 * sends a locked event.
 *
 * The protocol provides no guarantee that the constraints are ever
 * satisfied, and does not require the compositor to send an error if the
 * constraints cannot ever be satisfied. It is thus possible to request a
 * lock that will never activate.
 *
 * There may not be another pointer constraint of any kind requested or
 * active on the surface for any of the wl_pointer objects of the seat of
 * the passed pointer when requesting a lock. If there is, an error will be
 * raised. See general pointer lock documentation for more details.
 *
 * The intersection of the region passed with this request and the input
 * region of the surface is used to determine where the pointer must be
 * in order for the lock to activate. It is up to the compositor whether to
 * warp the pointer or require some kind of user interaction for the lock
 * to activate. If the region is null the surface input region is used.
 *
 * A surface may receive pointer focus without the lock being activated.
 *
 * The request creates a new object wp_locked_pointer which is used to
 * interact with the lock as well as receive updates about its state. See
 * the the description of wp_locked_pointer for further information.
 *
 * Note that while a pointer is locked, the wl_pointer objects of the
 * corresponding seat will not emit any wl_pointer.motion events, but
 * relative motion events will still be emitted via wp_relative_pointer
 * objects of the same seat. wl_pointer.axis and wl_pointer.button events
 * are unaffected.
 */
static inline struct zwp_locked_pointer_v1 *
zwp_pointer_constraints_v1_lock_pointer(struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1, struct wl_surface *surface, struct wl_pointer *pointer, struct wl_region *region, uint32_t lifetime)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) zwp_pointer_constraints_v1,
			 ZWP_POINTER_CONSTRAINTS_V1_LOCK_POINTER, &zwp_locked_pointer_v1_interface, wl_proxy_get_version((struct wl_proxy *) zwp_pointer_constraints_v1), 0, NULL, surface, pointer, region, lifetime);

	return (struct zwp_locked_pointer_v1 *) id;
}

/**
 * @ingroup iface_zwp_pointer_constraints_v1
 *
 * The confine_pointer request lets the client request to confine the
 * pointer cursor to a given region. This request may not take effect
 * immediately; in the future, when the compositor deems implementation-
 * specific constraints are satisfied, the pointer confinement will be
 * activated and the compositor sends a confined event.
 *
 * The intersection of the region passed with this request and the input
 * region of the surface is used to determine where the pointer must be
 * in order for the confinement to activate. It is up to the compositor
 * whether to warp the pointer or require some kind of user interaction for
 * the confinement to activate. If the region is null the surface input
 * region is used.
 *
 * The request will create a new object wp_confined_pointer which is used
 * to interact with the confinement as well as receive updates about its
 * state. See the the description of wp_confined_pointer for further
 * information.
 */
static inline struct zwp_confined_pointer_v1 *
zwp_pointer_constraints_v1_confine_pointer(struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1, struct wl_surface *surface, struct wl_pointer *pointer, struct wl_region *region, uint32_t lifetime)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) zwp_pointer_constraints_v1,
			 ZWP_POINTER_CONSTRAINTS_V1_CONFINE_POINTER, &zwp_confined_pointer_v1_interface, wl_proxy_get_version((struct wl_proxy *) zwp_pointer_constraints_v1), 0, NULL, surface, pointer, region, lifetime);

	return (struct zwp_confined_pointer_v1 *) id;
}

/**
 * @ingroup iface_zwp_locked_pointer_v1
 * @struct zwp_locked_pointer_v1_listener
 */
struct zwp_locked_pointer_v1_listener {
	/**
	 * lock activation event
	 *
	 * Notification that the pointer lock of the seat's pointer is
	 * activated.
	 */
	void (*locked)(void *data,
		       struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1);
	/**
	 * lock deactivation event
	 *
	 * Notification that the pointer lock of the seat's pointer is no
	 * longer active. If this is a oneshot pointer lock (see
	 * wp_pointer_constraints.lifetime) this object is now defunct and
	 * should be destroyed. If this is a persistent pointer lock (see
	 * wp_pointer_constraints.lifetime) this pointer lock may again
	 * reactivate in the future.
	 */
	void (*unlocked)(void *data,
			 struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1);
};

/**
 * @ingroup iface_zwp_locked_pointer_v1
 */
static inline int
zwp_locked_pointer_v1_add_listener(struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1,
				   const struct zwp_locked_pointer_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zwp_locked_pointer_v1,
				     (void (**)(void)) listener, data);
}

#define ZWP_LOCKED_POINTER_V1_DESTROY 0
#define ZWP_LOCKED_POINTER_V1_SET_CURSOR_POSITION_HINT 1
#define ZWP_LOCKED_POINTER_V1_SET_REGION 2

/**
 * @ingroup iface_zwp_locked_pointer_v1
 */
#define ZWP_LOCKED_POINTER_V1_LOCKED_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_locked_pointer_v1
 */
#define ZWP_LOCKED_POINTER_V1_UNLOCKED_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_locked_pointer_v1
 */
#define ZWP_LOCKED_POINTER_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_locked_pointer_v1
 */
#define ZWP_LOCKED_POINTER_V1_SET_CURSOR_POSITION_HINT_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_locked_pointer_v1
 */
#define ZWP_LOCKED_POINTER_V1_SET_REGION_SINCE_VERSION 1

/** @ingroup iface_zwp_locked_pointer_v1 */
static inline void
zwp_locked_pointer_v1_set_user_data(struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_locked_pointer_v1, user_data);
}

/** @ingroup iface_zwp_locked_pointer_v1 */
static inline void *
zwp_locked_pointer_v1_get_user_data(struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_locked_pointer_v1);
}

static inline uint32_t
zwp_locked_pointer_v1_get_version(struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_locked_pointer_v1);
}

/**
 * @ingroup iface_zwp_locked_pointer_v1
 *
 * Destroy the locked pointer object. If applicable, the compositor will
 * unlock the pointer.
 */
static inline void
zwp_locked_pointer_v1_destroy(struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_locked_pointer_v1,
			 ZWP_LOCKED_POINTER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_locked_pointer_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_zwp_locked_pointer_v1
 *
 * Set the cursor position hint relative to the top left corner of the
 * surface.
 *
 * If the client is drawing its own cursor, it should update the position
 * hint to the position of its own cursor. A compositor may use this
 * information to warp the pointer upon unlock in order to avoid pointer
 * jumps.
 *
 * The cursor position hint is double-buffered state, see
 * wl_surface.commit.
 */
static inline void
zwp_locked_pointer_v1_set_cursor_position_hint(struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1, wl_fixed_t surface_x, wl_fixed_t surface_y)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_locked_pointer_v1,
			 ZWP_LOCKED_POINTER_V1_SET_CURSOR_POSITION_HINT, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_locked_pointer_v1), 0, surface_x, surface_y);
}

/**
 * @ingroup iface_zwp_locked_pointer_v1
 *
 * Set a new region used to lock the pointer.
 *
 * The new lock region is double-buffered, see wl_surface.commit.
 *
 * For details about the lock region, see wp_locked_pointer.
 */
static inline void
zwp_locked_pointer_v1_set_region(struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1, struct wl_region *region)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_locked_pointer_v1,
			 ZWP_LOCKED_POINTER_V1_SET_REGION, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_locked_pointer_v1), 0, region);
}

/**
 * @ingroup iface_zwp_confined_pointer_v1
 * @struct zwp_confined_pointer_v1_listener
 */
struct zwp_confined_pointer_v1_listener {
	/**
	 * pointer confined
	 *
	 * Notification that the pointer confinement of the seat's
	 * pointer is activated.
	 */
	void (*confined)(void *data,
			 struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1);
	/**
	 * pointer unconfined
	 *
	 * Notification that the pointer confinement of the seat's
	 * pointer is no longer active. If this is a oneshot pointer
	 * confinement (see wp_pointer_constraints.lifetime) this object is
	 * now defunct and should be destroyed. If this is a persistent
	 * pointer confinement (see wp_pointer_constraints.lifetime) this
	 * pointer confinement may again reactivate in the future.
	 */
	void (*unconfined)(void *data,
			   struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1);
};

/**
 * @ingroup iface_zwp_confined_pointer_v1
 */
static inline int
zwp_confined_pointer_v1_add_listener(struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1,
				     const struct zwp_confined_pointer_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zwp_confined_pointer_v1,
				     (void (**)(void)) listener, data);
}

#define ZWP_CONFINED_POINTER_V1_DESTROY 0
#define ZWP_CONFINED_POINTER_V1_SET_REGION 1

/**
 * @ingroup iface_zwp_confined_pointer_v1
 */
#define ZWP_CONFINED_POINTER_V1_CONFINED_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_confined_pointer_v1
 */
#define ZWP_CONFINED_POINTER_V1_UNCONFINED_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_confined_pointer_v1
 */
#define ZWP_CONFINED_POINTER_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_confined_pointer_v1
 */
#define ZWP_CONFINED_POINTER_V1_SET_REGION_SINCE_VERSION 1

/** @ingroup iface_zwp_confined_pointer_v1 */
static inline void
zwp_confined_pointer_v1_set_user_data(struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_confined_pointer_v1, user_data);
}

/** @ingroup iface_zwp_confined_pointer_v1 */
static inline void *
zwp_confined_pointer_v1_get_user_data(struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_confined_pointer_v1);
}

static inline uint32_t
zwp_confined_pointer_v1_get_version(struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_confined_pointer_v1);
}

/**
 * @ingroup iface_zwp_confined_pointer_v1
 *
 * Destroy the confined pointer object. If applicable, the compositor will
 * unconfine the pointer.
 */
static inline void
zwp_confined_pointer_v1_destroy(struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_confined_pointer_v1,
			 ZWP_CONFINED_POINTER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_confined_pointer_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_zwp_confined_pointer_v1
 *
 * Set a new region used to confine the pointer.
 *
 * The new confine region is double-buffered, see wl_surface.commit.
 *
 * If the confinement is active when the new confinement region is applied
 * and the pointer ends up outside of newly applied region, the pointer may
 * warped to a position within the new confinement region. If warped, a
 * wl_pointer.motion event will be emitted, but no
 * wp_relative_pointer.relative_motion event.
 *
 * The compositor may also, instead of using the new region, unconfine the
 * pointer.
 *
 * For details about the confine region, see wp_confined_pointer.
 */
static inline void
zwp_confined_pointer_v1_set_region(struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1, struct wl_region *region)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_confined_pointer_v1,
			 ZWP_CONFINED_POINTER_V1_SET_REGION, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_confined_pointer_v1), 0, region);
}

#ifdef  __cplusplus
}
#endif

#endif
/* Generated by wayland-scanner 1.23.1 */

/*
 * Copyright © 2014      Jonas Ådahl
 * Copyright © 2015      Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <stdbool.h>
#include <stdlib.h>
#include <stdint.h>
#include "wayland-util.h"

#ifndef __has_attribute
# define __has_attribute(x) 0  /* Compatibility with non-clang compilers. */
#endif

#if (__has_attribute(visibility) || defined(__GNUC__) && __GNUC__ >= 4)
#define WL_PRIVATE __attribute__ ((visibility("hidden")))
#else
#define WL_PRIVATE
#endif

extern const struct wl_interface wl_pointer_interface;
extern const struct wl_interface wl_region_interface;
extern const struct wl_interface wl_surface_interface;
extern const struct wl_interface zwp_confined_pointer_v1_interface;
extern const struct wl_interface zwp_locked_pointer_v1_interface;

static const struct wl_interface *pointer_constraints_unstable_v1_types[] = {
	NULL,
	NULL,
	&zwp_locked_pointer_v1_interface,
	&wl_surface_interface,
	&wl_pointer_interface,
	&wl_region_interface,
	NULL,
	&zwp_confined_pointer_v1_interface,
	&wl_surface_interface,
	&wl_pointer_interface,
	&wl_region_interface,
	NULL,
	&wl_region_interface,
	&wl_region_interface,
};

static const struct wl_message zwp_pointer_constraints_v1_requests[] = {
	{ "destroy", "", pointer_constraints_unstable_v1_types + 0 },
	{ "lock_pointer", "noo?ou", pointer_constraints_unstable_v1_types + 2 },
	{ "confine_pointer", "noo?ou", pointer_constraints_unstable_v1_types + 7 },
};

WL_PRIVATE const struct wl_interface zwp_pointer_constraints_v1_interface = {
	"zwp_pointer_constraints_v1", 1,
	3, zwp_pointer_constraints_v1_requests,
	0, NULL,
};

static const struct wl_message zwp_locked_pointer_v1_requests[] = {
	{ "destroy", "", pointer_constraints_unstable_v1_types + 0 },
	{ "set_cursor_position_hint", "ff", pointer_constraints_unstable_v1_types + 0 },
	{ "set_region", "?o", pointer_constraints_unstable_v1_types + 12 },
};

static const struct wl_message zwp_locked_pointer_v1_events[] = {
	{ "locked", "", pointer_constraints_unstable_v1_types + 0 },
	{ "unlocked", "", pointer_constraints_unstable_v1_types + 0 },
};

WL_PRIVATE const struct wl_interface zwp_locked_pointer_v1_interface = {
	"zwp_locked_pointer_v1", 1,
	3, zwp_locked_pointer_v1_requests,
	2, zwp_locked_pointer_v1_events,
};

static const struct wl_message zwp_confined_pointer_v1_requests[] = {
	{ "destroy", "", pointer_constraints_unstable_v1_types + 0 },
	{ "set_region", "?o", pointer_constraints_unstable_v1_types + 13 },
};

static const struct wl_message zwp_confined_pointer_v1_events[] = {
	{ "confined", "", pointer_constraints_unstable_v1_types + 0 },
	{ "unconfined", "", pointer_constraints_unstable_v1_types + 0 },
};

WL_PRIVATE const struct wl_interface zwp_confined_pointer_v1_interface = {
	"zwp_confined_pointer_v1", 1,
	2, zwp_confined_pointer_v1_requests,
	2, zwp_confined_pointer_v1_events,
};

/* Generated by wayland-scanner 1.23.1 */

#ifndef KEYBOARD_SHORTCUTS_INHIBIT_UNSTABLE_V1_CLIENT_PROTOCOL_H
#define KEYBOARD_SHORTCUTS_INHIBIT_UNSTABLE_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_keyboard_shortcuts_inhibit_unstable_v1 The keyboard_shortcuts_inhibit_unstable_v1 protocol
 * Protocol for inhibiting the compositor keyboard shortcuts
 *
 * @section page_desc_keyboard_shortcuts_inhibit_unstable_v1 Description
 *
 * This protocol specifies a way for a client to request the compositor
 * to ignore its own keyboard shortcuts for a given seat, so that all
 * key events from that seat get forwarded to a surface.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible
 * changes may be added together with the corresponding interface
 * version bump.
 * Backward incompatible changes are done by bumping the version
 * number in the protocol and interface names and resetting the
 * interface version. Once the protocol is to be declared stable,
 * the 'z' prefix and the version number in the protocol and
 * interface names are removed and the interface version number is
 * reset.
 *
 * @section page_ifaces_keyboard_shortcuts_inhibit_unstable_v1 Interfaces
 * - @subpage page_iface_zwp_keyboard_shortcuts_inhibit_manager_v1 - context object for keyboard grab_manager
 * - @subpage page_iface_zwp_keyboard_shortcuts_inhibitor_v1 - context object for keyboard shortcuts inhibitor
 * @section page_copyright_keyboard_shortcuts_inhibit_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2017 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct wl_seat;
struct wl_surface;
struct zwp_keyboard_shortcuts_inhibit_manager_v1;
struct zwp_keyboard_shortcuts_inhibitor_v1;

#ifndef ZWP_KEYBOARD_SHORTCUTS_INHIBIT_MANAGER_V1_INTERFACE
#define ZWP_KEYBOARD_SHORTCUTS_INHIBIT_MANAGER_V1_INTERFACE
/**
 * @page page_iface_zwp_keyboard_shortcuts_inhibit_manager_v1 zwp_keyboard_shortcuts_inhibit_manager_v1
 * @section page_iface_zwp_keyboard_shortcuts_inhibit_manager_v1_desc Description
 *
 * A global interface used for inhibiting the compositor keyboard shortcuts.
 * @section page_iface_zwp_keyboard_shortcuts_inhibit_manager_v1_api API
 * See @ref iface_zwp_keyboard_shortcuts_inhibit_manager_v1.
 */
/**
 * @defgroup iface_zwp_keyboard_shortcuts_inhibit_manager_v1 The zwp_keyboard_shortcuts_inhibit_manager_v1 interface
 *
 * A global interface used for inhibiting the compositor keyboard shortcuts.
 */
extern const struct wl_interface zwp_keyboard_shortcuts_inhibit_manager_v1_interface;
#endif
#ifndef ZWP_KEYBOARD_SHORTCUTS_INHIBITOR_V1_INTERFACE
#define ZWP_KEYBOARD_SHORTCUTS_INHIBITOR_V1_INTERFACE
/**
 * @page page_iface_zwp_keyboard_shortcuts_inhibitor_v1 zwp_keyboard_shortcuts_inhibitor_v1
 * @section page_iface_zwp_keyboard_shortcuts_inhibitor_v1_desc Description
 *
 * A keyboard shortcuts inhibitor instructs the compositor to ignore
 * its own keyboard shortcuts when the associated surface has keyboard
 * focus. As a result, when the surface has keyboard focus on the given
 * seat, it will receive all key events originating from the specified
 * seat, even those which would normally be caught by the compositor for
 * its own shortcuts.
 *
 * The Wayland compositor is however under no obligation to disable
 * all of its shortcuts, and may keep some special key combo for its own
 * use, including but not limited to one allowing the user to forcibly
 * restore normal keyboard events routing in the case of an unwilling
 * client. The compositor may also use the same key combo to reactivate
 * an existing shortcut inhibitor that was previously deactivated on
 * user request.
 *
 * When the compositor restores its own keyboard shortcuts, an
 * "inactive" event is emitted to notify the client that the keyboard
 * shortcuts inhibitor is not effectively active for the surface and
 * seat any more, and the client should not expect to receive all
 * keyboard events.
 *
 * When the keyboard shortcuts inhibitor is inactive, the client has
 * no way to forcibly reactivate the keyboard shortcuts inhibitor.
 *
 * The user can chose to re-enable a previously deactivated keyboard
 * shortcuts inhibitor using any mechanism the compositor may offer,
 * in which case the compositor will send an "active" event to notify
 * the client.
 *
 * If the surface is destroyed, unmapped, or loses the seat's keyboard
 * focus, the keyboard shortcuts inhibitor becomes irrelevant and the
 * compositor will restore its own keyboard shortcuts but no "inactive"
 * event is emitted in this case.
 * @section page_iface_zwp_keyboard_shortcuts_inhibitor_v1_api API
 * See @ref iface_zwp_keyboard_shortcuts_inhibitor_v1.
 */
/**
 * @defgroup iface_zwp_keyboard_shortcuts_inhibitor_v1 The zwp_keyboard_shortcuts_inhibitor_v1 interface
 *
 * A keyboard shortcuts inhibitor instructs the compositor to ignore
 * its own keyboard shortcuts when the associated surface has keyboard
 * focus. As a result, when the surface has keyboard focus on the given
 * seat, it will receive all key events originating from the specified
 * seat, even those which would normally be caught by the compositor for
 * its own shortcuts.
 *
 * The Wayland compositor is however under no obligation to disable
 * all of its shortcuts, and may keep some special key combo for its own
 * use, including but not limited to one allowing the user to forcibly
 * restore normal keyboard events routing in the case of an unwilling
 * client. The compositor may also use the same key combo to reactivate
 * an existing shortcut inhibitor that was previously deactivated on
 * user request.
 *
 * When the compositor restores its own keyboard shortcuts, an
 * "inactive" event is emitted to notify the client that the keyboard
 * shortcuts inhibitor is not effectively active for the surface and
 * seat any more, and the client should not expect to receive all
 * keyboard events.
 *
 * When the keyboard shortcuts inhibitor is inactive, the client has
 * no way to forcibly reactivate the keyboard shortcuts inhibitor.
 *
 * The user can chose to re-enable a previously deactivated keyboard
 * shortcuts inhibitor using any mechanism the compositor may offer,
 * in which case the compositor will send an "active" event to notify
 * the client.
 *
 * If the surface is destroyed, unmapped, or loses the seat's keyboard
 * focus, the keyboard shortcuts inhibitor becomes irrelevant and the
 * compositor will restore its own keyboard shortcuts but no "inactive"
 * event is emitted in this case.
 */
extern const struct wl_interface zwp_keyboard_shortcuts_inhibitor_v1_interface;
#endif

#ifndef ZWP_KEYBOARD_SHORTCUTS_INHIBIT_MANAGER_V1_ERROR_ENUM
#define ZWP_KEYBOARD_SHORTCUTS_INHIBIT_MANAGER_V1_ERROR_ENUM
enum zwp_keyboard_shortcuts_inhibit_manager_v1_error {
	/**
	 * the shortcuts are already inhibited for this surface
	 */
	ZWP_KEYBOARD_SHORTCUTS_INHIBIT_MANAGER_V1_ERROR_ALREADY_INHIBITED = 0,
};
#endif /* ZWP_KEYBOARD_SHORTCUTS_INHIBIT_MANAGER_V1_ERROR_ENUM */

#define ZWP_KEYBOARD_SHORTCUTS_INHIBIT_MANAGER_V1_DESTROY 0
#define ZWP_KEYBOARD_SHORTCUTS_INHIBIT_MANAGER_V1_INHIBIT_SHORTCUTS 1


/**
 * @ingroup iface_zwp_keyboard_shortcuts_inhibit_manager_v1
 */
#define ZWP_KEYBOARD_SHORTCUTS_INHIBIT_MANAGER_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_keyboard_shortcuts_inhibit_manager_v1
 */
#define ZWP_KEYBOARD_SHORTCUTS_INHIBIT_MANAGER_V1_INHIBIT_SHORTCUTS_SINCE_VERSION 1

/** @ingroup iface_zwp_keyboard_shortcuts_inhibit_manager_v1 */
static inline void
zwp_keyboard_shortcuts_inhibit_manager_v1_set_user_data(struct zwp_keyboard_shortcuts_inhibit_manager_v1 *zwp_keyboard_shortcuts_inhibit_manager_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_keyboard_shortcuts_inhibit_manager_v1, user_data);
}

/** @ingroup iface_zwp_keyboard_shortcuts_inhibit_manager_v1 */
static inline void *
zwp_keyboard_shortcuts_inhibit_manager_v1_get_user_data(struct zwp_keyboard_shortcuts_inhibit_manager_v1 *zwp_keyboard_shortcuts_inhibit_manager_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_keyboard_shortcuts_inhibit_manager_v1);
}

static inline uint32_t
zwp_keyboard_shortcuts_inhibit_manager_v1_get_version(struct zwp_keyboard_shortcuts_inhibit_manager_v1 *zwp_keyboard_shortcuts_inhibit_manager_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_keyboard_shortcuts_inhibit_manager_v1);
}

/**
 * @ingroup iface_zwp_keyboard_shortcuts_inhibit_manager_v1
 *
 * Destroy the keyboard shortcuts inhibitor manager.
 */
static inline void
zwp_keyboard_shortcuts_inhibit_manager_v1_destroy(struct zwp_keyboard_shortcuts_inhibit_manager_v1 *zwp_keyboard_shortcuts_inhibit_manager_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_keyboard_shortcuts_inhibit_manager_v1,
			 ZWP_KEYBOARD_SHORTCUTS_INHIBIT_MANAGER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_keyboard_shortcuts_inhibit_manager_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_zwp_keyboard_shortcuts_inhibit_manager_v1
 *
 * Create a new keyboard shortcuts inhibitor object associated with
 * the given surface for the given seat.
 *
 * If shortcuts are already inhibited for the specified seat and surface,
 * a protocol error "already_inhibited" is raised by the compositor.
 */
static inline struct zwp_keyboard_shortcuts_inhibitor_v1 *
zwp_keyboard_shortcuts_inhibit_manager_v1_inhibit_shortcuts(struct zwp_keyboard_shortcuts_inhibit_manager_v1 *zwp_keyboard_shortcuts_inhibit_manager_v1, struct wl_surface *surface, struct wl_seat *seat)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) zwp_keyboard_shortcuts_inhibit_manager_v1,
			 ZWP_KEYBOARD_SHORTCUTS_INHIBIT_MANAGER_V1_INHIBIT_SHORTCUTS, &zwp_keyboard_shortcuts_inhibitor_v1_interface, wl_proxy_get_version((struct wl_proxy *) zwp_keyboard_shortcuts_inhibit_manager_v1), 0, NULL, surface, seat);

	return (struct zwp_keyboard_shortcuts_inhibitor_v1 *) id;
}

/**
 * @ingroup iface_zwp_keyboard_shortcuts_inhibitor_v1
 * @struct zwp_keyboard_shortcuts_inhibitor_v1_listener
 */
struct zwp_keyboard_shortcuts_inhibitor_v1_listener {
	/**
	 * shortcuts are inhibited
	 *
	 * This event indicates that the shortcut inhibitor is active.
	 *
	 * The compositor sends this event every time compositor shortcuts
	 * are inhibited on behalf of the surface. When active, the client
	 * may receive input events normally reserved by the compositor
	 * (see zwp_keyboard_shortcuts_inhibitor_v1).
	 *
	 * This occurs typically when the initial request
	 * "inhibit_shortcuts" first becomes active or when the user
	 * instructs the compositor to re-enable and existing shortcuts
	 * inhibitor using any mechanism offered by the compositor.
	 */
	void (*active)(void *data,
		       struct zwp_keyboard_shortcuts_inhibitor_v1 *zwp_keyboard_shortcuts_inhibitor_v1);
	/**
	 * shortcuts are restored
	 *
	 * This event indicates that the shortcuts inhibitor is inactive,
	 * normal shortcuts processing is restored by the compositor.
	 */
	void (*inactive)(void *data,
			 struct zwp_keyboard_shortcuts_inhibitor_v1 *zwp_keyboard_shortcuts_inhibitor_v1);
};

/**
 * @ingroup iface_zwp_keyboard_shortcuts_inhibitor_v1
 */
static inline int
zwp_keyboard_shortcuts_inhibitor_v1_add_listener(struct zwp_keyboard_shortcuts_inhibitor_v1 *zwp_keyboard_shortcuts_inhibitor_v1,
						 const struct zwp_keyboard_shortcuts_inhibitor_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zwp_keyboard_shortcuts_inhibitor_v1,
				     (void (**)(void)) listener, data);
}

#define ZWP_KEYBOARD_SHORTCUTS_INHIBITOR_V1_DESTROY 0

/**
 * @ingroup iface_zwp_keyboard_shortcuts_inhibitor_v1
 */
#define ZWP_KEYBOARD_SHORTCUTS_INHIBITOR_V1_ACTIVE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_keyboard_shortcuts_inhibitor_v1
 */
#define ZWP_KEYBOARD_SHORTCUTS_INHIBITOR_V1_INACTIVE_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_keyboard_shortcuts_inhibitor_v1
 */
#define ZWP_KEYBOARD_SHORTCUTS_INHIBITOR_V1_DESTROY_SINCE_VERSION 1

/** @ingroup iface_zwp_keyboard_shortcuts_inhibitor_v1 */
static inline void
zwp_keyboard_shortcuts_inhibitor_v1_set_user_data(struct zwp_keyboard_shortcuts_inhibitor_v1 *zwp_keyboard_shortcuts_inhibitor_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_keyboard_shortcuts_inhibitor_v1, user_data);
}

/** @ingroup iface_zwp_keyboard_shortcuts_inhibitor_v1 */
static inline void *
zwp_keyboard_shortcuts_inhibitor_v1_get_user_data(struct zwp_keyboard_shortcuts_inhibitor_v1 *zwp_keyboard_shortcuts_inhibitor_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_keyboard_shortcuts_inhibitor_v1);
}

static inline uint32_t
zwp_keyboard_shortcuts_inhibitor_v1_get_version(struct zwp_keyboard_shortcuts_inhibitor_v1 *zwp_keyboard_shortcuts_inhibitor_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_keyboard_shortcuts_inhibitor_v1);
}

/**
 * @ingroup iface_zwp_keyboard_shortcuts_inhibitor_v1
 *
 * Remove the keyboard shortcuts inhibitor from the associated wl_surface.
 */
static inline void
zwp_keyboard_shortcuts_inhibitor_v1_destroy(struct zwp_keyboard_shortcuts_inhibitor_v1 *zwp_keyboard_shortcuts_inhibitor_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_keyboard_shortcuts_inhibitor_v1,
			 ZWP_KEYBOARD_SHORTCUTS_INHIBITOR_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_keyboard_shortcuts_inhibitor_v1), WL_MARSHAL_FLAG_DESTROY);
}

#ifdef  __cplusplus
}
#endif

#endif
/* Generated by wayland-scanner 1.23.1 */

/*
 * Copyright © 2017 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <stdbool.h>
#include <stdlib.h>
#include <stdint.h>
#include "wayland-util.h"

#ifndef __has_attribute
# define __has_attribute(x) 0  /* Compatibility with non-clang compilers. */
#endif

#if (__has_attribute(visibility) || defined(__GNUC__) && __GNUC__ >= 4)
#define WL_PRIVATE __attribute__ ((visibility("hidden")))
#else
#define WL_PRIVATE
#endif

extern const struct wl_interface wl_seat_interface;
extern const struct wl_interface wl_surface_interface;
extern const struct wl_interface zwp_keyboard_shortcuts_inhibitor_v1_interface;

static const struct wl_interface *keyboard_shortcuts_inhibit_unstable_v1_types[] = {
	&zwp_keyboard_shortcuts_inhibitor_v1_interface,
	&wl_surface_interface,
	&wl_seat_interface,
};

static const struct wl_message zwp_keyboard_shortcuts_inhibit_manager_v1_requests[] = {
	{ "destroy", "", keyboard_shortcuts_inhibit_unstable_v1_types + 0 },
	{ "inhibit_shortcuts", "noo", keyboard_shortcuts_inhibit_unstable_v1_types + 0 },
};

WL_PRIVATE const struct wl_interface zwp_keyboard_shortcuts_inhibit_manager_v1_interface = {
	"zwp_keyboard_shortcuts_inhibit_manager_v1", 1,
	2, zwp_keyboard_shortcuts_inhibit_manager_v1_requests,
	0, NULL,
};

static const struct wl_message zwp_keyboard_shortcuts_inhibitor_v1_requests[] = {
	{ "destroy", "", keyboard_shortcuts_inhibit_unstable_v1_types + 0 },
};

static const struct wl_message zwp_keyboard_shortcuts_inhibitor_v1_events[] = {
	{ "active", "", keyboard_shortcuts_inhibit_unstable_v1_types + 0 },
	{ "inactive", "", keyboard_shortcuts_inhibit_unstable_v1_types + 0 },
};

WL_PRIVATE const struct wl_interface zwp_keyboard_shortcuts_inhibitor_v1_interface = {
	"zwp_keyboard_shortcuts_inhibitor_v1", 1,
	1, zwp_keyboard_shortcuts_inhibitor_v1_requests,
	2, zwp_keyboard_shortcuts_inhibitor_v1_events,
};

/* Generated by wayland-scanner 1.23.1 */

#ifndef TABLET_V2_CLIENT_PROTOCOL_H
#define TABLET_V2_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_tablet_v2 The tablet_v2 protocol
 * Wayland protocol for graphics tablets
 *
 * @section page_desc_tablet_v2 Description
 *
 * This description provides a high-level overview of the interplay between
 * the interfaces defined this protocol. For details, see the protocol
 * specification.
 *
 * More than one tablet may exist, and device-specifics matter. Tablets are
 * not represented by a single virtual device like wl_pointer. A client
 * binds to the tablet manager object which is just a proxy object. From
 * that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)
 * and that returns the actual interface that has all the tablets. With
 * this indirection, we can avoid merging wp_tablet into the actual Wayland
 * protocol, a long-term benefit.
 *
 * The wp_tablet_seat sends a "tablet added" event for each tablet
 * connected. That event is followed by descriptive events about the
 * hardware; currently that includes events for name, vid/pid and
 * a wp_tablet.path event that describes a local path. This path can be
 * used to uniquely identify a tablet or get more information through
 * libwacom. Emulated or nested tablets can skip any of those, e.g. a
 * virtual tablet may not have a vid/pid. The sequence of descriptive
 * events is terminated by a wp_tablet.done event to signal that a client
 * may now finalize any initialization for that tablet.
 *
 * Events from tablets require a tool in proximity. Tools are also managed
 * by the tablet seat; a "tool added" event is sent whenever a tool is new
 * to the compositor. That event is followed by a number of descriptive
 * events about the hardware; currently that includes capabilities,
 * hardware id and serial number, and tool type. Similar to the tablet
 * interface, a wp_tablet_tool.done event is sent to terminate that initial
 * sequence.
 *
 * Any event from a tool happens on the wp_tablet_tool interface. When the
 * tool gets into proximity of the tablet, a proximity_in event is sent on
 * the wp_tablet_tool interface, listing the tablet and the surface. That
 * event is followed by a motion event with the coordinates. After that,
 * it's the usual motion, axis, button, etc. events. The protocol's
 * serialisation means events are grouped by wp_tablet_tool.frame events.
 *
 * Two special events (that don't exist in X) are down and up. They signal
 * "tip touching the surface". For tablets without real proximity
 * detection, the sequence is: proximity_in, motion, down, frame.
 *
 * When the tool leaves proximity, a proximity_out event is sent. If any
 * button is still down, a button release event is sent before this
 * proximity event. These button events are sent in the same frame as the
 * proximity event to signal to the client that the buttons were held when
 * the tool left proximity.
 *
 * If the tool moves out of the surface but stays in proximity (i.e.
 * between windows), compositor-specific grab policies apply. This usually
 * means that the proximity-out is delayed until all buttons are released.
 *
 * Moving a tool physically from one tablet to the other has no real effect
 * on the protocol, since we already have the tool object from the "tool
 * added" event. All the information is already there and the proximity
 * events on both tablets are all a client needs to reconstruct what
 * happened.
 *
 * Some extra axes are normalized, i.e. the client knows the range as
 * specified in the protocol (e.g. [0, 65535]), the granularity however is
 * unknown. The current normalized axes are pressure, distance, and slider.
 *
 * Other extra axes are in physical units as specified in the protocol.
 * The current extra axes with physical units are tilt, rotation and
 * wheel rotation.
 *
 * Since tablets work independently of the pointer controlled by the mouse,
 * the focus handling is independent too and controlled by proximity.
 * The wp_tablet_tool.set_cursor request sets a tool-specific cursor.
 * This cursor surface may be the same as the mouse cursor, and it may be
 * the same across tools but it is possible to be more fine-grained. For
 * example, a client may set different cursors for the pen and eraser.
 *
 * Tools are generally independent of tablets and it is
 * compositor-specific policy when a tool can be removed. Common approaches
 * will likely include some form of removing a tool when all tablets the
 * tool was used on are removed.
 *
 * @section page_ifaces_tablet_v2 Interfaces
 * - @subpage page_iface_zwp_tablet_manager_v2 - controller object for graphic tablet devices
 * - @subpage page_iface_zwp_tablet_seat_v2 - controller object for graphic tablet devices of a seat
 * - @subpage page_iface_zwp_tablet_tool_v2 - a physical tablet tool
 * - @subpage page_iface_zwp_tablet_v2 - graphics tablet device
 * - @subpage page_iface_zwp_tablet_pad_ring_v2 - pad ring
 * - @subpage page_iface_zwp_tablet_pad_strip_v2 - pad strip
 * - @subpage page_iface_zwp_tablet_pad_group_v2 - a set of buttons, rings and strips
 * - @subpage page_iface_zwp_tablet_pad_v2 - a set of buttons, rings and strips
 * @section page_copyright_tablet_v2 Copyright
 * <pre>
 *
 * Copyright 2014 © Stephen "Lyude" Chandler Paul
 * Copyright 2015-2016 © Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * </pre>
 */
struct wl_seat;
struct wl_surface;
struct zwp_tablet_manager_v2;
struct zwp_tablet_pad_group_v2;
struct zwp_tablet_pad_ring_v2;
struct zwp_tablet_pad_strip_v2;
struct zwp_tablet_pad_v2;
struct zwp_tablet_seat_v2;
struct zwp_tablet_tool_v2;
struct zwp_tablet_v2;

#ifndef ZWP_TABLET_MANAGER_V2_INTERFACE
#define ZWP_TABLET_MANAGER_V2_INTERFACE
/**
 * @page page_iface_zwp_tablet_manager_v2 zwp_tablet_manager_v2
 * @section page_iface_zwp_tablet_manager_v2_desc Description
 *
 * An object that provides access to the graphics tablets available on this
 * system. All tablets are associated with a seat, to get access to the
 * actual tablets, use wp_tablet_manager.get_tablet_seat.
 * @section page_iface_zwp_tablet_manager_v2_api API
 * See @ref iface_zwp_tablet_manager_v2.
 */
/**
 * @defgroup iface_zwp_tablet_manager_v2 The zwp_tablet_manager_v2 interface
 *
 * An object that provides access to the graphics tablets available on this
 * system. All tablets are associated with a seat, to get access to the
 * actual tablets, use wp_tablet_manager.get_tablet_seat.
 */
extern const struct wl_interface zwp_tablet_manager_v2_interface;
#endif
#ifndef ZWP_TABLET_SEAT_V2_INTERFACE
#define ZWP_TABLET_SEAT_V2_INTERFACE
/**
 * @page page_iface_zwp_tablet_seat_v2 zwp_tablet_seat_v2
 * @section page_iface_zwp_tablet_seat_v2_desc Description
 *
 * An object that provides access to the graphics tablets available on this
 * seat. After binding to this interface, the compositor sends a set of
 * wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
 * @section page_iface_zwp_tablet_seat_v2_api API
 * See @ref iface_zwp_tablet_seat_v2.
 */
/**
 * @defgroup iface_zwp_tablet_seat_v2 The zwp_tablet_seat_v2 interface
 *
 * An object that provides access to the graphics tablets available on this
 * seat. After binding to this interface, the compositor sends a set of
 * wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
 */
extern const struct wl_interface zwp_tablet_seat_v2_interface;
#endif
#ifndef ZWP_TABLET_TOOL_V2_INTERFACE
#define ZWP_TABLET_TOOL_V2_INTERFACE
/**
 * @page page_iface_zwp_tablet_tool_v2 zwp_tablet_tool_v2
 * @section page_iface_zwp_tablet_tool_v2_desc Description
 *
 * An object that represents a physical tool that has been, or is
 * currently in use with a tablet in this seat. Each wp_tablet_tool
 * object stays valid until the client destroys it; the compositor
 * reuses the wp_tablet_tool object to indicate that the object's
 * respective physical tool has come into proximity of a tablet again.
 *
 * A wp_tablet_tool object's relation to a physical tool depends on the
 * tablet's ability to report serial numbers. If the tablet supports
 * this capability, then the object represents a specific physical tool
 * and can be identified even when used on multiple tablets.
 *
 * A tablet tool has a number of static characteristics, e.g. tool type,
 * hardware_serial and capabilities. These capabilities are sent in an
 * event sequence after the wp_tablet_seat.tool_added event before any
 * actual events from this tool. This initial event sequence is
 * terminated by a wp_tablet_tool.done event.
 *
 * Tablet tool events are grouped by wp_tablet_tool.frame events.
 * Any events received before a wp_tablet_tool.frame event should be
 * considered part of the same hardware state change.
 * @section page_iface_zwp_tablet_tool_v2_api API
 * See @ref iface_zwp_tablet_tool_v2.
 */
/**
 * @defgroup iface_zwp_tablet_tool_v2 The zwp_tablet_tool_v2 interface
 *
 * An object that represents a physical tool that has been, or is
 * currently in use with a tablet in this seat. Each wp_tablet_tool
 * object stays valid until the client destroys it; the compositor
 * reuses the wp_tablet_tool object to indicate that the object's
 * respective physical tool has come into proximity of a tablet again.
 *
 * A wp_tablet_tool object's relation to a physical tool depends on the
 * tablet's ability to report serial numbers. If the tablet supports
 * this capability, then the object represents a specific physical tool
 * and can be identified even when used on multiple tablets.
 *
 * A tablet tool has a number of static characteristics, e.g. tool type,
 * hardware_serial and capabilities. These capabilities are sent in an
 * event sequence after the wp_tablet_seat.tool_added event before any
 * actual events from this tool. This initial event sequence is
 * terminated by a wp_tablet_tool.done event.
 *
 * Tablet tool events are grouped by wp_tablet_tool.frame events.
 * Any events received before a wp_tablet_tool.frame event should be
 * considered part of the same hardware state change.
 */
extern const struct wl_interface zwp_tablet_tool_v2_interface;
#endif
#ifndef ZWP_TABLET_V2_INTERFACE
#define ZWP_TABLET_V2_INTERFACE
/**
 * @page page_iface_zwp_tablet_v2 zwp_tablet_v2
 * @section page_iface_zwp_tablet_v2_desc Description
 *
 * The wp_tablet interface represents one graphics tablet device. The
 * tablet interface itself does not generate events; all events are
 * generated by wp_tablet_tool objects when in proximity above a tablet.
 *
 * A tablet has a number of static characteristics, e.g. device name and
 * pid/vid. These capabilities are sent in an event sequence after the
 * wp_tablet_seat.tablet_added event. This initial event sequence is
 * terminated by a wp_tablet.done event.
 * @section page_iface_zwp_tablet_v2_api API
 * See @ref iface_zwp_tablet_v2.
 */
/**
 * @defgroup iface_zwp_tablet_v2 The zwp_tablet_v2 interface
 *
 * The wp_tablet interface represents one graphics tablet device. The
 * tablet interface itself does not generate events; all events are
 * generated by wp_tablet_tool objects when in proximity above a tablet.
 *
 * A tablet has a number of static characteristics, e.g. device name and
 * pid/vid. These capabilities are sent in an event sequence after the
 * wp_tablet_seat.tablet_added event. This initial event sequence is
 * terminated by a wp_tablet.done event.
 */
extern const struct wl_interface zwp_tablet_v2_interface;
#endif
#ifndef ZWP_TABLET_PAD_RING_V2_INTERFACE
#define ZWP_TABLET_PAD_RING_V2_INTERFACE
/**
 * @page page_iface_zwp_tablet_pad_ring_v2 zwp_tablet_pad_ring_v2
 * @section page_iface_zwp_tablet_pad_ring_v2_desc Description
 *
 * A circular interaction area, such as the touch ring on the Wacom Intuos
 * Pro series tablets.
 *
 * Events on a ring are logically grouped by the wl_tablet_pad_ring.frame
 * event.
 * @section page_iface_zwp_tablet_pad_ring_v2_api API
 * See @ref iface_zwp_tablet_pad_ring_v2.
 */
/**
 * @defgroup iface_zwp_tablet_pad_ring_v2 The zwp_tablet_pad_ring_v2 interface
 *
 * A circular interaction area, such as the touch ring on the Wacom Intuos
 * Pro series tablets.
 *
 * Events on a ring are logically grouped by the wl_tablet_pad_ring.frame
 * event.
 */
extern const struct wl_interface zwp_tablet_pad_ring_v2_interface;
#endif
#ifndef ZWP_TABLET_PAD_STRIP_V2_INTERFACE
#define ZWP_TABLET_PAD_STRIP_V2_INTERFACE
/**
 * @page page_iface_zwp_tablet_pad_strip_v2 zwp_tablet_pad_strip_v2
 * @section page_iface_zwp_tablet_pad_strip_v2_desc Description
 *
 * A linear interaction area, such as the strips found in Wacom Cintiq
 * models.
 *
 * Events on a strip are logically grouped by the wl_tablet_pad_strip.frame
 * event.
 * @section page_iface_zwp_tablet_pad_strip_v2_api API
 * See @ref iface_zwp_tablet_pad_strip_v2.
 */
/**
 * @defgroup iface_zwp_tablet_pad_strip_v2 The zwp_tablet_pad_strip_v2 interface
 *
 * A linear interaction area, such as the strips found in Wacom Cintiq
 * models.
 *
 * Events on a strip are logically grouped by the wl_tablet_pad_strip.frame
 * event.
 */
extern const struct wl_interface zwp_tablet_pad_strip_v2_interface;
#endif
#ifndef ZWP_TABLET_PAD_GROUP_V2_INTERFACE
#define ZWP_TABLET_PAD_GROUP_V2_INTERFACE
/**
 * @page page_iface_zwp_tablet_pad_group_v2 zwp_tablet_pad_group_v2
 * @section page_iface_zwp_tablet_pad_group_v2_desc Description
 *
 * A pad group describes a distinct (sub)set of buttons, rings and strips
 * present in the tablet. The criteria of this grouping is usually positional,
 * eg. if a tablet has buttons on the left and right side, 2 groups will be
 * presented. The physical arrangement of groups is undisclosed and may
 * change on the fly.
 *
 * Pad groups will announce their features during pad initialization. Between
 * the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the
 * pad group will announce the buttons, rings and strips contained in it,
 * plus the number of supported modes.
 *
 * Modes are a mechanism to allow multiple groups of actions for every element
 * in the pad group. The number of groups and available modes in each is
 * persistent across device plugs. The current mode is user-switchable, it
 * will be announced through the wp_tablet_pad_group.mode_switch event both
 * whenever it is switched, and after wp_tablet_pad.enter.
 *
 * The current mode logically applies to all elements in the pad group,
 * although it is at clients' discretion whether to actually perform different
 * actions, and/or issue the respective .set_feedback requests to notify the
 * compositor. See the wp_tablet_pad_group.mode_switch event for more details.
 * @section page_iface_zwp_tablet_pad_group_v2_api API
 * See @ref iface_zwp_tablet_pad_group_v2.
 */
/**
 * @defgroup iface_zwp_tablet_pad_group_v2 The zwp_tablet_pad_group_v2 interface
 *
 * A pad group describes a distinct (sub)set of buttons, rings and strips
 * present in the tablet. The criteria of this grouping is usually positional,
 * eg. if a tablet has buttons on the left and right side, 2 groups will be
 * presented. The physical arrangement of groups is undisclosed and may
 * change on the fly.
 *
 * Pad groups will announce their features during pad initialization. Between
 * the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the
 * pad group will announce the buttons, rings and strips contained in it,
 * plus the number of supported modes.
 *
 * Modes are a mechanism to allow multiple groups of actions for every element
 * in the pad group. The number of groups and available modes in each is
 * persistent across device plugs. The current mode is user-switchable, it
 * will be announced through the wp_tablet_pad_group.mode_switch event both
 * whenever it is switched, and after wp_tablet_pad.enter.
 *
 * The current mode logically applies to all elements in the pad group,
 * although it is at clients' discretion whether to actually perform different
 * actions, and/or issue the respective .set_feedback requests to notify the
 * compositor. See the wp_tablet_pad_group.mode_switch event for more details.
 */
extern const struct wl_interface zwp_tablet_pad_group_v2_interface;
#endif
#ifndef ZWP_TABLET_PAD_V2_INTERFACE
#define ZWP_TABLET_PAD_V2_INTERFACE
/**
 * @page page_iface_zwp_tablet_pad_v2 zwp_tablet_pad_v2
 * @section page_iface_zwp_tablet_pad_v2_desc Description
 *
 * A pad device is a set of buttons, rings and strips
 * usually physically present on the tablet device itself. Some
 * exceptions exist where the pad device is physically detached, e.g. the
 * Wacom ExpressKey Remote.
 *
 * Pad devices have no axes that control the cursor and are generally
 * auxiliary devices to the tool devices used on the tablet surface.
 *
 * A pad device has a number of static characteristics, e.g. the number
 * of rings. These capabilities are sent in an event sequence after the
 * wp_tablet_seat.pad_added event before any actual events from this pad.
 * This initial event sequence is terminated by a wp_tablet_pad.done
 * event.
 *
 * All pad features (buttons, rings and strips) are logically divided into
 * groups and all pads have at least one group. The available groups are
 * notified through the wp_tablet_pad.group event; the compositor will
 * emit one event per group before emitting wp_tablet_pad.done.
 *
 * Groups may have multiple modes. Modes allow clients to map multiple
 * actions to a single pad feature. Only one mode can be active per group,
 * although different groups may have different active modes.
 * @section page_iface_zwp_tablet_pad_v2_api API
 * See @ref iface_zwp_tablet_pad_v2.
 */
/**
 * @defgroup iface_zwp_tablet_pad_v2 The zwp_tablet_pad_v2 interface
 *
 * A pad device is a set of buttons, rings and strips
 * usually physically present on the tablet device itself. Some
 * exceptions exist where the pad device is physically detached, e.g. the
 * Wacom ExpressKey Remote.
 *
 * Pad devices have no axes that control the cursor and are generally
 * auxiliary devices to the tool devices used on the tablet surface.
 *
 * A pad device has a number of static characteristics, e.g. the number
 * of rings. These capabilities are sent in an event sequence after the
 * wp_tablet_seat.pad_added event before any actual events from this pad.
 * This initial event sequence is terminated by a wp_tablet_pad.done
 * event.
 *
 * All pad features (buttons, rings and strips) are logically divided into
 * groups and all pads have at least one group. The available groups are
 * notified through the wp_tablet_pad.group event; the compositor will
 * emit one event per group before emitting wp_tablet_pad.done.
 *
 * Groups may have multiple modes. Modes allow clients to map multiple
 * actions to a single pad feature. Only one mode can be active per group,
 * although different groups may have different active modes.
 */
extern const struct wl_interface zwp_tablet_pad_v2_interface;
#endif

#define ZWP_TABLET_MANAGER_V2_GET_TABLET_SEAT 0
#define ZWP_TABLET_MANAGER_V2_DESTROY 1


/**
 * @ingroup iface_zwp_tablet_manager_v2
 */
#define ZWP_TABLET_MANAGER_V2_GET_TABLET_SEAT_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_manager_v2
 */
#define ZWP_TABLET_MANAGER_V2_DESTROY_SINCE_VERSION 1

/** @ingroup iface_zwp_tablet_manager_v2 */
static inline void
zwp_tablet_manager_v2_set_user_data(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_manager_v2, user_data);
}

/** @ingroup iface_zwp_tablet_manager_v2 */
static inline void *
zwp_tablet_manager_v2_get_user_data(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_manager_v2);
}

static inline uint32_t
zwp_tablet_manager_v2_get_version(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_manager_v2);
}

/**
 * @ingroup iface_zwp_tablet_manager_v2
 *
 * Get the wp_tablet_seat object for the given seat. This object
 * provides access to all graphics tablets in this seat.
 */
static inline struct zwp_tablet_seat_v2 *
zwp_tablet_manager_v2_get_tablet_seat(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2, struct wl_seat *seat)
{
	struct wl_proxy *tablet_seat;

	tablet_seat = wl_proxy_marshal_flags((struct wl_proxy *) zwp_tablet_manager_v2,
			 ZWP_TABLET_MANAGER_V2_GET_TABLET_SEAT, &zwp_tablet_seat_v2_interface, wl_proxy_get_version((struct wl_proxy *) zwp_tablet_manager_v2), 0, NULL, seat);

	return (struct zwp_tablet_seat_v2 *) tablet_seat;
}

/**
 * @ingroup iface_zwp_tablet_manager_v2
 *
 * Destroy the wp_tablet_manager object. Objects created from this
 * object are unaffected and should be destroyed separately.
 */
static inline void
zwp_tablet_manager_v2_destroy(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_tablet_manager_v2,
			 ZWP_TABLET_MANAGER_V2_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_tablet_manager_v2), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_zwp_tablet_seat_v2
 * @struct zwp_tablet_seat_v2_listener
 */
struct zwp_tablet_seat_v2_listener {
	/**
	 * new device notification
	 *
	 * This event is sent whenever a new tablet becomes available on
	 * this seat. This event only provides the object id of the tablet,
	 * any static information about the tablet (device name, vid/pid,
	 * etc.) is sent through the wp_tablet interface.
	 * @param id the newly added graphics tablet
	 */
	void (*tablet_added)(void *data,
			     struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2,
			     struct zwp_tablet_v2 *id);
	/**
	 * a new tool has been used with a tablet
	 *
	 * This event is sent whenever a tool that has not previously
	 * been used with a tablet comes into use. This event only provides
	 * the object id of the tool; any static information about the tool
	 * (capabilities, type, etc.) is sent through the wp_tablet_tool
	 * interface.
	 * @param id the newly added tablet tool
	 */
	void (*tool_added)(void *data,
			   struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2,
			   struct zwp_tablet_tool_v2 *id);
	/**
	 * new pad notification
	 *
	 * This event is sent whenever a new pad is known to the system.
	 * Typically, pads are physically attached to tablets and a
	 * pad_added event is sent immediately after the
	 * wp_tablet_seat.tablet_added. However, some standalone pad
	 * devices logically attach to tablets at runtime, and the client
	 * must wait for wp_tablet_pad.enter to know the tablet a pad is
	 * attached to.
	 *
	 * This event only provides the object id of the pad. All further
	 * features (buttons, strips, rings) are sent through the
	 * wp_tablet_pad interface.
	 * @param id the newly added pad
	 */
	void (*pad_added)(void *data,
			  struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2,
			  struct zwp_tablet_pad_v2 *id);
};

/**
 * @ingroup iface_zwp_tablet_seat_v2
 */
static inline int
zwp_tablet_seat_v2_add_listener(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2,
				const struct zwp_tablet_seat_v2_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_seat_v2,
				     (void (**)(void)) listener, data);
}

#define ZWP_TABLET_SEAT_V2_DESTROY 0

/**
 * @ingroup iface_zwp_tablet_seat_v2
 */
#define ZWP_TABLET_SEAT_V2_TABLET_ADDED_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_seat_v2
 */
#define ZWP_TABLET_SEAT_V2_TOOL_ADDED_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_seat_v2
 */
#define ZWP_TABLET_SEAT_V2_PAD_ADDED_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_tablet_seat_v2
 */
#define ZWP_TABLET_SEAT_V2_DESTROY_SINCE_VERSION 1

/** @ingroup iface_zwp_tablet_seat_v2 */
static inline void
zwp_tablet_seat_v2_set_user_data(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_seat_v2, user_data);
}

/** @ingroup iface_zwp_tablet_seat_v2 */
static inline void *
zwp_tablet_seat_v2_get_user_data(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_seat_v2);
}

static inline uint32_t
zwp_tablet_seat_v2_get_version(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_seat_v2);
}

/**
 * @ingroup iface_zwp_tablet_seat_v2
 *
 * Destroy the wp_tablet_seat object. Objects created from this
 * object are unaffected and should be destroyed separately.
 */
static inline void
zwp_tablet_seat_v2_destroy(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_tablet_seat_v2,
			 ZWP_TABLET_SEAT_V2_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_tablet_seat_v2), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef ZWP_TABLET_TOOL_V2_TYPE_ENUM
#define ZWP_TABLET_TOOL_V2_TYPE_ENUM
/**
 * @ingroup iface_zwp_tablet_tool_v2
 * a physical tool type
 *
 * Describes the physical type of a tool. The physical type of a tool
 * generally defines its base usage.
 *
 * The mouse tool represents a mouse-shaped tool that is not a relative
 * device but bound to the tablet's surface, providing absolute
 * coordinates.
 *
 * The lens tool is a mouse-shaped tool with an attached lens to
 * provide precision focus.
 */
enum zwp_tablet_tool_v2_type {
	/**
	 * Pen
	 */
	ZWP_TABLET_TOOL_V2_TYPE_PEN = 0x140,
	/**
	 * Eraser
	 */
	ZWP_TABLET_TOOL_V2_TYPE_ERASER = 0x141,
	/**
	 * Brush
	 */
	ZWP_TABLET_TOOL_V2_TYPE_BRUSH = 0x142,
	/**
	 * Pencil
	 */
	ZWP_TABLET_TOOL_V2_TYPE_PENCIL = 0x143,
	/**
	 * Airbrush
	 */
	ZWP_TABLET_TOOL_V2_TYPE_AIRBRUSH = 0x144,
	/**
	 * Finger
	 */
	ZWP_TABLET_TOOL_V2_TYPE_FINGER = 0x145,
	/**
	 * Mouse
	 */
	ZWP_TABLET_TOOL_V2_TYPE_MOUSE = 0x146,
	/**
	 * Lens
	 */
	ZWP_TABLET_TOOL_V2_TYPE_LENS = 0x147,
};
#endif /* ZWP_TABLET_TOOL_V2_TYPE_ENUM */

#ifndef ZWP_TABLET_TOOL_V2_CAPABILITY_ENUM
#define ZWP_TABLET_TOOL_V2_CAPABILITY_ENUM
/**
 * @ingroup iface_zwp_tablet_tool_v2
 * capability flags for a tool
 *
 * Describes extra capabilities on a tablet.
 *
 * Any tool must provide x and y values, extra axes are
 * device-specific.
 */
enum zwp_tablet_tool_v2_capability {
	/**
	 * Tilt axes
	 */
	ZWP_TABLET_TOOL_V2_CAPABILITY_TILT = 1,
	/**
	 * Pressure axis
	 */
	ZWP_TABLET_TOOL_V2_CAPABILITY_PRESSURE = 2,
	/**
	 * Distance axis
	 */
	ZWP_TABLET_TOOL_V2_CAPABILITY_DISTANCE = 3,
	/**
	 * Z-rotation axis
	 */
	ZWP_TABLET_TOOL_V2_CAPABILITY_ROTATION = 4,
	/**
	 * Slider axis
	 */
	ZWP_TABLET_TOOL_V2_CAPABILITY_SLIDER = 5,
	/**
	 * Wheel axis
	 */
	ZWP_TABLET_TOOL_V2_CAPABILITY_WHEEL = 6,
};
#endif /* ZWP_TABLET_TOOL_V2_CAPABILITY_ENUM */

#ifndef ZWP_TABLET_TOOL_V2_BUTTON_STATE_ENUM
#define ZWP_TABLET_TOOL_V2_BUTTON_STATE_ENUM
/**
 * @ingroup iface_zwp_tablet_tool_v2
 * physical button state
 *
 * Describes the physical state of a button that produced the button event.
 */
enum zwp_tablet_tool_v2_button_state {
	/**
	 * button is not pressed
	 */
	ZWP_TABLET_TOOL_V2_BUTTON_STATE_RELEASED = 0,
	/**
	 * button is pressed
	 */
	ZWP_TABLET_TOOL_V2_BUTTON_STATE_PRESSED = 1,
};
#endif /* ZWP_TABLET_TOOL_V2_BUTTON_STATE_ENUM */

#ifndef ZWP_TABLET_TOOL_V2_ERROR_ENUM
#define ZWP_TABLET_TOOL_V2_ERROR_ENUM
enum zwp_tablet_tool_v2_error {
	/**
	 * given wl_surface has another role
	 */
	ZWP_TABLET_TOOL_V2_ERROR_ROLE = 0,
};
#endif /* ZWP_TABLET_TOOL_V2_ERROR_ENUM */

/**
 * @ingroup iface_zwp_tablet_tool_v2
 * @struct zwp_tablet_tool_v2_listener
 */
struct zwp_tablet_tool_v2_listener {
	/**
	 * tool type
	 *
	 * The tool type is the high-level type of the tool and usually
	 * decides the interaction expected from this tool.
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_tablet_tool.done event.
	 * @param tool_type the physical tool type
	 */
	void (*type)(void *data,
		     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
		     uint32_t tool_type);
	/**
	 * unique hardware serial number of the tool
	 *
	 * If the physical tool can be identified by a unique 64-bit
	 * serial number, this event notifies the client of this serial
	 * number.
	 *
	 * If multiple tablets are available in the same seat and the tool
	 * is uniquely identifiable by the serial number, that tool may
	 * move between tablets.
	 *
	 * Otherwise, if the tool has no serial number and this event is
	 * missing, the tool is tied to the tablet it first comes into
	 * proximity with. Even if the physical tool is used on multiple
	 * tablets, separate wp_tablet_tool objects will be created, one
	 * per tablet.
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_tablet_tool.done event.
	 * @param hardware_serial_hi the unique serial number of the tool, most significant bits
	 * @param hardware_serial_lo the unique serial number of the tool, least significant bits
	 */
	void (*hardware_serial)(void *data,
				struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
				uint32_t hardware_serial_hi,
				uint32_t hardware_serial_lo);
	/**
	 * hardware id notification in Wacom's format
	 *
	 * This event notifies the client of a hardware id available on
	 * this tool.
	 *
	 * The hardware id is a device-specific 64-bit id that provides
	 * extra information about the tool in use, beyond the wl_tool.type
	 * enumeration. The format of the id is specific to tablets made by
	 * Wacom Inc. For example, the hardware id of a Wacom Grip Pen (a
	 * stylus) is 0x802.
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_tablet_tool.done event.
	 * @param hardware_id_hi the hardware id, most significant bits
	 * @param hardware_id_lo the hardware id, least significant bits
	 */
	void (*hardware_id_wacom)(void *data,
				  struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
				  uint32_t hardware_id_hi,
				  uint32_t hardware_id_lo);
	/**
	 * tool capability notification
	 *
	 * This event notifies the client of any capabilities of this
	 * tool, beyond the main set of x/y axes and tip up/down detection.
	 *
	 * One event is sent for each extra capability available on this
	 * tool.
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_tablet_tool.done event.
	 * @param capability the capability
	 */
	void (*capability)(void *data,
			   struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
			   uint32_t capability);
	/**
	 * tool description events sequence complete
	 *
	 * This event signals the end of the initial burst of descriptive
	 * events. A client may consider the static description of the tool
	 * to be complete and finalize initialization of the tool.
	 */
	void (*done)(void *data,
		     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2);
	/**
	 * tool removed
	 *
	 * This event is sent when the tool is removed from the system
	 * and will send no further events. Should the physical tool come
	 * back into proximity later, a new wp_tablet_tool object will be
	 * created.
	 *
	 * It is compositor-dependent when a tool is removed. A compositor
	 * may remove a tool on proximity out, tablet removal or any other
	 * reason. A compositor may also keep a tool alive until shutdown.
	 *
	 * If the tool is currently in proximity, a proximity_out event
	 * will be sent before the removed event. See
	 * wp_tablet_tool.proximity_out for the handling of any buttons
	 * logically down.
	 *
	 * When this event is received, the client must
	 * wp_tablet_tool.destroy the object.
	 */
	void (*removed)(void *data,
			struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2);
	/**
	 * proximity in event
	 *
	 * Notification that this tool is focused on a certain surface.
	 *
	 * This event can be received when the tool has moved from one
	 * surface to another, or when the tool has come back into
	 * proximity above the surface.
	 *
	 * If any button is logically down when the tool comes into
	 * proximity, the respective button event is sent after the
	 * proximity_in event but within the same frame as the proximity_in
	 * event.
	 * @param tablet The tablet the tool is in proximity of
	 * @param surface The current surface the tablet tool is over
	 */
	void (*proximity_in)(void *data,
			     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
			     uint32_t serial,
			     struct zwp_tablet_v2 *tablet,
			     struct wl_surface *surface);
	/**
	 * proximity out event
	 *
	 * Notification that this tool has either left proximity, or is
	 * no longer focused on a certain surface.
	 *
	 * When the tablet tool leaves proximity of the tablet, button
	 * release events are sent for each button that was held down at
	 * the time of leaving proximity. These events are sent before the
	 * proximity_out event but within the same wp_tablet.frame.
	 *
	 * If the tool stays within proximity of the tablet, but the focus
	 * changes from one surface to another, a button release event may
	 * not be sent until the button is actually released or the tool
	 * leaves the proximity of the tablet.
	 */
	void (*proximity_out)(void *data,
			      struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2);
	/**
	 * tablet tool is making contact
	 *
	 * Sent whenever the tablet tool comes in contact with the
	 * surface of the tablet.
	 *
	 * If the tool is already in contact with the tablet when entering
	 * the input region, the client owning said region will receive a
	 * wp_tablet.proximity_in event, followed by a wp_tablet.down event
	 * and a wp_tablet.frame event.
	 *
	 * Note that this event describes logical contact, not physical
	 * contact. On some devices, a compositor may not consider a tool
	 * in logical contact until a minimum physical pressure threshold
	 * is exceeded.
	 */
	void (*down)(void *data,
		     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
		     uint32_t serial);
	/**
	 * tablet tool is no longer making contact
	 *
	 * Sent whenever the tablet tool stops making contact with the
	 * surface of the tablet, or when the tablet tool moves out of the
	 * input region and the compositor grab (if any) is dismissed.
	 *
	 * If the tablet tool moves out of the input region while in
	 * contact with the surface of the tablet and the compositor does
	 * not have an ongoing grab on the surface, the client owning said
	 * region will receive a wp_tablet.up event, followed by a
	 * wp_tablet.proximity_out event and a wp_tablet.frame event. If
	 * the compositor has an ongoing grab on this device, this event
	 * sequence is sent whenever the grab is dismissed in the future.
	 *
	 * Note that this event describes logical contact, not physical
	 * contact. On some devices, a compositor may not consider a tool
	 * out of logical contact until physical pressure falls below a
	 * specific threshold.
	 */
	void (*up)(void *data,
		   struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2);
	/**
	 * motion event
	 *
	 * Sent whenever a tablet tool moves.
	 * @param x surface-local x coordinate
	 * @param y surface-local y coordinate
	 */
	void (*motion)(void *data,
		       struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
		       wl_fixed_t x,
		       wl_fixed_t y);
	/**
	 * pressure change event
	 *
	 * Sent whenever the pressure axis on a tool changes. The value
	 * of this event is normalized to a value between 0 and 65535.
	 *
	 * Note that pressure may be nonzero even when a tool is not in
	 * logical contact. See the down and up events for more details.
	 * @param pressure The current pressure value
	 */
	void (*pressure)(void *data,
			 struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
			 uint32_t pressure);
	/**
	 * distance change event
	 *
	 * Sent whenever the distance axis on a tool changes. The value
	 * of this event is normalized to a value between 0 and 65535.
	 *
	 * Note that distance may be nonzero even when a tool is not in
	 * logical contact. See the down and up events for more details.
	 * @param distance The current distance value
	 */
	void (*distance)(void *data,
			 struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
			 uint32_t distance);
	/**
	 * tilt change event
	 *
	 * Sent whenever one or both of the tilt axes on a tool change.
	 * Each tilt value is in degrees, relative to the z-axis of the
	 * tablet. The angle is positive when the top of a tool tilts along
	 * the positive x or y axis.
	 * @param tilt_x The current value of the X tilt axis
	 * @param tilt_y The current value of the Y tilt axis
	 */
	void (*tilt)(void *data,
		     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
		     wl_fixed_t tilt_x,
		     wl_fixed_t tilt_y);
	/**
	 * z-rotation change event
	 *
	 * Sent whenever the z-rotation axis on the tool changes. The
	 * rotation value is in degrees clockwise from the tool's logical
	 * neutral position.
	 * @param degrees The current rotation of the Z axis
	 */
	void (*rotation)(void *data,
			 struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
			 wl_fixed_t degrees);
	/**
	 * Slider position change event
	 *
	 * Sent whenever the slider position on the tool changes. The
	 * value is normalized between -65535 and 65535, with 0 as the
	 * logical neutral position of the slider.
	 *
	 * The slider is available on e.g. the Wacom Airbrush tool.
	 * @param position The current position of slider
	 */
	void (*slider)(void *data,
		       struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
		       int32_t position);
	/**
	 * Wheel delta event
	 *
	 * Sent whenever the wheel on the tool emits an event. This event
	 * contains two values for the same axis change. The degrees value
	 * is in the same orientation as the wl_pointer.vertical_scroll
	 * axis. The clicks value is in discrete logical clicks of the
	 * mouse wheel. This value may be zero if the movement of the wheel
	 * was less than one logical click.
	 *
	 * Clients should choose either value and avoid mixing degrees and
	 * clicks. The compositor may accumulate values smaller than a
	 * logical click and emulate click events when a certain threshold
	 * is met. Thus, wl_tablet_tool.wheel events with non-zero clicks
	 * values may have different degrees values.
	 * @param degrees The wheel delta in degrees
	 * @param clicks The wheel delta in discrete clicks
	 */
	void (*wheel)(void *data,
		      struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
		      wl_fixed_t degrees,
		      int32_t clicks);
	/**
	 * button event
	 *
	 * Sent whenever a button on the tool is pressed or released.
	 *
	 * If a button is held down when the tool moves in or out of
	 * proximity, button events are generated by the compositor. See
	 * wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
	 * details.
	 * @param button The button whose state has changed
	 * @param state Whether the button was pressed or released
	 */
	void (*button)(void *data,
		       struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
		       uint32_t serial,
		       uint32_t button,
		       uint32_t state);
	/**
	 * frame event
	 *
	 * Marks the end of a series of axis and/or button updates from
	 * the tablet. The Wayland protocol requires axis updates to be
	 * sent sequentially, however all events within a frame should be
	 * considered one hardware event.
	 * @param time The time of the event with millisecond granularity
	 */
	void (*frame)(void *data,
		      struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
		      uint32_t time);
};

/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
static inline int
zwp_tablet_tool_v2_add_listener(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
				const struct zwp_tablet_tool_v2_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_tool_v2,
				     (void (**)(void)) listener, data);
}

#define ZWP_TABLET_TOOL_V2_SET_CURSOR 0
#define ZWP_TABLET_TOOL_V2_DESTROY 1

/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_TYPE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_HARDWARE_SERIAL_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_HARDWARE_ID_WACOM_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_CAPABILITY_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_DONE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_REMOVED_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_PROXIMITY_IN_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_PROXIMITY_OUT_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_DOWN_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_UP_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_MOTION_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_PRESSURE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_DISTANCE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_TILT_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_ROTATION_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_SLIDER_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_WHEEL_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_BUTTON_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_FRAME_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_SET_CURSOR_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_tool_v2
 */
#define ZWP_TABLET_TOOL_V2_DESTROY_SINCE_VERSION 1

/** @ingroup iface_zwp_tablet_tool_v2 */
static inline void
zwp_tablet_tool_v2_set_user_data(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_tool_v2, user_data);
}

/** @ingroup iface_zwp_tablet_tool_v2 */
static inline void *
zwp_tablet_tool_v2_get_user_data(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_tool_v2);
}

static inline uint32_t
zwp_tablet_tool_v2_get_version(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_tool_v2);
}

/**
 * @ingroup iface_zwp_tablet_tool_v2
 *
 * Sets the surface of the cursor used for this tool on the given
 * tablet. This request only takes effect if the tool is in proximity
 * of one of the requesting client's surfaces or the surface parameter
 * is the current pointer surface. If there was a previous surface set
 * with this request it is replaced. If surface is NULL, the cursor
 * image is hidden.
 *
 * The parameters hotspot_x and hotspot_y define the position of the
 * pointer surface relative to the pointer location. Its top-left corner
 * is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
 * coordinates of the pointer location, in surface-local coordinates.
 *
 * On surface.attach requests to the pointer surface, hotspot_x and
 * hotspot_y are decremented by the x and y parameters passed to the
 * request. Attach must be confirmed by wl_surface.commit as usual.
 *
 * The hotspot can also be updated by passing the currently set pointer
 * surface to this request with new values for hotspot_x and hotspot_y.
 *
 * The current and pending input regions of the wl_surface are cleared,
 * and wl_surface.set_input_region is ignored until the wl_surface is no
 * longer used as the cursor. When the use as a cursor ends, the current
 * and pending input regions become undefined, and the wl_surface is
 * unmapped.
 *
 * This request gives the surface the role of a wp_tablet_tool cursor. A
 * surface may only ever be used as the cursor surface for one
 * wp_tablet_tool. If the surface already has another role or has
 * previously been used as cursor surface for a different tool, a
 * protocol error is raised.
 */
static inline void
zwp_tablet_tool_v2_set_cursor(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2, uint32_t serial, struct wl_surface *surface, int32_t hotspot_x, int32_t hotspot_y)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_tablet_tool_v2,
			 ZWP_TABLET_TOOL_V2_SET_CURSOR, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_tablet_tool_v2), 0, serial, surface, hotspot_x, hotspot_y);
}

/**
 * @ingroup iface_zwp_tablet_tool_v2
 *
 * This destroys the client's resource for this tool object.
 */
static inline void
zwp_tablet_tool_v2_destroy(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_tablet_tool_v2,
			 ZWP_TABLET_TOOL_V2_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_tablet_tool_v2), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_zwp_tablet_v2
 * @struct zwp_tablet_v2_listener
 */
struct zwp_tablet_v2_listener {
	/**
	 * tablet device name
	 *
	 * A descriptive name for the tablet device.
	 *
	 * If the device has no descriptive name, this event is not sent.
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_tablet.done event.
	 * @param name the device name
	 */
	void (*name)(void *data,
		     struct zwp_tablet_v2 *zwp_tablet_v2,
		     const char *name);
	/**
	 * tablet device USB vendor/product id
	 *
	 * The USB vendor and product IDs for the tablet device.
	 *
	 * If the device has no USB vendor/product ID, this event is not
	 * sent. This can happen for virtual devices or non-USB devices,
	 * for instance.
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_tablet.done event.
	 * @param vid USB vendor id
	 * @param pid USB product id
	 */
	void (*id)(void *data,
		   struct zwp_tablet_v2 *zwp_tablet_v2,
		   uint32_t vid,
		   uint32_t pid);
	/**
	 * path to the device
	 *
	 * A system-specific device path that indicates which device is
	 * behind this wp_tablet. This information may be used to gather
	 * additional information about the device, e.g. through libwacom.
	 *
	 * A device may have more than one device path. If so, multiple
	 * wp_tablet.path events are sent. A device may be emulated and not
	 * have a device path, and in that case this event will not be
	 * sent.
	 *
	 * The format of the path is unspecified, it may be a device node,
	 * a sysfs path, or some other identifier. It is up to the client
	 * to identify the string provided.
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_tablet.done event.
	 * @param path path to local device
	 */
	void (*path)(void *data,
		     struct zwp_tablet_v2 *zwp_tablet_v2,
		     const char *path);
	/**
	 * tablet description events sequence complete
	 *
	 * This event is sent immediately to signal the end of the
	 * initial burst of descriptive events. A client may consider the
	 * static description of the tablet to be complete and finalize
	 * initialization of the tablet.
	 */
	void (*done)(void *data,
		     struct zwp_tablet_v2 *zwp_tablet_v2);
	/**
	 * tablet removed event
	 *
	 * Sent when the tablet has been removed from the system. When a
	 * tablet is removed, some tools may be removed.
	 *
	 * When this event is received, the client must wp_tablet.destroy
	 * the object.
	 */
	void (*removed)(void *data,
			struct zwp_tablet_v2 *zwp_tablet_v2);
};

/**
 * @ingroup iface_zwp_tablet_v2
 */
static inline int
zwp_tablet_v2_add_listener(struct zwp_tablet_v2 *zwp_tablet_v2,
			   const struct zwp_tablet_v2_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_v2,
				     (void (**)(void)) listener, data);
}

#define ZWP_TABLET_V2_DESTROY 0

/**
 * @ingroup iface_zwp_tablet_v2
 */
#define ZWP_TABLET_V2_NAME_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_v2
 */
#define ZWP_TABLET_V2_ID_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_v2
 */
#define ZWP_TABLET_V2_PATH_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_v2
 */
#define ZWP_TABLET_V2_DONE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_v2
 */
#define ZWP_TABLET_V2_REMOVED_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_tablet_v2
 */
#define ZWP_TABLET_V2_DESTROY_SINCE_VERSION 1

/** @ingroup iface_zwp_tablet_v2 */
static inline void
zwp_tablet_v2_set_user_data(struct zwp_tablet_v2 *zwp_tablet_v2, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_v2, user_data);
}

/** @ingroup iface_zwp_tablet_v2 */
static inline void *
zwp_tablet_v2_get_user_data(struct zwp_tablet_v2 *zwp_tablet_v2)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_v2);
}

static inline uint32_t
zwp_tablet_v2_get_version(struct zwp_tablet_v2 *zwp_tablet_v2)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_v2);
}

/**
 * @ingroup iface_zwp_tablet_v2
 *
 * This destroys the client's resource for this tablet object.
 */
static inline void
zwp_tablet_v2_destroy(struct zwp_tablet_v2 *zwp_tablet_v2)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_tablet_v2,
			 ZWP_TABLET_V2_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_tablet_v2), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef ZWP_TABLET_PAD_RING_V2_SOURCE_ENUM
#define ZWP_TABLET_PAD_RING_V2_SOURCE_ENUM
/**
 * @ingroup iface_zwp_tablet_pad_ring_v2
 * ring axis source
 *
 * Describes the source types for ring events. This indicates to the
 * client how a ring event was physically generated; a client may
 * adjust the user interface accordingly. For example, events
 * from a "finger" source may trigger kinetic scrolling.
 */
enum zwp_tablet_pad_ring_v2_source {
	/**
	 * finger
	 */
	ZWP_TABLET_PAD_RING_V2_SOURCE_FINGER = 1,
};
#endif /* ZWP_TABLET_PAD_RING_V2_SOURCE_ENUM */

/**
 * @ingroup iface_zwp_tablet_pad_ring_v2
 * @struct zwp_tablet_pad_ring_v2_listener
 */
struct zwp_tablet_pad_ring_v2_listener {
	/**
	 * ring event source
	 *
	 * Source information for ring events.
	 *
	 * This event does not occur on its own. It is sent before a
	 * wp_tablet_pad_ring.frame event and carries the source
	 * information for all events within that frame.
	 *
	 * The source specifies how this event was generated. If the source
	 * is wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop
	 * event will be sent when the user lifts the finger off the
	 * device.
	 *
	 * This event is optional. If the source is unknown for an
	 * interaction, no event is sent.
	 * @param source the event source
	 */
	void (*source)(void *data,
		       struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
		       uint32_t source);
	/**
	 * angle changed
	 *
	 * Sent whenever the angle on a ring changes.
	 *
	 * The angle is provided in degrees clockwise from the logical
	 * north of the ring in the pad's current rotation.
	 * @param degrees the current angle in degrees
	 */
	void (*angle)(void *data,
		      struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
		      wl_fixed_t degrees);
	/**
	 * interaction stopped
	 *
	 * Stop notification for ring events.
	 *
	 * For some wp_tablet_pad_ring.source types, a
	 * wp_tablet_pad_ring.stop event is sent to notify a client that
	 * the interaction with the ring has terminated. This enables the
	 * client to implement kinetic scrolling. See the
	 * wp_tablet_pad_ring.source documentation for information on when
	 * this event may be generated.
	 *
	 * Any wp_tablet_pad_ring.angle events with the same source after
	 * this event should be considered as the start of a new
	 * interaction.
	 */
	void (*stop)(void *data,
		     struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2);
	/**
	 * end of a ring event sequence
	 *
	 * Indicates the end of a set of ring events that logically
	 * belong together. A client is expected to accumulate the data in
	 * all events within the frame before proceeding.
	 *
	 * All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame
	 * event belong logically together. For example, on termination of
	 * a finger interaction on a ring the compositor will send a
	 * wp_tablet_pad_ring.source event, a wp_tablet_pad_ring.stop event
	 * and a wp_tablet_pad_ring.frame event.
	 *
	 * A wp_tablet_pad_ring.frame event is sent for every logical event
	 * group, even if the group only contains a single
	 * wp_tablet_pad_ring event. Specifically, a client may get a
	 * sequence: angle, frame, angle, frame, etc.
	 * @param time timestamp with millisecond granularity
	 */
	void (*frame)(void *data,
		      struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
		      uint32_t time);
};

/**
 * @ingroup iface_zwp_tablet_pad_ring_v2
 */
static inline int
zwp_tablet_pad_ring_v2_add_listener(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
				    const struct zwp_tablet_pad_ring_v2_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_pad_ring_v2,
				     (void (**)(void)) listener, data);
}

#define ZWP_TABLET_PAD_RING_V2_SET_FEEDBACK 0
#define ZWP_TABLET_PAD_RING_V2_DESTROY 1

/**
 * @ingroup iface_zwp_tablet_pad_ring_v2
 */
#define ZWP_TABLET_PAD_RING_V2_SOURCE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_ring_v2
 */
#define ZWP_TABLET_PAD_RING_V2_ANGLE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_ring_v2
 */
#define ZWP_TABLET_PAD_RING_V2_STOP_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_ring_v2
 */
#define ZWP_TABLET_PAD_RING_V2_FRAME_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_tablet_pad_ring_v2
 */
#define ZWP_TABLET_PAD_RING_V2_SET_FEEDBACK_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_ring_v2
 */
#define ZWP_TABLET_PAD_RING_V2_DESTROY_SINCE_VERSION 1

/** @ingroup iface_zwp_tablet_pad_ring_v2 */
static inline void
zwp_tablet_pad_ring_v2_set_user_data(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_pad_ring_v2, user_data);
}

/** @ingroup iface_zwp_tablet_pad_ring_v2 */
static inline void *
zwp_tablet_pad_ring_v2_get_user_data(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_pad_ring_v2);
}

static inline uint32_t
zwp_tablet_pad_ring_v2_get_version(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_ring_v2);
}

/**
 * @ingroup iface_zwp_tablet_pad_ring_v2
 *
 * Request that the compositor use the provided feedback string
 * associated with this ring. This request should be issued immediately
 * after a wp_tablet_pad_group.mode_switch event from the corresponding
 * group is received, or whenever the ring is mapped to a different
 * action. See wp_tablet_pad_group.mode_switch for more details.
 *
 * Clients are encouraged to provide context-aware descriptions for
 * the actions associated with the ring; compositors may use this
 * information to offer visual feedback about the button layout
 * (eg. on-screen displays).
 *
 * The provided string 'description' is a UTF-8 encoded string to be
 * associated with this ring, and is considered user-visible; general
 * internationalization rules apply.
 *
 * The serial argument will be that of the last
 * wp_tablet_pad_group.mode_switch event received for the group of this
 * ring. Requests providing other serials than the most recent one will be
 * ignored.
 */
static inline void
zwp_tablet_pad_ring_v2_set_feedback(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2, const char *description, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_tablet_pad_ring_v2,
			 ZWP_TABLET_PAD_RING_V2_SET_FEEDBACK, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_ring_v2), 0, description, serial);
}

/**
 * @ingroup iface_zwp_tablet_pad_ring_v2
 *
 * This destroys the client's resource for this ring object.
 */
static inline void
zwp_tablet_pad_ring_v2_destroy(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_tablet_pad_ring_v2,
			 ZWP_TABLET_PAD_RING_V2_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_ring_v2), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef ZWP_TABLET_PAD_STRIP_V2_SOURCE_ENUM
#define ZWP_TABLET_PAD_STRIP_V2_SOURCE_ENUM
/**
 * @ingroup iface_zwp_tablet_pad_strip_v2
 * strip axis source
 *
 * Describes the source types for strip events. This indicates to the
 * client how a strip event was physically generated; a client may
 * adjust the user interface accordingly. For example, events
 * from a "finger" source may trigger kinetic scrolling.
 */
enum zwp_tablet_pad_strip_v2_source {
	/**
	 * finger
	 */
	ZWP_TABLET_PAD_STRIP_V2_SOURCE_FINGER = 1,
};
#endif /* ZWP_TABLET_PAD_STRIP_V2_SOURCE_ENUM */

/**
 * @ingroup iface_zwp_tablet_pad_strip_v2
 * @struct zwp_tablet_pad_strip_v2_listener
 */
struct zwp_tablet_pad_strip_v2_listener {
	/**
	 * strip event source
	 *
	 * Source information for strip events.
	 *
	 * This event does not occur on its own. It is sent before a
	 * wp_tablet_pad_strip.frame event and carries the source
	 * information for all events within that frame.
	 *
	 * The source specifies how this event was generated. If the source
	 * is wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop
	 * event will be sent when the user lifts their finger off the
	 * device.
	 *
	 * This event is optional. If the source is unknown for an
	 * interaction, no event is sent.
	 * @param source the event source
	 */
	void (*source)(void *data,
		       struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
		       uint32_t source);
	/**
	 * position changed
	 *
	 * Sent whenever the position on a strip changes.
	 *
	 * The position is normalized to a range of [0, 65535], the 0-value
	 * represents the top-most and/or left-most position of the strip
	 * in the pad's current rotation.
	 * @param position the current position
	 */
	void (*position)(void *data,
			 struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
			 uint32_t position);
	/**
	 * interaction stopped
	 *
	 * Stop notification for strip events.
	 *
	 * For some wp_tablet_pad_strip.source types, a
	 * wp_tablet_pad_strip.stop event is sent to notify a client that
	 * the interaction with the strip has terminated. This enables the
	 * client to implement kinetic scrolling. See the
	 * wp_tablet_pad_strip.source documentation for information on when
	 * this event may be generated.
	 *
	 * Any wp_tablet_pad_strip.position events with the same source
	 * after this event should be considered as the start of a new
	 * interaction.
	 */
	void (*stop)(void *data,
		     struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2);
	/**
	 * end of a strip event sequence
	 *
	 * Indicates the end of a set of events that represent one
	 * logical hardware strip event. A client is expected to accumulate
	 * the data in all events within the frame before proceeding.
	 *
	 * All wp_tablet_pad_strip events before a
	 * wp_tablet_pad_strip.frame event belong logically together. For
	 * example, on termination of a finger interaction on a strip the
	 * compositor will send a wp_tablet_pad_strip.source event, a
	 * wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame
	 * event.
	 *
	 * A wp_tablet_pad_strip.frame event is sent for every logical
	 * event group, even if the group only contains a single
	 * wp_tablet_pad_strip event. Specifically, a client may get a
	 * sequence: position, frame, position, frame, etc.
	 * @param time timestamp with millisecond granularity
	 */
	void (*frame)(void *data,
		      struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
		      uint32_t time);
};

/**
 * @ingroup iface_zwp_tablet_pad_strip_v2
 */
static inline int
zwp_tablet_pad_strip_v2_add_listener(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
				     const struct zwp_tablet_pad_strip_v2_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_pad_strip_v2,
				     (void (**)(void)) listener, data);
}

#define ZWP_TABLET_PAD_STRIP_V2_SET_FEEDBACK 0
#define ZWP_TABLET_PAD_STRIP_V2_DESTROY 1

/**
 * @ingroup iface_zwp_tablet_pad_strip_v2
 */
#define ZWP_TABLET_PAD_STRIP_V2_SOURCE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_strip_v2
 */
#define ZWP_TABLET_PAD_STRIP_V2_POSITION_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_strip_v2
 */
#define ZWP_TABLET_PAD_STRIP_V2_STOP_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_strip_v2
 */
#define ZWP_TABLET_PAD_STRIP_V2_FRAME_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_tablet_pad_strip_v2
 */
#define ZWP_TABLET_PAD_STRIP_V2_SET_FEEDBACK_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_strip_v2
 */
#define ZWP_TABLET_PAD_STRIP_V2_DESTROY_SINCE_VERSION 1

/** @ingroup iface_zwp_tablet_pad_strip_v2 */
static inline void
zwp_tablet_pad_strip_v2_set_user_data(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_pad_strip_v2, user_data);
}

/** @ingroup iface_zwp_tablet_pad_strip_v2 */
static inline void *
zwp_tablet_pad_strip_v2_get_user_data(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_pad_strip_v2);
}

static inline uint32_t
zwp_tablet_pad_strip_v2_get_version(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_strip_v2);
}

/**
 * @ingroup iface_zwp_tablet_pad_strip_v2
 *
 * Requests the compositor to use the provided feedback string
 * associated with this strip. This request should be issued immediately
 * after a wp_tablet_pad_group.mode_switch event from the corresponding
 * group is received, or whenever the strip is mapped to a different
 * action. See wp_tablet_pad_group.mode_switch for more details.
 *
 * Clients are encouraged to provide context-aware descriptions for
 * the actions associated with the strip, and compositors may use this
 * information to offer visual feedback about the button layout
 * (eg. on-screen displays).
 *
 * The provided string 'description' is a UTF-8 encoded string to be
 * associated with this ring, and is considered user-visible; general
 * internationalization rules apply.
 *
 * The serial argument will be that of the last
 * wp_tablet_pad_group.mode_switch event received for the group of this
 * strip. Requests providing other serials than the most recent one will be
 * ignored.
 */
static inline void
zwp_tablet_pad_strip_v2_set_feedback(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2, const char *description, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_tablet_pad_strip_v2,
			 ZWP_TABLET_PAD_STRIP_V2_SET_FEEDBACK, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_strip_v2), 0, description, serial);
}

/**
 * @ingroup iface_zwp_tablet_pad_strip_v2
 *
 * This destroys the client's resource for this strip object.
 */
static inline void
zwp_tablet_pad_strip_v2_destroy(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_tablet_pad_strip_v2,
			 ZWP_TABLET_PAD_STRIP_V2_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_strip_v2), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_zwp_tablet_pad_group_v2
 * @struct zwp_tablet_pad_group_v2_listener
 */
struct zwp_tablet_pad_group_v2_listener {
	/**
	 * buttons announced
	 *
	 * Sent on wp_tablet_pad_group initialization to announce the
	 * available buttons in the group. Button indices start at 0, a
	 * button may only be in one group at a time.
	 *
	 * This event is first sent in the initial burst of events before
	 * the wp_tablet_pad_group.done event.
	 *
	 * Some buttons are reserved by the compositor. These buttons may
	 * not be assigned to any wp_tablet_pad_group. Compositors may
	 * broadcast this event in the case of changes to the mapping of
	 * these reserved buttons. If the compositor happens to reserve all
	 * buttons in a group, this event will be sent with an empty array.
	 * @param buttons buttons in this group
	 */
	void (*buttons)(void *data,
			struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
			struct wl_array *buttons);
	/**
	 * ring announced
	 *
	 * Sent on wp_tablet_pad_group initialization to announce
	 * available rings. One event is sent for each ring available on
	 * this pad group.
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_tablet_pad_group.done event.
	 */
	void (*ring)(void *data,
		     struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
		     struct zwp_tablet_pad_ring_v2 *ring);
	/**
	 * strip announced
	 *
	 * Sent on wp_tablet_pad initialization to announce available
	 * strips. One event is sent for each strip available on this pad
	 * group.
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_tablet_pad_group.done event.
	 */
	void (*strip)(void *data,
		      struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
		      struct zwp_tablet_pad_strip_v2 *strip);
	/**
	 * mode-switch ability announced
	 *
	 * Sent on wp_tablet_pad_group initialization to announce that
	 * the pad group may switch between modes. A client may use a mode
	 * to store a specific configuration for buttons, rings and strips
	 * and use the wl_tablet_pad_group.mode_switch event to toggle
	 * between these configurations. Mode indices start at 0.
	 *
	 * Switching modes is compositor-dependent. See the
	 * wp_tablet_pad_group.mode_switch event for more details.
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_tablet_pad_group.done event. This event is only sent when
	 * more than more than one mode is available.
	 * @param modes the number of modes
	 */
	void (*modes)(void *data,
		      struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
		      uint32_t modes);
	/**
	 * tablet group description events sequence complete
	 *
	 * This event is sent immediately to signal the end of the
	 * initial burst of descriptive events. A client may consider the
	 * static description of the tablet to be complete and finalize
	 * initialization of the tablet group.
	 */
	void (*done)(void *data,
		     struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2);
	/**
	 * mode switch event
	 *
	 * Notification that the mode was switched.
	 *
	 * A mode applies to all buttons, rings and strips in a group
	 * simultaneously, but a client is not required to assign different
	 * actions for each mode. For example, a client may have
	 * mode-specific button mappings but map the ring to vertical
	 * scrolling in all modes. Mode indices start at 0.
	 *
	 * Switching modes is compositor-dependent. The compositor may
	 * provide visual cues to the user about the mode, e.g. by toggling
	 * LEDs on the tablet device. Mode-switching may be
	 * software-controlled or controlled by one or more physical
	 * buttons. For example, on a Wacom Intuos Pro, the button inside
	 * the ring may be assigned to switch between modes.
	 *
	 * The compositor will also send this event after
	 * wp_tablet_pad.enter on each group in order to notify of the
	 * current mode. Groups that only feature one mode will use mode=0
	 * when emitting this event.
	 *
	 * If a button action in the new mode differs from the action in
	 * the previous mode, the client should immediately issue a
	 * wp_tablet_pad.set_feedback request for each changed button.
	 *
	 * If a ring or strip action in the new mode differs from the
	 * action in the previous mode, the client should immediately issue
	 * a wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback
	 * request for each changed ring or strip.
	 * @param time the time of the event with millisecond granularity
	 * @param mode the new mode of the pad
	 */
	void (*mode_switch)(void *data,
			    struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
			    uint32_t time,
			    uint32_t serial,
			    uint32_t mode);
};

/**
 * @ingroup iface_zwp_tablet_pad_group_v2
 */
static inline int
zwp_tablet_pad_group_v2_add_listener(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
				     const struct zwp_tablet_pad_group_v2_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_pad_group_v2,
				     (void (**)(void)) listener, data);
}

#define ZWP_TABLET_PAD_GROUP_V2_DESTROY 0

/**
 * @ingroup iface_zwp_tablet_pad_group_v2
 */
#define ZWP_TABLET_PAD_GROUP_V2_BUTTONS_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_group_v2
 */
#define ZWP_TABLET_PAD_GROUP_V2_RING_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_group_v2
 */
#define ZWP_TABLET_PAD_GROUP_V2_STRIP_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_group_v2
 */
#define ZWP_TABLET_PAD_GROUP_V2_MODES_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_group_v2
 */
#define ZWP_TABLET_PAD_GROUP_V2_DONE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_group_v2
 */
#define ZWP_TABLET_PAD_GROUP_V2_MODE_SWITCH_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_tablet_pad_group_v2
 */
#define ZWP_TABLET_PAD_GROUP_V2_DESTROY_SINCE_VERSION 1

/** @ingroup iface_zwp_tablet_pad_group_v2 */
static inline void
zwp_tablet_pad_group_v2_set_user_data(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_pad_group_v2, user_data);
}

/** @ingroup iface_zwp_tablet_pad_group_v2 */
static inline void *
zwp_tablet_pad_group_v2_get_user_data(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_pad_group_v2);
}

static inline uint32_t
zwp_tablet_pad_group_v2_get_version(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_group_v2);
}

/**
 * @ingroup iface_zwp_tablet_pad_group_v2
 *
 * Destroy the wp_tablet_pad_group object. Objects created from this object
 * are unaffected and should be destroyed separately.
 */
static inline void
zwp_tablet_pad_group_v2_destroy(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_tablet_pad_group_v2,
			 ZWP_TABLET_PAD_GROUP_V2_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_group_v2), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef ZWP_TABLET_PAD_V2_BUTTON_STATE_ENUM
#define ZWP_TABLET_PAD_V2_BUTTON_STATE_ENUM
/**
 * @ingroup iface_zwp_tablet_pad_v2
 * physical button state
 *
 * Describes the physical state of a button that caused the button
 * event.
 */
enum zwp_tablet_pad_v2_button_state {
	/**
	 * the button is not pressed
	 */
	ZWP_TABLET_PAD_V2_BUTTON_STATE_RELEASED = 0,
	/**
	 * the button is pressed
	 */
	ZWP_TABLET_PAD_V2_BUTTON_STATE_PRESSED = 1,
};
#endif /* ZWP_TABLET_PAD_V2_BUTTON_STATE_ENUM */

/**
 * @ingroup iface_zwp_tablet_pad_v2
 * @struct zwp_tablet_pad_v2_listener
 */
struct zwp_tablet_pad_v2_listener {
	/**
	 * group announced
	 *
	 * Sent on wp_tablet_pad initialization to announce available
	 * groups. One event is sent for each pad group available.
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_tablet_pad.done event. At least one group will be announced.
	 */
	void (*group)(void *data,
		      struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
		      struct zwp_tablet_pad_group_v2 *pad_group);
	/**
	 * path to the device
	 *
	 * A system-specific device path that indicates which device is
	 * behind this wp_tablet_pad. This information may be used to
	 * gather additional information about the device, e.g. through
	 * libwacom.
	 *
	 * The format of the path is unspecified, it may be a device node,
	 * a sysfs path, or some other identifier. It is up to the client
	 * to identify the string provided.
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_tablet_pad.done event.
	 * @param path path to local device
	 */
	void (*path)(void *data,
		     struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
		     const char *path);
	/**
	 * buttons announced
	 *
	 * Sent on wp_tablet_pad initialization to announce the available
	 * buttons.
	 *
	 * This event is sent in the initial burst of events before the
	 * wp_tablet_pad.done event. This event is only sent when at least
	 * one button is available.
	 * @param buttons the number of buttons
	 */
	void (*buttons)(void *data,
			struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
			uint32_t buttons);
	/**
	 * pad description event sequence complete
	 *
	 * This event signals the end of the initial burst of descriptive
	 * events. A client may consider the static description of the pad
	 * to be complete and finalize initialization of the pad.
	 */
	void (*done)(void *data,
		     struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2);
	/**
	 * physical button state
	 *
	 * Sent whenever the physical state of a button changes.
	 * @param time the time of the event with millisecond granularity
	 * @param button the index of the button that changed state
	 */
	void (*button)(void *data,
		       struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
		       uint32_t time,
		       uint32_t button,
		       uint32_t state);
	/**
	 * enter event
	 *
	 * Notification that this pad is focused on the specified
	 * surface.
	 * @param serial serial number of the enter event
	 * @param tablet the tablet the pad is attached to
	 * @param surface surface the pad is focused on
	 */
	void (*enter)(void *data,
		      struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
		      uint32_t serial,
		      struct zwp_tablet_v2 *tablet,
		      struct wl_surface *surface);
	/**
	 * leave event
	 *
	 * Notification that this pad is no longer focused on the
	 * specified surface.
	 * @param serial serial number of the leave event
	 * @param surface surface the pad is no longer focused on
	 */
	void (*leave)(void *data,
		      struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
		      uint32_t serial,
		      struct wl_surface *surface);
	/**
	 * pad removed event
	 *
	 * Sent when the pad has been removed from the system. When a
	 * tablet is removed its pad(s) will be removed too.
	 *
	 * When this event is received, the client must destroy all rings,
	 * strips and groups that were offered by this pad, and issue
	 * wp_tablet_pad.destroy the pad itself.
	 */
	void (*removed)(void *data,
			struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2);
};

/**
 * @ingroup iface_zwp_tablet_pad_v2
 */
static inline int
zwp_tablet_pad_v2_add_listener(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
			       const struct zwp_tablet_pad_v2_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_pad_v2,
				     (void (**)(void)) listener, data);
}

#define ZWP_TABLET_PAD_V2_SET_FEEDBACK 0
#define ZWP_TABLET_PAD_V2_DESTROY 1

/**
 * @ingroup iface_zwp_tablet_pad_v2
 */
#define ZWP_TABLET_PAD_V2_GROUP_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_v2
 */
#define ZWP_TABLET_PAD_V2_PATH_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_v2
 */
#define ZWP_TABLET_PAD_V2_BUTTONS_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_v2
 */
#define ZWP_TABLET_PAD_V2_DONE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_v2
 */
#define ZWP_TABLET_PAD_V2_BUTTON_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_v2
 */
#define ZWP_TABLET_PAD_V2_ENTER_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_v2
 */
#define ZWP_TABLET_PAD_V2_LEAVE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_v2
 */
#define ZWP_TABLET_PAD_V2_REMOVED_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_tablet_pad_v2
 */
#define ZWP_TABLET_PAD_V2_SET_FEEDBACK_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_tablet_pad_v2
 */
#define ZWP_TABLET_PAD_V2_DESTROY_SINCE_VERSION 1

/** @ingroup iface_zwp_tablet_pad_v2 */
static inline void
zwp_tablet_pad_v2_set_user_data(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_pad_v2, user_data);
}

/** @ingroup iface_zwp_tablet_pad_v2 */
static inline void *
zwp_tablet_pad_v2_get_user_data(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2)
{
	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_pad_v2);
}

static inline uint32_t
zwp_tablet_pad_v2_get_version(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2)
{
	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_v2);
}

/**
 * @ingroup iface_zwp_tablet_pad_v2
 *
 * Requests the compositor to use the provided feedback string
 * associated with this button. This request should be issued immediately
 * after a wp_tablet_pad_group.mode_switch event from the corresponding
 * group is received, or whenever a button is mapped to a different
 * action. See wp_tablet_pad_group.mode_switch for more details.
 *
 * Clients are encouraged to provide context-aware descriptions for
 * the actions associated with each button, and compositors may use
 * this information to offer visual feedback on the button layout
 * (e.g. on-screen displays).
 *
 * Button indices start at 0. Setting the feedback string on a button
 * that is reserved by the compositor (i.e. not belonging to any
 * wp_tablet_pad_group) does not generate an error but the compositor
 * is free to ignore the request.
 *
 * The provided string 'description' is a UTF-8 encoded string to be
 * associated with this ring, and is considered user-visible; general
 * internationalization rules apply.
 *
 * The serial argument will be that of the last
 * wp_tablet_pad_group.mode_switch event received for the group of this
 * button. Requests providing other serials than the most recent one will
 * be ignored.
 */
static inline void
zwp_tablet_pad_v2_set_feedback(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2, uint32_t button, const char *description, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_tablet_pad_v2,
			 ZWP_TABLET_PAD_V2_SET_FEEDBACK, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_v2), 0, button, description, serial);
}

/**
 * @ingroup iface_zwp_tablet_pad_v2
 *
 * Destroy the wp_tablet_pad object. Objects created from this object
 * are unaffected and should be destroyed separately.
 */
static inline void
zwp_tablet_pad_v2_destroy(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2)
{
	wl_proxy_marshal_flags((struct wl_proxy *) zwp_tablet_pad_v2,
			 ZWP_TABLET_PAD_V2_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_v2), WL_MARSHAL_FLAG_DESTROY);
}

#ifdef  __cplusplus
}
#endif

#endif
/* Generated by wayland-scanner 1.23.1 */

/*
 * Copyright 2014 © Stephen "Lyude" Chandler Paul
 * Copyright 2015-2016 © Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <stdbool.h>
#include <stdlib.h>
#include <stdint.h>
#include "wayland-util.h"

#ifndef __has_attribute
# define __has_attribute(x) 0  /* Compatibility with non-clang compilers. */
#endif

#if (__has_attribute(visibility) || defined(__GNUC__) && __GNUC__ >= 4)
#define WL_PRIVATE __attribute__ ((visibility("hidden")))
#else
#define WL_PRIVATE
#endif

extern const struct wl_interface wl_seat_interface;
extern const struct wl_interface wl_surface_interface;
extern const struct wl_interface zwp_tablet_pad_group_v2_interface;
extern const struct wl_interface zwp_tablet_pad_ring_v2_interface;
extern const struct wl_interface zwp_tablet_pad_strip_v2_interface;
extern const struct wl_interface zwp_tablet_pad_v2_interface;
extern const struct wl_interface zwp_tablet_seat_v2_interface;
extern const struct wl_interface zwp_tablet_tool_v2_interface;
extern const struct wl_interface zwp_tablet_v2_interface;

static const struct wl_interface *tablet_v2_types[] = {
	NULL,
	NULL,
	NULL,
	&zwp_tablet_seat_v2_interface,
	&wl_seat_interface,
	&zwp_tablet_v2_interface,
	&zwp_tablet_tool_v2_interface,
	&zwp_tablet_pad_v2_interface,
	NULL,
	&wl_surface_interface,
	NULL,
	NULL,
	NULL,
	&zwp_tablet_v2_interface,
	&wl_surface_interface,
	&zwp_tablet_pad_ring_v2_interface,
	&zwp_tablet_pad_strip_v2_interface,
	&zwp_tablet_pad_group_v2_interface,
	NULL,
	&zwp_tablet_v2_interface,
	&wl_surface_interface,
	NULL,
	&wl_surface_interface,
};

static const struct wl_message zwp_tablet_manager_v2_requests[] = {
	{ "get_tablet_seat", "no", tablet_v2_types + 3 },
	{ "destroy", "", tablet_v2_types + 0 },
};

WL_PRIVATE const struct wl_interface zwp_tablet_manager_v2_interface = {
	"zwp_tablet_manager_v2", 1,
	2, zwp_tablet_manager_v2_requests,
	0, NULL,
};

static const struct wl_message zwp_tablet_seat_v2_requests[] = {
	{ "destroy", "", tablet_v2_types + 0 },
};

static const struct wl_message zwp_tablet_seat_v2_events[] = {
	{ "tablet_added", "n", tablet_v2_types + 5 },
	{ "tool_added", "n", tablet_v2_types + 6 },
	{ "pad_added", "n", tablet_v2_types + 7 },
};

WL_PRIVATE const struct wl_interface zwp_tablet_seat_v2_interface = {
	"zwp_tablet_seat_v2", 1,
	1, zwp_tablet_seat_v2_requests,
	3, zwp_tablet_seat_v2_events,
};

static const struct wl_message zwp_tablet_tool_v2_requests[] = {
	{ "set_cursor", "u?oii", tablet_v2_types + 8 },
	{ "destroy", "", tablet_v2_types + 0 },
};

static const struct wl_message zwp_tablet_tool_v2_events[] = {
	{ "type", "u", tablet_v2_types + 0 },
	{ "hardware_serial", "uu", tablet_v2_types + 0 },
	{ "hardware_id_wacom", "uu", tablet_v2_types + 0 },
	{ "capability", "u", tablet_v2_types + 0 },
	{ "done", "", tablet_v2_types + 0 },
	{ "removed", "", tablet_v2_types + 0 },
	{ "proximity_in", "uoo", tablet_v2_types + 12 },
	{ "proximity_out", "", tablet_v2_types + 0 },
	{ "down", "u", tablet_v2_types + 0 },
	{ "up", "", tablet_v2_types + 0 },
	{ "motion", "ff", tablet_v2_types + 0 },
	{ "pressure", "u", tablet_v2_types + 0 },
	{ "distance", "u", tablet_v2_types + 0 },
	{ "tilt", "ff", tablet_v2_types + 0 },
	{ "rotation", "f", tablet_v2_types + 0 },
	{ "slider", "i", tablet_v2_types + 0 },
	{ "wheel", "fi", tablet_v2_types + 0 },
	{ "button", "uuu", tablet_v2_types + 0 },
	{ "frame", "u", tablet_v2_types + 0 },
};

WL_PRIVATE const struct wl_interface zwp_tablet_tool_v2_interface = {
	"zwp_tablet_tool_v2", 1,
	2, zwp_tablet_tool_v2_requests,
	19, zwp_tablet_tool_v2_events,
};

static const struct wl_message zwp_tablet_v2_requests[] = {
	{ "destroy", "", tablet_v2_types + 0 },
};

static const struct wl_message zwp_tablet_v2_events[] = {
	{ "name", "s", tablet_v2_types + 0 },
	{ "id", "uu", tablet_v2_types + 0 },
	{ "path", "s", tablet_v2_types + 0 },
	{ "done", "", tablet_v2_types + 0 },
	{ "removed", "", tablet_v2_types + 0 },
};

WL_PRIVATE const struct wl_interface zwp_tablet_v2_interface = {
	"zwp_tablet_v2", 1,
	1, zwp_tablet_v2_requests,
	5, zwp_tablet_v2_events,
};

static const struct wl_message zwp_tablet_pad_ring_v2_requests[] = {
	{ "set_feedback", "su", tablet_v2_types + 0 },
	{ "destroy", "", tablet_v2_types + 0 },
};

static const struct wl_message zwp_tablet_pad_ring_v2_events[] = {
	{ "source", "u", tablet_v2_types + 0 },
	{ "angle", "f", tablet_v2_types + 0 },
	{ "stop", "", tablet_v2_types + 0 },
	{ "frame", "u", tablet_v2_types + 0 },
};

WL_PRIVATE const struct wl_interface zwp_tablet_pad_ring_v2_interface = {
	"zwp_tablet_pad_ring_v2", 1,
	2, zwp_tablet_pad_ring_v2_requests,
	4, zwp_tablet_pad_ring_v2_events,
};

static const struct wl_message zwp_tablet_pad_strip_v2_requests[] = {
	{ "set_feedback", "su", tablet_v2_types + 0 },
	{ "destroy", "", tablet_v2_types + 0 },
};

static const struct wl_message zwp_tablet_pad_strip_v2_events[] = {
	{ "source", "u", tablet_v2_types + 0 },
	{ "position", "u", tablet_v2_types + 0 },
	{ "stop", "", tablet_v2_types + 0 },
	{ "frame", "u", tablet_v2_types + 0 },
};

WL_PRIVATE const struct wl_interface zwp_tablet_pad_strip_v2_interface = {
	"zwp_tablet_pad_strip_v2", 1,
	2, zwp_tablet_pad_strip_v2_requests,
	4, zwp_tablet_pad_strip_v2_events,
};

static const struct wl_message zwp_tablet_pad_group_v2_requests[] = {
	{ "destroy", "", tablet_v2_types + 0 },
};

static const struct wl_message zwp_tablet_pad_group_v2_events[] = {
	{ "buttons", "a", tablet_v2_types + 0 },
	{ "ring", "n", tablet_v2_types + 15 },
	{ "strip", "n", tablet_v2_types + 16 },
	{ "modes", "u", tablet_v2_types + 0 },
	{ "done", "", tablet_v2_types + 0 },
	{ "mode_switch", "uuu", tablet_v2_types + 0 },
};

WL_PRIVATE const struct wl_interface zwp_tablet_pad_group_v2_interface = {
	"zwp_tablet_pad_group_v2", 1,
	1, zwp_tablet_pad_group_v2_requests,
	6, zwp_tablet_pad_group_v2_events,
};

static const struct wl_message zwp_tablet_pad_v2_requests[] = {
	{ "set_feedback", "usu", tablet_v2_types + 0 },
	{ "destroy", "", tablet_v2_types + 0 },
};

static const struct wl_message zwp_tablet_pad_v2_events[] = {
	{ "group", "n", tablet_v2_types + 17 },
	{ "path", "s", tablet_v2_types + 0 },
	{ "buttons", "u", tablet_v2_types + 0 },
	{ "done", "", tablet_v2_types + 0 },
	{ "button", "uuu", tablet_v2_types + 0 },
	{ "enter", "uoo", tablet_v2_types + 18 },
	{ "leave", "uo", tablet_v2_types + 21 },
	{ "removed", "", tablet_v2_types + 0 },
};

WL_PRIVATE const struct wl_interface zwp_tablet_pad_v2_interface = {
	"zwp_tablet_pad_v2", 1,
	2, zwp_tablet_pad_v2_requests,
	8, zwp_tablet_pad_v2_events,
};

